diff --no-dereference -Nru kernel-22/kernel/arch/csky/silan_dlna/dev-amba.c kernel-central/kernel/arch/csky/silan_dlna/dev-amba.c
--- kernel-22/kernel/arch/csky/silan_dlna/dev-amba.c	2017-01-18 12:55:11.000000000 +0200
+++ kernel-central/kernel/arch/csky/silan_dlna/dev-amba.c	2017-02-12 13:01:43.293299217 +0200
@@ -8,24 +8,24 @@
 
 static struct pl08x_channel_data pl080_slave_data0[] = {
 	{//0
-		.bus_id = "spdif",
+		.bus_id = "spdif-tx",
 		.min_signal = 14,
 		.max_signal = 14,
 		.muxval = 0x00,
 	},
-	{//8
-		.bus_id = "iis adc",
+	{//1
+		.bus_id = "iis adc sd0",
 		.min_signal = 11,
 		.max_signal = 11,
 		.muxval = 0x00,
 	},
-	{//1
+	{//2
 		.bus_id = "iis dac",
 		.min_signal = 9,
 		.max_signal = 9,
 		.muxval = 0x00,
 	},
-	{//2
+	{//3
 		.bus_id = "uart1-rx",
 		.min_signal = 0,
 		.max_signal = 0,
@@ -43,20 +43,20 @@
 		.max_signal = 4,
 		.muxval = 0x00,
 	},
-	{//3
+	{//6
 		.bus_id = "uart1-tx",
 		.min_signal = 1,
 		.max_signal = 1,
 		.muxval = 0x00,
 	},
-	{//6
-		.bus_id = "i2c-rx",
+	{//7
+		.bus_id = "iis adc sd2", // "i2c-rx",
 		.min_signal = 2,
 		.max_signal = 2,
 		.muxval = 0x00,
 	},
-	{//7
-		.bus_id = "i2c-tx",
+	{//8
+		.bus_id = "iis adc sd1", // "i2c-tx",
 		.min_signal = 7,
 		.max_signal = 7,
 		.muxval = 0x00,
diff --no-dereference -Nru kernel-22/kernel/arch/csky/silan_dlna/dev-audio.c kernel-central/kernel/arch/csky/silan_dlna/dev-audio.c
--- kernel-22/kernel/arch/csky/silan_dlna/dev-audio.c	2017-01-18 12:55:11.000000000 +0200
+++ kernel-central/kernel/arch/csky/silan_dlna/dev-audio.c	2017-02-12 12:50:10.503112302 +0200
@@ -85,13 +85,13 @@
 		.flags	= IORESOURCE_MEM,
 	},
 	{
-		.start	= 1,
-		.end	= 1,
+		.start	= 2,
+		.end	= 2,
 		.flags	= IORESOURCE_DMA,
 	},
 	{
-		.start	= 8,
-		.end	= 8,
+		.start	= 1,
+		.end	= 1,
 		.flags	= IORESOURCE_DMA,
 	},
 };
diff --no-dereference -Nru kernel-22/kernel/arch/csky/silan_dlna/platform.c kernel-central/kernel/arch/csky/silan_dlna/platform.c
--- kernel-22/kernel/arch/csky/silan_dlna/platform.c	2017-02-10 04:19:40.096287351 +0200
+++ kernel-central/kernel/arch/csky/silan_dlna/platform.c	2017-02-12 13:00:39.207471254 +0200
@@ -272,7 +272,7 @@
     .num_resources  = ARRAY_SIZE(silan_otgusb_resource),
     .resource       = silan_otgusb_resource,
 };
-
+/*
 static struct resource silan_i2c_resource[] = 
 {
     [0] = {
@@ -286,13 +286,13 @@
         .flags  = IORESOURCE_IRQ,
     },    
     [2] = {
-        .start  = 1,
-        .end    = 1,
+        .start  = 8,
+        .end    = 8,
         .flags  = IORESOURCE_DMA,
     },
     [3] = {
-        .start  = 2,
-        .end    = 2,
+        .start  = 7,
+        .end    = 7,
         .flags  = IORESOURCE_DMA,
     },
 };
@@ -304,7 +304,7 @@
     .num_resources  = ARRAY_SIZE(silan_i2c_resource),
     .resource       = silan_i2c_resource,
 };
-
+*/
 static struct resource silan_spi_resource[] = {
     [0] = {
         .start = SILAN_SPI_PHY_BASE,
@@ -557,7 +557,7 @@
     .id                = -1,
 };
 #endif
-
+/*
 static struct i2c_gpio_platform_data i2c_gpio_adapter_data = 
 {
     .sda_pin = 32+12,
@@ -576,7 +576,7 @@
         .platform_data = &i2c_gpio_adapter_data,
     },
 };
-
+*/
 static struct timed_gpio vibrator = 
 {
     .name    = "vibrator",
@@ -695,7 +695,7 @@
     &silan_mac_device,    
     &silan_hostusb_device,
     &silan_otgusb_device,
-    &silan_i2c_device,
+//    &silan_i2c_device,
     &silan_spi_device,
     &silan_spi_ctrl_device,
     &silan_dsp_device,
@@ -716,7 +716,7 @@
     &silan_padmux_device,
     //&silan_pwm_device,
     //&silan_backlight,
-    &silan_i2c_gpio,    
+//    &silan_i2c_gpio,    
     &silan_timed_gpio,
     &silan_rtc_device,
     //&spi_silan_gpio_device,
diff --no-dereference -Nru kernel-22/kernel/arch/csky/silan_dlna/spi_board_info.c kernel-central/kernel/arch/csky/silan_dlna/spi_board_info.c
--- kernel-22/kernel/arch/csky/silan_dlna/spi_board_info.c	2017-01-18 12:55:11.000000000 +0200
+++ kernel-central/kernel/arch/csky/silan_dlna/spi_board_info.c	2017-02-10 04:56:29.361148819 +0200
@@ -84,6 +84,7 @@
 		.bus_num		 = 1,
 		.chip_select	 = 0,
 		},
+
 #if 0
 	[1] = {
 		//.modalias		 = "spidev",
@@ -108,6 +109,7 @@
 		.chip_select     = 0,
 		},
 #endif
+#if 0
 	[2] = {
 		.modalias		 = "silan-wmcodec",
 		.platform_data   = NULL,
@@ -118,6 +120,7 @@
 		.chip_select 	 = 3,
 		.bits_per_word	 = 16,
 		},
+#endif
 };
 EXPORT_SYMBOL(silan_spi_board_info);
 
diff --no-dereference -Nru kernel-22/kernel/.config kernel-central/kernel/.config
--- kernel-22/kernel/.config	2017-01-18 13:06:33.000000000 +0200
+++ kernel-central/kernel/.config	2017-02-12 12:16:09.101409532 +0200
@@ -212,7 +212,7 @@
 CONFIG_APB_FREQ=150000000
 CONFIG_RAM_BASE=0x0000000
 # CONFIG_HEARTBEAT is not set
-CONFIG_CMDLINE="root=/dev/mtdblock2 rootfstype=squashfs rw console=ttyAMA0,115200 rdinit=/sbin/init mem=28M"
+CONFIG_CMDLINE="console=ttyAMA0,115200 console=tty0 ip=dhcp root=/dev/nfs rw init=/sbin/init mem=28M"
 # CONFIG_DIOSCURI is not set
 # CONFIG_CK6408EVB is not set
 # CONFIG_CKM5208 is not set
@@ -265,11 +265,6 @@
 #
 CONFIG_PACKET=y
 CONFIG_UNIX=y
-CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
-# CONFIG_XFRM_SUB_POLICY is not set
-# CONFIG_XFRM_MIGRATE is not set
-# CONFIG_XFRM_STATISTICS is not set
 # CONFIG_NET_KEY is not set
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
@@ -289,7 +284,7 @@
 # CONFIG_INET_ESP is not set
 # CONFIG_INET_IPCOMP is not set
 # CONFIG_INET_XFRM_TUNNEL is not set
-CONFIG_INET_TUNNEL=y
+# CONFIG_INET_TUNNEL is not set
 # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
 # CONFIG_INET_XFRM_MODE_TUNNEL is not set
 # CONFIG_INET_XFRM_MODE_BEET is not set
@@ -299,26 +294,7 @@
 CONFIG_TCP_CONG_CUBIC=y
 CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_TCP_MD5SIG is not set
-CONFIG_IPV6=y
-# CONFIG_IPV6_PRIVACY is not set
-# CONFIG_IPV6_ROUTER_PREF is not set
-# CONFIG_IPV6_OPTIMISTIC_DAD is not set
-# CONFIG_INET6_AH is not set
-# CONFIG_INET6_ESP is not set
-# CONFIG_INET6_IPCOMP is not set
-# CONFIG_IPV6_MIP6 is not set
-# CONFIG_INET6_XFRM_TUNNEL is not set
-# CONFIG_INET6_TUNNEL is not set
-CONFIG_INET6_XFRM_MODE_TRANSPORT=y
-CONFIG_INET6_XFRM_MODE_TUNNEL=y
-CONFIG_INET6_XFRM_MODE_BEET=y
-# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
-CONFIG_IPV6_SIT=y
-# CONFIG_IPV6_SIT_6RD is not set
-CONFIG_IPV6_NDISC_NODETYPE=y
-# CONFIG_IPV6_TUNNEL is not set
-# CONFIG_IPV6_MULTIPLE_TABLES is not set
-# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6 is not set
 CONFIG_ANDROID_PARANOID_NETWORK=y
 CONFIG_NET_ACTIVITY_STATS=y
 # CONFIG_NETWORK_SECMARK is not set
@@ -399,7 +375,6 @@
 # CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
 # CONFIG_NETFILTER_XT_MATCH_OSF is not set
 # CONFIG_NETFILTER_XT_MATCH_OWNER is not set
-CONFIG_NETFILTER_XT_MATCH_POLICY=m
 # CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
 # CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
 # CONFIG_NETFILTER_XT_MATCH_QUOTA2 is not set
@@ -446,14 +421,6 @@
 # CONFIG_IP_NF_MANGLE is not set
 # CONFIG_IP_NF_RAW is not set
 # CONFIG_IP_NF_ARPTABLES is not set
-
-#
-# IPv6: Netfilter Configuration
-#
-# CONFIG_NF_DEFRAG_IPV6 is not set
-# CONFIG_NF_CONNTRACK_IPV6 is not set
-# CONFIG_IP6_NF_QUEUE is not set
-# CONFIG_IP6_NF_IPTABLES is not set
 # CONFIG_IP_DCCP is not set
 # CONFIG_IP_SCTP is not set
 # CONFIG_RDS is not set
@@ -523,32 +490,7 @@
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
 # CONFIG_AF_RXRPC is not set
-CONFIG_WIRELESS=y
-CONFIG_WIRELESS_EXT=y
-CONFIG_WEXT_CORE=y
-CONFIG_WEXT_PROC=y
-CONFIG_CFG80211=y
-# CONFIG_NL80211_TESTMODE is not set
-# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
-# CONFIG_CFG80211_REG_DEBUG is not set
-CONFIG_CFG80211_DEFAULT_PS=y
-# CONFIG_CFG80211_DEBUGFS is not set
-# CONFIG_CFG80211_INTERNAL_REGDB is not set
-CONFIG_CFG80211_WEXT=y
-CONFIG_WIRELESS_EXT_SYSFS=y
-# CONFIG_LIB80211 is not set
-# CONFIG_CFG80211_ALLOW_RECONNECT is not set
-CONFIG_MAC80211=y
-CONFIG_MAC80211_HAS_RC=y
-# CONFIG_MAC80211_RC_PID is not set
-CONFIG_MAC80211_RC_MINSTREL=y
-CONFIG_MAC80211_RC_MINSTREL_HT=y
-CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
-CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
-# CONFIG_MAC80211_MESH is not set
-# CONFIG_MAC80211_LEDS is not set
-# CONFIG_MAC80211_DEBUGFS is not set
-# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIRELESS is not set
 # CONFIG_WIMAX is not set
 # CONFIG_RFKILL is not set
 # CONFIG_NET_9P is not set
@@ -720,63 +662,14 @@
 # CONFIG_BONDING is not set
 # CONFIG_MACVLAN is not set
 # CONFIG_EQUALIZER is not set
-CONFIG_TUN=y
+# CONFIG_TUN is not set
 # CONFIG_VETH is not set
 CONFIG_MII=y
-CONFIG_PHYLIB=y
-
-#
-# MII PHY device drivers
-#
-# CONFIG_MARVELL_PHY is not set
-# CONFIG_DAVICOM_PHY is not set
-# CONFIG_QSEMI_PHY is not set
-# CONFIG_LXT_PHY is not set
-# CONFIG_CICADA_PHY is not set
-# CONFIG_VITESSE_PHY is not set
-# CONFIG_SMSC_PHY is not set
-# CONFIG_BROADCOM_PHY is not set
-# CONFIG_ICPLUS_PHY is not set
-# CONFIG_REALTEK_PHY is not set
-# CONFIG_NATIONAL_PHY is not set
-# CONFIG_STE10XP is not set
-# CONFIG_LSI_ET1011C_PHY is not set
-# CONFIG_DP83848_PHY is not set
-# CONFIG_MICREL_PHY is not set
-# CONFIG_FIXED_PHY is not set
-# CONFIG_MDIO_BITBANG is not set
+# CONFIG_PHYLIB is not set
 # CONFIG_NET_ETHERNET is not set
-CONFIG_NETDEV_1000=y
-CONFIG_STMMAC_ETH=y
-# CONFIG_SILAN_GMAC_TX_POSTCHK is not set
-# CONFIG_STMMAC_DA is not set
-# CONFIG_STMMAC_DUAL_MAC is not set
+# CONFIG_NETDEV_1000 is not set
 # CONFIG_NETDEV_10000 is not set
-CONFIG_WLAN=y
-# CONFIG_LIBERTAS_THINFIRM is not set
-# CONFIG_AT76C50X_USB is not set
-# CONFIG_USB_ZD1201 is not set
-# CONFIG_USB_NET_RNDIS_WLAN is not set
-# CONFIG_RTL8187 is not set
-# CONFIG_MAC80211_HWSIM is not set
-# CONFIG_WIFI_CONTROL_FUNC is not set
-# CONFIG_ATH_COMMON is not set
-# CONFIG_B43 is not set
-# CONFIG_B43LEGACY is not set
-# CONFIG_BCM4329 is not set
-# CONFIG_BCMDHD is not set
-# CONFIG_HOSTAP is not set
-# CONFIG_IWM is not set
-# CONFIG_LIBERTAS is not set
-# CONFIG_P54_COMMON is not set
-# CONFIG_RT2X00 is not set
-# CONFIG_WL1251 is not set
-# CONFIG_WL12XX_MENU is not set
-# CONFIG_ZD1211RW is not set
-# CONFIG_MWIFIEX is not set
-# CONFIG_RTL8192CU is not set
-CONFIG_RTL8188EU=y
-# CONFIG_RTL8723BU is not set
+# CONFIG_WLAN is not set
 
 #
 # Enable WiMAX (Networking options) to see the WiMAX drivers
@@ -789,8 +682,29 @@
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_PEGASUS is not set
 # CONFIG_USB_RTL8150 is not set
-# CONFIG_USB_USBNET is not set
+CONFIG_USB_RTL8152=y
+CONFIG_USB_USBNET=y
+# CONFIG_USB_NET_AX8817X is not set
+CONFIG_USB_NET_AX8877X=y
+CONFIG_USB_NET_CDCETHER=y
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+# CONFIG_USB_NET_INT51X1 is not set
 # CONFIG_USB_IPHETH is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_VL600 is not set
 # CONFIG_WAN is not set
 
 #
@@ -840,7 +754,6 @@
 # CONFIG_INPUT_CM109 is not set
 # CONFIG_INPUT_UINPUT is not set
 # CONFIG_INPUT_GPIO is not set
-# CONFIG_INPUT_PCF8574 is not set
 # CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
 # CONFIG_INPUT_ADXL34X is not set
 # CONFIG_INPUT_CMA3000 is not set
@@ -910,55 +823,17 @@
 # CONFIG_RAW_DRIVER is not set
 # CONFIG_TCG_TPM is not set
 # CONFIG_RAMOOPS is not set
-CONFIG_SILAN_TESTIO=y
+# CONFIG_SILAN_TESTIO is not set
 CONFIG_DLNA_GPIO=y
 # CONFIG_DLNA_PWM is not set
-CONFIG_SILAN_LCD=y
+# CONFIG_SILAN_LCD is not set
 # CONFIG_SILAN_LCD_SPI is not set
 CONFIG_SILAN_PADMUX=y
 # CONFIG_SILAN_DSP is not set
 CONFIG_SILAN_DSP_SUBSYSTEM=y
 CONFIG_SILAN_DRM=y
 # CONFIG_SILAN_BLUETOOTH is not set
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-CONFIG_I2C_COMPAT=y
-CONFIG_I2C_CHARDEV=y
-# CONFIG_I2C_MUX is not set
-CONFIG_I2C_HELPER_AUTO=y
-CONFIG_I2C_ALGOBIT=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-CONFIG_I2C_GPIO=y
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_PXA_PCI is not set
-# CONFIG_I2C_SIMTEC is not set
-# CONFIG_I2C_XILINX is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_DIOLAN_U2C is not set
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-# CONFIG_I2C_TINY_USB is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_I2C_STUB is not set
-# CONFIG_I2C_SILAN is not set
-# CONFIG_I2C_SILAN_NEW is not set
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C is not set
 CONFIG_SPI=y
 CONFIG_SPI_MASTER=y
 
@@ -1013,12 +888,6 @@
 #
 # I2C GPIO expanders:
 #
-# CONFIG_GPIO_MAX7300 is not set
-# CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_PCA953X is not set
-# CONFIG_GPIO_PCF857X is not set
-# CONFIG_GPIO_SX150X is not set
-# CONFIG_GPIO_ADP5588 is not set
 
 #
 # PCI GPIO expanders:
@@ -1089,34 +958,28 @@
 #
 # CONFIG_DISPLAY_SUPPORT is not set
 CONFIG_SOUND=y
-CONFIG_SOUND_OSS_CORE=y
-CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+# CONFIG_SOUND_OSS_CORE is not set
 CONFIG_SND=y
 CONFIG_SND_TIMER=y
 CONFIG_SND_PCM=y
 CONFIG_SND_JACK=y
 # CONFIG_SND_SEQUENCER is not set
-CONFIG_SND_OSSEMUL=y
-CONFIG_SND_MIXER_OSS=y
-CONFIG_SND_PCM_OSS=y
-CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
 CONFIG_SND_HRTIMER=y
 # CONFIG_SND_DYNAMIC_MINORS is not set
-CONFIG_SND_SUPPORT_OLD_API=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
 CONFIG_SND_VERBOSE_PROCFS=y
-# CONFIG_SND_VERBOSE_PRINTK is not set
-# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VERBOSE_PRINTK=y
+CONFIG_SND_DEBUG=y
+CONFIG_SND_DEBUG_VERBOSE=y
+CONFIG_SND_PCM_XRUN_DEBUG=y
 # CONFIG_SND_RAWMIDI_SEQ is not set
 # CONFIG_SND_OPL3_LIB_SEQ is not set
 # CONFIG_SND_OPL4_LIB_SEQ is not set
 # CONFIG_SND_SBAWE_SEQ is not set
 # CONFIG_SND_EMU10K1_SEQ is not set
-CONFIG_SND_DRIVERS=y
-# CONFIG_SND_DUMMY is not set
-# CONFIG_SND_ALOOP is not set
-# CONFIG_SND_MTPAV is not set
-# CONFIG_SND_SERIAL_U16550 is not set
-# CONFIG_SND_MPU401 is not set
+# CONFIG_SND_DRIVERS is not set
 # CONFIG_SND_SPI is not set
 # CONFIG_SND_USB is not set
 CONFIG_SND_SOC=y
@@ -1126,10 +989,10 @@
 #
 # IIS DAC CODEC
 #
-CONFIG_I2S_DLNA_DAC_INTRA=y
-CONFIG_SILAN_INNER_CODEC_LINEOUT=y
-# CONFIG_SILAN_INNER_CODEC_HEADPHONE is not set
-# CONFIG_I2S_DLNA_DAC_EXTRA is not set
+# CONFIG_I2S_DLNA_DAC_INTRA is not set
+CONFIG_I2S_DLNA_DAC_EXTRA=y
+CONFIG_I2S_DLNA_DAC_MASTER=y
+# CONFIG_I2S_DLNA_DAC_SLAVE is not set
 
 #
 # IIS ADC CODEC
@@ -1145,7 +1008,7 @@
 # CONFIG_SND_SOC_ALL_CODECS is not set
 CONFIG_SND_SOC_SILAN=y
 # CONFIG_SND_SOC_UDA1380 is not set
-CONFIG_SOUND_PRIME=y
+# CONFIG_SOUND_PRIME is not set
 # CONFIG_HID_SUPPORT is not set
 CONFIG_USB_SUPPORT=y
 CONFIG_USB_ARCH_HAS_HCD=y
@@ -1289,16 +1152,9 @@
 #
 # LED drivers
 #
-# CONFIG_LEDS_LM3530 is not set
-# CONFIG_LEDS_PCA9532 is not set
 CONFIG_LEDS_GPIO=y
 CONFIG_LEDS_GPIO_PLATFORM=y
-# CONFIG_LEDS_LP3944 is not set
-# CONFIG_LEDS_LP5521 is not set
-# CONFIG_LEDS_LP5523 is not set
-# CONFIG_LEDS_PCA955X is not set
 # CONFIG_LEDS_DAC124S085 is not set
-# CONFIG_LEDS_BD2802 is not set
 # CONFIG_LEDS_LT3593 is not set
 CONFIG_LEDS_TRIGGERS=y
 
@@ -1336,29 +1192,6 @@
 # CONFIG_RTC_DRV_TEST is not set
 
 #
-# I2C RTC drivers
-#
-# CONFIG_RTC_DRV_DS1307 is not set
-# CONFIG_RTC_DRV_DS1374 is not set
-# CONFIG_RTC_DRV_DS1672 is not set
-# CONFIG_RTC_DRV_DS3232 is not set
-# CONFIG_RTC_DRV_MAX6900 is not set
-# CONFIG_RTC_DRV_RS5C372 is not set
-# CONFIG_RTC_DRV_ISL1208 is not set
-# CONFIG_RTC_DRV_ISL12022 is not set
-# CONFIG_RTC_DRV_X1205 is not set
-# CONFIG_RTC_DRV_PCF8563 is not set
-# CONFIG_RTC_DRV_PCF8583 is not set
-# CONFIG_RTC_DRV_M41T80 is not set
-# CONFIG_RTC_DRV_BQ32K is not set
-# CONFIG_RTC_DRV_S35390A is not set
-# CONFIG_RTC_DRV_FM3130 is not set
-# CONFIG_RTC_DRV_RX8581 is not set
-# CONFIG_RTC_DRV_RX8025 is not set
-# CONFIG_RTC_DRV_EM3027 is not set
-# CONFIG_RTC_DRV_RV3029C2 is not set
-
-#
 # SPI RTC drivers
 #
 # CONFIG_RTC_DRV_M41T93 is not set
@@ -1392,7 +1225,7 @@
 #
 # CONFIG_RTC_DRV_PL030 is not set
 # CONFIG_RTC_DRV_PL031 is not set
-# CONFIG_RTC_DRV_SILAN is not set
+CONFIG_RTC_DRV_SILAN=y
 CONFIG_DMADEVICES=y
 # CONFIG_DMADEVICES_DEBUG is not set
 
diff --no-dereference -Nru kernel-22/kernel/drivers/dma/dsp_pl08x.c kernel-central/kernel/drivers/dma/dsp_pl08x.c
--- kernel-22/kernel/drivers/dma/dsp_pl08x.c	2017-01-18 12:55:12.000000000 +0200
+++ kernel-central/kernel/drivers/dma/dsp_pl08x.c	2017-02-12 13:10:29.957975726 +0200
@@ -213,7 +213,7 @@
 	//dev_vdbg(&pl08x->adev->dev,
 #if 0
 	printk(
-		"WRITE channel %d: csrc=0x%08x, cdst=0x%08x, "
+		"--- [GRIF] --- WRITE channel %d: csrc=0x%08x, cdst=0x%08x, "
 		"clli=0x%08x, cctl=0x%08x, ccfg=0x%08x, phychan_base: 0x%08x\n",
 		phychan->id, lli->src, lli->dst, lli->lli, lli->cctl,
 		txd->ccfg, phychan->base);
@@ -967,7 +967,7 @@
 
 	//dev_dbg(&pl08x->adev->dev, "allocated physical channel %d and signal %d for xfer on %s\n",
 #if 0
-	printk("allocated physical channel %d and signal %d for xfer on %s\n",
+	printk("--- [GRIF] --- allocated physical channel %d and signal %d for xfer on %s\n",
 		 ch->id,
 		 ch->signal,
 		 plchan->name);
diff --no-dereference -Nru kernel-22/kernel/drivers/net/usb/asix.h kernel-central/kernel/drivers/net/usb/asix.h
--- kernel-22/kernel/drivers/net/usb/asix.h	1970-01-01 03:00:00.000000000 +0300
+++ kernel-central/kernel/drivers/net/usb/asix.h	2016-12-11 14:42:48.000000000 +0200
@@ -0,0 +1,565 @@
+#ifndef	__LINUX_USBNET_ASIX_H
+#define	__LINUX_USBNET_ASIX_H
+
+/*
+ * Turn on this flag if the implementation of your USB host controller
+ * cannot handle non-double word aligned buffer.
+ * When turn on this flag, driver will fixup egress packet aligned on double
+ * word boundary before deliver to USB host controller. And will Disable the
+ * function "skb_reserve (skb, NET_IP_ALIGN)" to retain the buffer aligned on
+ * double word alignment for ingress packets.
+ */
+#define AX_FORCE_BUFF_ALIGN		1
+
+//#define RX_SKB_COPY
+
+#define AX_MONITOR_MODE			0x01
+#define AX_MONITOR_LINK			0x02
+#define AX_MONITOR_MAGIC		0x04
+#define AX_MONITOR_HSFS			0x10
+
+/* AX88172 Medium Status Register values */
+#define AX_MEDIUM_FULL_DUPLEX		0x02
+#define AX_MEDIUM_TX_ABORT_ALLOW	0x04
+#define AX_MEDIUM_FLOW_CONTROL_EN	0x10
+#define AX_MCAST_FILTER_SIZE		8
+#define AX_MAX_MCAST			64
+
+#define AX_EEPROM_LEN			0x40
+
+#define AX_SWRESET_CLEAR		0x00
+#define AX_SWRESET_RR			0x01
+#define AX_SWRESET_RT			0x02
+#define AX_SWRESET_PRTE			0x04
+#define AX_SWRESET_PRL			0x08
+#define AX_SWRESET_BZ			0x10
+#define AX_SWRESET_IPRL			0x20
+#define AX_SWRESET_IPPD			0x40
+#define AX_SWRESET_IPOSC		0x0080
+#define AX_SWRESET_IPPSL_0		0x0100
+#define AX_SWRESET_IPPSL_1		0x0200
+#define AX_SWRESET_IPCOPS		0x0400
+#define AX_SWRESET_IPCOPSC		0x0800
+#define AX_SWRESET_AUTODETACH		0x1000
+#define AX_SWRESET_WOLLP		0x8000
+
+#define AX88772_IPG0_DEFAULT		0x15
+#define AX88772_IPG1_DEFAULT		0x0c
+#define AX88772_IPG2_DEFAULT		0x0E
+
+#define AX88772A_IPG0_DEFAULT		0x15
+#define AX88772A_IPG1_DEFAULT		0x16
+#define AX88772A_IPG2_DEFAULT		0x1A
+
+#define AX88772_MEDIUM_FULL_DUPLEX	0x0002
+#define AX88772_MEDIUM_RESERVED		0x0004
+#define AX88772_MEDIUM_RX_FC_ENABLE	0x0010
+#define AX88772_MEDIUM_TX_FC_ENABLE	0x0020
+#define AX88772_MEDIUM_PAUSE_FORMAT	0x0080
+#define AX88772_MEDIUM_RX_ENABLE	0x0100
+#define AX88772_MEDIUM_100MB		0x0200
+#define AX88772_MEDIUM_DEFAULT	\
+	(AX88772_MEDIUM_FULL_DUPLEX | AX88772_MEDIUM_RX_FC_ENABLE | \
+	 AX88772_MEDIUM_TX_FC_ENABLE | AX88772_MEDIUM_100MB | \
+	 AX88772_MEDIUM_RESERVED | AX88772_MEDIUM_RX_ENABLE)
+
+#define AX_CMD_SET_SW_MII		0x06
+#define AX_CMD_READ_MII_REG		0x07
+#define AX_CMD_WRITE_MII_REG		0x08
+#define AX_CMD_READ_STATMNGSTS_REG	0x09
+	#define AX_HOST_EN		0x01
+
+#define AX_CMD_SET_HW_MII		0x0a
+#define AX_CMD_READ_EEPROM		0x0b
+#define AX_CMD_WRITE_EEPROM		0x0c
+#define AX_CMD_WRITE_EEPROM_EN		0x0d
+#define AX_CMD_WRITE_EEPROM_DIS		0x0e
+#define AX_CMD_WRITE_RX_CTL		0x10
+#define AX_CMD_READ_IPG012		0x11
+#define AX_CMD_WRITE_IPG0		0x12
+#define AX_CMD_WRITE_IPG1		0x13
+#define AX_CMD_WRITE_IPG2		0x14
+#define AX_CMD_WRITE_MULTI_FILTER	0x16
+#define AX_CMD_READ_NODE_ID		0x17
+#define AX_CMD_READ_PHY_ID		0x19
+#define AX_CMD_READ_MEDIUM_MODE		0x1a
+#define AX_CMD_WRITE_MEDIUM_MODE	0x1b
+#define AX_CMD_READ_MONITOR_MODE	0x1c
+#define AX_CMD_WRITE_MONITOR_MODE	0x1d
+#define AX_CMD_WRITE_GPIOS		0x1f
+#define AX_CMD_SW_RESET			0x20
+#define AX_CMD_SW_PHY_STATUS		0x21
+#define AX_CMD_SW_PHY_SELECT		0x22
+	#define AX_PHYSEL_PSEL		(1 << 0)
+	#define AX_PHYSEL_ASEL		(1 << 1)
+	#define AX_PHYSEL_SSMII		(0 << 2)
+	#define AX_PHYSEL_SSRMII	(1 << 2)
+	#define AX_PHYSEL_SSRRMII	(3 << 2)
+	#define AX_PHYSEL_SSEN		(1 << 4)
+#define AX88772_CMD_READ_NODE_ID	0x13
+#define AX88772_CMD_WRITE_NODE_ID	0x14
+#define AX_CMD_READ_WKFARY		0x23
+#define AX_CMD_WRITE_WKFARY		0x24
+#define AX_CMD_READ_RXCOE_CTL		0x2b
+#define AX_CMD_WRITE_RXCOE_CTL		0x2c
+#define AX_CMD_READ_TXCOE_CTL		0x2d
+#define AX_CMD_WRITE_TXCOE_CTL		0x2e
+
+#define REG_LENGTH			2
+#define PHY_ID_MASK			0x1f
+
+#define AX_RXCOE_IPCE			0x0001
+#define AX_RXCOE_IPVE			0x0002
+#define AX_RXCOE_V6VE			0x0004
+#define AX_RXCOE_TCPE			0x0008
+#define AX_RXCOE_UDPE			0x0010
+#define AX_RXCOE_ICMP			0x0020
+#define AX_RXCOE_IGMP			0x0040
+#define AX_RXCOE_ICV6			0x0080
+#define AX_RXCOE_TCPV6			0x0100
+#define AX_RXCOE_UDPV6			0x0200
+#define AX_RXCOE_ICMV6			0x0400
+#define AX_RXCOE_IGMV6			0x0800
+#define AX_RXCOE_ICV6V6			0x1000
+#define AX_RXCOE_FOPC			0x8000
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22)
+#define AX_RXCOE_DEF_CSUM		(AX_RXCOE_IPCE | AX_RXCOE_IPVE | \
+					 AX_RXCOE_V6VE | AX_RXCOE_TCPE | \
+					 AX_RXCOE_UDPE |  AX_RXCOE_ICV6 | \
+					 AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6)
+#else
+#define AX_RXCOE_DEF_CSUM		(AX_RXCOE_IPCE | AX_RXCOE_IPVE | \
+					 AX_RXCOE_TCPE | AX_RXCOE_UDPE)
+#endif
+
+#define AX_RXCOE_64TE			0x0100
+#define AX_RXCOE_PPPOE			0x0200
+#define AX_RXCOE_RPCE			0x8000
+
+#define AX_TXCOE_IP			0x0001
+#define AX_TXCOE_TCP			0x0002
+#define AX_TXCOE_UDP			0x0004
+#define AX_TXCOE_ICMP			0x0008
+#define AX_TXCOE_IGMP			0x0010
+#define AX_TXCOE_ICV6			0x0020
+
+#define AX_TXCOE_TCPV6			0x0100
+#define AX_TXCOE_UDPV6			0x0200
+#define AX_TXCOE_ICMV6			0x0400
+#define AX_TXCOE_IGMV6			0x0800
+#define AX_TXCOE_ICV6V6			0x1000
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22)
+#define AX_TXCOE_DEF_CSUM		(AX_TXCOE_TCP | AX_TXCOE_UDP | \
+					 AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6)
+#else
+#define AX_TXCOE_DEF_CSUM		(AX_TXCOE_TCP | AX_TXCOE_UDP)
+#endif
+
+#define AX_TXCOE_64TE			0x0001
+#define AX_TXCOE_PPPE			0x0002
+
+#define AX88772B_MAX_BULKIN_2K		0
+#define AX88772B_MAX_BULKIN_4K		1
+#define AX88772B_MAX_BULKIN_6K		2
+#define AX88772B_MAX_BULKIN_8K		3
+#define AX88772B_MAX_BULKIN_16K		4
+#define AX88772B_MAX_BULKIN_20K		5
+#define AX88772B_MAX_BULKIN_24K		6
+#define AX88772B_MAX_BULKIN_32K		7
+struct {unsigned short size, byte_cnt, threshold; } AX88772B_BULKIN_SIZE[] = {
+	/* 2k */
+	{2048, 0x8000, 0x8001},
+	/* 4k */
+	{4096, 0x8100, 0x8147},
+	/* 6k */
+	{6144, 0x8200, 0x81EB},
+	/* 8k */
+	{8192, 0x8300, 0x83D7},
+	/* 16 */
+	{16384, 0x8400, 0x851E},
+	/* 20k */
+	{20480, 0x8500, 0x8666},
+	/* 24k */
+	{24576, 0x8600, 0x87AE},
+	/* 32k */
+	{32768, 0x8700, 0x8A3D},
+};
+
+
+#define AX_RX_CTL_RH1M			0x0100		/* Enable RX-Header mode 0 */
+#define AX_RX_CTL_RH2M			0x0200		/* Enable IP header in receive buffer aligned on 32-bit aligment */
+#define AX_RX_CTL_RH3M			0x0400		/* checksum value in rx header 3 */
+#define AX_RX_HEADER_DEFAULT		(AX_RX_CTL_RH1M | AX_RX_CTL_RH2M)
+
+#define AX_RX_CTL_MFB			0x0300		/* Maximum Frame size 16384bytes */
+#define AX_RX_CTL_START			0x0080		/* Ethernet MAC start */
+#define AX_RX_CTL_AP			0x0020		/* Accept physcial address from Multicast array */
+#define AX_RX_CTL_AM			0x0010
+#define AX_RX_CTL_AB			0x0008		/* Accetp Brocadcast frames*/
+#define AX_RX_CTL_SEP			0x0004		/* Save error packets */
+#define AX_RX_CTL_AMALL			0x0002		/* Accetp all multicast frames */
+#define AX_RX_CTL_PRO			0x0001		/* Promiscuous Mode */
+#define AX_RX_CTL_STOP			0x0000		/* Stop MAC */
+
+#define AX_MONITOR_MODE			0x01
+#define AX_MONITOR_LINK			0x02
+#define AX_MONITOR_MAGIC		0x04
+#define AX_MONITOR_HSFS			0x10
+
+#define AX_MCAST_FILTER_SIZE		8
+#define AX_MAX_MCAST			64
+#define AX_INTERRUPT_BUFSIZE		8
+
+#define AX_EEPROM_LEN			0x40
+#define AX_EEPROM_MAGIC			0xdeadbeef
+#define EEPROMMASK			0x7f
+
+/* GPIO REGISTER */
+#define AXGPIOS_GPO0EN			0X01 /* 1 << 0 */
+#define AXGPIOS_GPO0			0X02 /* 1 << 1 */
+#define AXGPIOS_GPO1EN			0X04 /*	1 << 2 */
+#define AXGPIOS_GPO1			0X08 /* 1 << 3 */
+#define AXGPIOS_GPO2EN			0X10 /* 1 << 4 */
+#define AXGPIOS_GPO2			0X20 /* 1 << 5 */
+#define AXGPIOS_RSE			0X80 /* 1 << 7 */
+
+/* TX-header format */
+#define AX_TX_HDR_CPHI			0x4000
+#define AX_TX_HDR_DICF			0x8000
+
+/* GMII register definitions */
+#define GMII_PHY_CONTROL		0x00	/* control reg */
+#define GMII_PHY_STATUS			0x01	/* status reg */
+#define GMII_PHY_OUI			0x02	/* most of the OUI bits */
+#define GMII_PHY_MODEL			0x03	/* model/rev bits, and rest of OUI */
+#define GMII_PHY_ANAR			0x04	/* AN advertisement reg */
+#define GMII_PHY_ANLPAR			0x05	/* AN Link Partner */
+#define GMII_PHY_ANER			0x06	/* AN expansion reg */
+#define GMII_PHY_1000BT_CONTROL		0x09	/* control reg for 1000BT */
+#define GMII_PHY_1000BT_STATUS		0x0A	/* status reg for 1000BT */
+
+/* Bit definitions: GMII Control */
+#define GMII_CONTROL_RESET		0x8000	/* reset bit in control reg */
+#define GMII_CONTROL_LOOPBACK		0x4000	/* loopback bit in control reg */
+#define GMII_CONTROL_10MB		0x0000	/* 10 Mbit */
+#define GMII_CONTROL_100MB		0x2000	/* 100Mbit */
+#define GMII_CONTROL_1000MB		0x0040	/* 1000Mbit */
+#define GMII_CONTROL_SPEED_BITS		0x2040	/* speed bit mask */
+#define GMII_CONTROL_ENABLE_AUTO	0x1000	/* autonegotiate enable */
+#define GMII_CONTROL_POWER_DOWN		0x0800
+#define GMII_CONTROL_ISOLATE		0x0400	/* islolate bit */
+#define GMII_CONTROL_START_AUTO		0x0200	/* restart autonegotiate */
+#define GMII_CONTROL_FULL_DUPLEX	0x0100
+
+/* Bit definitions: GMII Status */
+#define GMII_STATUS_100MB_MASK		0xE000	/* any of these indicate 100 Mbit */
+#define GMII_STATUS_10MB_MASK		0x1800	/* either of these indicate 10 Mbit */
+#define GMII_STATUS_AUTO_DONE		0x0020	/* auto negotiation complete */
+#define GMII_STATUS_AUTO		0x0008	/* auto negotiation is available */
+#define GMII_STATUS_LINK_UP		0x0004	/* link status bit */
+#define GMII_STATUS_EXTENDED		0x0001	/* extended regs exist */
+#define GMII_STATUS_100T4		0x8000	/* capable of 100BT4 */
+#define GMII_STATUS_100TXFD		0x4000	/* capable of 100BTX full duplex */
+#define GMII_STATUS_100TX		0x2000	/* capable of 100BTX */
+#define GMII_STATUS_10TFD		0x1000	/* capable of 10BT full duplex */
+#define GMII_STATUS_10T			0x0800	/* capable of 10BT */
+
+/* Bit definitions: Auto-Negotiation Advertisement */
+#define GMII_ANAR_ASYM_PAUSE		0x0800	/* support asymetric pause */
+#define GMII_ANAR_PAUSE			0x0400	/* support pause packets */
+#define GMII_ANAR_100T4			0x0200	/* support 100BT4 */
+#define GMII_ANAR_100TXFD		0x0100	/* support 100BTX full duplex */
+#define GMII_ANAR_100TX			0x0080	/* support 100BTX half duplex */
+#define GMII_ANAR_10TFD			0x0040	/* support 10BT full duplex */
+#define GMII_ANAR_10T			0x0020	/* support 10BT half duplex */
+#define GMII_SELECTOR_FIELD		0x001F	/* selector field. */
+
+/* Bit definitions: Auto-Negotiation Link Partner Ability */
+#define GMII_ANLPAR_100T4		0x0200	/* support 100BT4 */
+#define GMII_ANLPAR_100TXFD		0x0100	/* support 100BTX full duplex */
+#define GMII_ANLPAR_100TX		0x0080	/* support 100BTX half duplex */
+#define GMII_ANLPAR_10TFD		0x0040	/* support 10BT full duplex */
+#define GMII_ANLPAR_10T			0x0020	/* support 10BT half duplex */
+#define GMII_ANLPAR_PAUSE		0x0400	/* support pause packets */
+#define GMII_ANLPAR_ASYM_PAUSE		0x0800	/* support asymetric pause */
+#define GMII_ANLPAR_ACK			0x4000	/* means LCB was successfully rx'd */
+#define GMII_SELECTOR_8023		0x0001;
+
+/* Bit definitions: 1000BaseT AUX Control */
+#define GMII_1000_AUX_CTRL_MASTER_SLAVE		0x1000
+#define GMII_1000_AUX_CTRL_FD_CAPABLE		0x0200	/* full duplex capable */
+#define GMII_1000_AUX_CTRL_HD_CAPABLE		0x0100	/* half duplex capable */
+
+/* Bit definitions: 1000BaseT AUX Status */
+#define GMII_1000_AUX_STATUS_FD_CAPABLE		0x0800	/* full duplex capable */
+#define GMII_1000_AUX_STATUS_HD_CAPABLE		0x0400	/* half duplex capable */
+
+/* Cicada MII Registers */
+#define GMII_AUX_CTRL_STATUS			0x1C
+#define GMII_AUX_ANEG_CPLT			0x8000
+#define GMII_AUX_FDX				0x0020
+#define GMII_AUX_SPEED_1000			0x0010
+#define GMII_AUX_SPEED_100			0x0008
+
+#ifndef ADVERTISE_PAUSE_CAP
+#define ADVERTISE_PAUSE_CAP			0x0400
+#endif
+
+#ifndef MII_STAT1000
+#define MII_STAT1000				0x000A
+#endif
+
+#ifndef LPA_1000FULL
+#define LPA_1000FULL				0x0800
+#endif
+
+/* medium mode register */
+#define MEDIUM_GIGA_MODE			0x0001
+#define MEDIUM_FULL_DUPLEX_MODE			0x0002
+#define MEDIUM_TX_ABORT_MODE			0x0004
+#define MEDIUM_ENABLE_125MHZ			0x0008
+#define MEDIUM_ENABLE_RX_FLOWCTRL		0x0010
+#define MEDIUM_ENABLE_TX_FLOWCTRL		0x0020
+#define MEDIUM_ENABLE_JUMBO_FRAME		0x0040
+#define MEDIUM_CHECK_PAUSE_FRAME_MODE		0x0080
+#define MEDIUM_ENABLE_RECEIVE			0x0100
+#define MEDIUM_MII_100M_MODE			0x0200
+#define MEDIUM_ENABLE_JAM_PATTERN		0x0400
+#define MEDIUM_ENABLE_STOP_BACKPRESSURE		0x0800
+#define MEDIUM_ENABLE_SUPPER_MAC_SUPPORT	0x1000
+
+/* PHY mode */
+#define PHY_MODE_MARVELL		0
+#define PHY_MODE_CICADA_FAMILY		1
+#define PHY_MODE_CICADA_V1		1
+#define PHY_MODE_AGERE_FAMILY		2
+#define PHY_MODE_AGERE_V0		2
+#define PHY_MODE_CICADA_V2		5
+#define PHY_MODE_AGERE_V0_GMII		6
+#define PHY_MODE_CICADA_V2_ASIX		9
+#define PHY_MODE_VSC8601		10
+#define PHY_MODE_RTL8211CL		12
+#define PHY_MODE_RTL8211BN		13
+#define PHY_MODE_RTL8251CL		14
+#define PHY_MODE_ATTANSIC_V0		0x40
+#define PHY_MODE_ATTANSIC_FAMILY	0x40
+#define PHY_MODE_MAC_TO_MAC_GMII	0x7C
+
+/*  */
+#define LED_MODE_MARVELL		0
+#define LED_MODE_CAMEO			1
+
+#define MARVELL_LED_CTRL		0x18
+#define MARVELL_MANUAL_LED		0x19
+
+#define PHY_IDENTIFIER			0x0002
+#define PHY_AGERE_IDENTIFIER		0x0282
+#define PHY_CICADA_IDENTIFIER		0x000f
+#define PHY_MARVELL_IDENTIFIER		0x0141
+
+#define PHY_MARVELL_STATUS		0x001b
+#define MARVELL_STATUS_HWCFG		0x0004		/* SGMII without clock */
+
+#define PHY_MARVELL_CTRL		0x0014
+#define MARVELL_CTRL_RXDELAY		0x0080
+#define MARVELL_CTRL_TXDELAY		0x0002
+
+#define PHY_CICADA_EXTPAGE		0x001f
+#define CICADA_EXTPAGE_EN		0x0001
+#define CICADA_EXTPAGE_DIS		0x0000
+
+struct {unsigned short value, offset; } CICADA_FAMILY_HWINIT[] = {
+	{0x0001, 0x001f}, {0x1c25, 0x0017}, {0x2a30, 0x001f}, {0x234c, 0x0010},
+	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0xa7fa, 0x0000},
+	{0x0012, 0x0002}, {0x3002, 0x0001}, {0x87fa, 0x0000}, {0x52b5, 0x001f},
+	{0xafac, 0x0000}, {0x000d, 0x0002}, {0x001c, 0x0001}, {0x8fac, 0x0000},
+	{0x2a30, 0x001f}, {0x0012, 0x0008}, {0x2a30, 0x001f}, {0x0400, 0x0014},
+	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0xa760, 0x0000},
+	{0x0000, 0x0002}, {0xfaff, 0x0001}, {0x8760, 0x0000}, {0x52b5, 0x001f},
+	{0xa760, 0x0000}, {0x0000, 0x0002}, {0xfaff, 0x0001}, {0x8760, 0x0000},
+	{0x52b5, 0x001f}, {0xafae, 0x0000}, {0x0004, 0x0002}, {0x0671, 0x0001},
+	{0x8fae, 0x0000}, {0x2a30, 0x001f}, {0x0012, 0x0008}, {0x0000, 0x001f},
+};
+
+struct {unsigned short value, offset; } CICADA_V2_HWINIT[] = {
+	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0x000f, 0x0002},
+	{0x472a, 0x0001}, {0x8fa4, 0x0000}, {0x2a30, 0x001f}, {0x0212, 0x0008},
+	{0x0000, 0x001f},
+};
+
+struct {unsigned short value, offset; } CICADA_V2_ASIX_HWINIT[] = {
+	{0x2a30, 0x001f}, {0x0212, 0x0008}, {0x52b5, 0x001f}, {0x0012, 0x0002},
+	{0x3002, 0x0001}, {0x87fa, 0x0000}, {0x52b5, 0x001f}, {0x000f, 0x0002},
+	{0x472a, 0x0001}, {0x8fa4, 0x0000}, {0x2a30, 0x001f}, {0x0212, 0x0008},
+	{0x0000, 0x001f},
+};
+
+struct {unsigned short value, offset; } AGERE_FAMILY_HWINIT[] = {
+	{0x0800, 0x0000}, {0x0007, 0x0012}, {0x8805, 0x0010}, {0xb03e, 0x0011},
+	{0x8808, 0x0010}, {0xe110, 0x0011}, {0x8806, 0x0010}, {0xb03e, 0x0011},
+	{0x8807, 0x0010}, {0xff00, 0x0011}, {0x880e, 0x0010}, {0xb4d3, 0x0011},
+	{0x880f, 0x0010}, {0xb4d3, 0x0011}, {0x8810, 0x0010}, {0xb4d3, 0x0011},
+	{0x8817, 0x0010}, {0x1c00, 0x0011}, {0x300d, 0x0010}, {0x0001, 0x0011},
+	{0x0002, 0x0012},
+};
+
+struct ax88178_data {
+	u16	EepromData;
+	u16	MediaLink;
+	int	UseGpio0;
+	int	UseRgmii;
+	u8	PhyMode;
+	u8	LedMode;
+	u8	BuffaloOld;
+};
+
+enum watchdog_state {
+	AX_NOP = 0,
+	CHK_LINK,			/* Routine A */
+	CHK_CABLE_EXIST,		/* Called by A */
+	CHK_CABLE_EXIST_AGAIN,		/* Routine B */
+	PHY_POWER_UP,			/* Called by B */
+	PHY_POWER_UP_BH,
+	PHY_POWER_DOWN,
+	CHK_CABLE_STATUS,		/* Routine C */
+	WAIT_AUTONEG_COMPLETE,
+	AX_SET_RX_CFG,
+	AX_CHK_AUTODETACH,
+};
+
+struct ax88772b_data {
+	struct usbnet *dev;
+	struct workqueue_struct *ax_work;
+	struct work_struct check_link;
+	unsigned long time_to_chk;
+	u16 psc;
+	u8 pw_enabled;
+	u8 Event;
+	u8 checksum;
+	u8 PhySelect:1;
+	u8 OperationMode:1;
+	u16 presvd_phy_advertise;
+	u16 presvd_phy_bmcr;
+};
+
+/* define for MAC or PHY mode */
+#define OPERATION_MAC_MODE			0
+#define OPERATION_PHY_MODE			1
+
+struct ax88772a_data {
+	struct usbnet *dev;
+	struct workqueue_struct *ax_work;
+	struct work_struct check_link;
+	unsigned long autoneg_start;
+#define AX88772B_WATCHDOG	(6 * HZ)
+	u8 Event;
+	u8 TickToExpire;
+	u8 DlyIndex;
+	u8 DlySel;
+	u16 EepromData;
+	u16 presvd_phy_advertise;
+	u16 presvd_phy_bmcr;
+};
+
+struct ax88772_data {
+	struct usbnet *dev;
+	struct workqueue_struct *ax_work;
+	struct work_struct check_link;
+	unsigned long autoneg_start;
+	u8 Event;
+	u8 TickToExpire;
+	u16 presvd_phy_advertise;
+	u16 presvd_phy_bmcr;
+};
+
+#define AX_RX_CHECKSUM		1
+#define AX_TX_CHECKSUM		2
+
+/* This structure cannot exceed sizeof(unsigned long [5]) AKA 20 bytes */
+struct ax8817x_data {
+	u8 multi_filter[AX_MCAST_FILTER_SIZE];
+	int (*resume) (struct usb_interface *intf);
+	int (*suspend) (struct usb_interface *intf,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+					pm_message_t message);
+#else
+					u32 message);
+#endif
+};
+
+struct ax88172_int_data {
+	u16 res1;
+#define AX_INT_PPLS_LINK		(1 << 0)
+#define AX_INT_SPLS_LINK		(1 << 1)
+#define AX_INT_CABOFF_UNPLUG		(1 << 7)
+	u8 link;
+	u16 res2;
+	u8 status;
+	u16 res3;
+} __attribute__ ((packed));
+
+#define AX_RXHDR_L4_ERR		(1 << 8)
+#define AX_RXHDR_L3_ERR		(1 << 9)
+
+#define AX_RXHDR_L4_TYPE_UDP		1
+#define AX_RXHDR_L4_TYPE_ICMP		2
+#define AX_RXHDR_L4_TYPE_IGMP		3
+#define AX_RXHDR_L4_TYPE_TCP		4
+#define AX_RXHDR_L4_TYPE_TCMPV6	5
+#define AX_RXHDR_L4_TYPE_MASK		7
+
+#define AX_RXHDR_L3_TYPE_IP		1
+#define AX_RXHDR_L3_TYPE_IPV6		2
+
+struct ax88772b_rx_header {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	u16	len:11,
+		res1:1,
+		crc:1,
+		mii:1,
+		runt:1,
+		mc_bc:1;
+
+	u16	len_bar:11,
+		res2:5;
+
+	u8	vlan_ind:3,
+		vlan_tag_striped:1,
+		pri:3,
+		res3:1;
+
+	u8	l4_csum_err:1,
+		l3_csum_err:1,
+		l4_type:3,
+		l3_type:2,
+		ce:1;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	u16	mc_bc:1,
+		runt:1,
+		mii:1,
+		crc:1,
+		res1:1,
+		len:11;
+
+	u16	res2:5,
+		len_bar:11;
+
+	u8	res3:1,
+		pri:3,
+		vlan_tag_striped:1,
+		vlan_ind:3;
+
+	u8	ce:1,
+		l3_type:2,
+		l4_type:3,
+		l3_csum_err:1,
+		l4_csum_err:1;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+
+} __attribute__ ((packed));
+
+
+#endif /* __LINUX_USBNET_ASIX_H */
+
diff --no-dereference -Nru kernel-22/kernel/drivers/net/usb/asix-new.c kernel-central/kernel/drivers/net/usb/asix-new.c
--- kernel-22/kernel/drivers/net/usb/asix-new.c	1970-01-01 03:00:00.000000000 +0300
+++ kernel-central/kernel/drivers/net/usb/asix-new.c	2016-11-23 05:02:47.000000000 +0200
@@ -0,0 +1,4255 @@
+/*
+ * ASIX AX8817X based USB 2.0 Ethernet Devices
+ * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>
+ * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>
+ * Copyright (c) 2002-2003 TiVo Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* debug messages, extra info */
+/* #define	DEBUG */
+
+#include <linux/version.h>
+/* #include <linux/config.h> */
+#ifdef	CONFIG_USB_DEBUG
+#   define DEBUG
+#endif
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/workqueue.h>
+#include <linux/mii.h>
+#include <linux/usb.h>
+#include <linux/crc32.h>
+
+#include "axusbnet.c"
+#include "asix.h"
+
+#define DRV_VERSION	"4.19.0"
+
+static char version[] =
+KERN_INFO "ASIX USB Ethernet Adapter:v" DRV_VERSION
+//	" " __TIME__ " " __DATE__ "\n"
+	"    http://www.asix.com.tw\n";
+
+/* configuration of maximum bulk in size */
+static int bsize = AX88772B_MAX_BULKIN_16K;
+module_param(bsize, int, 0);
+MODULE_PARM_DESC(bsize, "Maximum transfer size per bulk");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void ax88772b_link_reset(void *data);
+static void ax88772a_link_reset(void *data);
+static void ax88772_link_reset(void *data);
+#else
+static void ax88772b_link_reset(struct work_struct *work);
+static void ax88772a_link_reset(struct work_struct *work);
+static void ax88772_link_reset(struct work_struct *work);
+#endif
+static int ax88772a_phy_powerup(struct usbnet *dev);
+static void ax8817x_mdio_write_le(struct net_device *netdev, int phy_id,
+				  int loc, int val);
+static int ax8817x_mdio_read_le(struct net_device *netdev, int phy_id, int loc);
+static int ax88772b_set_csums(struct usbnet *dev);
+
+/* ASIX AX8817X based USB 2.0 Ethernet Devices */
+
+static int ax8817x_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
+			    u16 size, void *data)
+{
+	return usb_control_msg(
+		dev->udev,
+		usb_rcvctrlpipe(dev->udev, 0),
+		cmd,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		value,
+		index,
+		data,
+		size,
+		USB_CTRL_GET_TIMEOUT);
+}
+
+static int ax8817x_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
+			     u16 size, void *data)
+{
+	return usb_control_msg(
+		dev->udev,
+		usb_sndctrlpipe(dev->udev, 0),
+		cmd,
+		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		value,
+		index,
+		data,
+		size,
+		USB_CTRL_SET_TIMEOUT);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void ax8817x_async_cmd_callback(struct urb *urb, struct pt_regs *regs)
+#else
+static void ax8817x_async_cmd_callback(struct urb *urb)
+#endif
+{
+	struct usb_ctrlrequest *req = (struct usb_ctrlrequest *)urb->context;
+
+	if (urb->status < 0)
+		printk(KERN_DEBUG "ax8817x_async_cmd_callback() failed with %d",
+			urb->status);
+
+	kfree(req);
+	usb_free_urb(urb);
+}
+
+static int ax8817x_set_mac_addr(struct net_device *net, void *p)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct sockaddr *addr = p;
+
+	memcpy(net->dev_addr, addr->sa_data, ETH_ALEN);
+
+	/* Set the MAC address */
+	return ax8817x_write_cmd(dev, AX88772_CMD_WRITE_NODE_ID,
+				 0, 0, ETH_ALEN, net->dev_addr);
+
+}
+
+static void ax88178_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88172_int_data *event;
+	struct ax88178_data *ax178dataptr = (struct ax88178_data *)dev->priv;
+	int link;
+
+	if (urb->actual_length < 8)
+		return;
+
+	if (ax178dataptr->EepromData == PHY_MODE_MAC_TO_MAC_GMII)
+		return;
+
+	event = urb->transfer_buffer;
+	link = event->link & 0x01;
+	if (netif_carrier_ok(dev->net) != link) {
+		if (link) {
+			netif_carrier_on(dev->net);
+			axusbnet_defer_kevent(dev, EVENT_LINK_RESET);
+		} else
+			netif_carrier_off(dev->net);
+		devwarn(dev, "ax88178 - Link status is: %d", link);
+	}
+}
+
+static void ax8817x_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88172_int_data *event;
+	int link;
+
+	if (urb->actual_length < 8)
+		return;
+
+	event = urb->transfer_buffer;
+	link = event->link & 0x01;
+	if (netif_carrier_ok(dev->net) != link) {
+		if (link) {
+			netif_carrier_on(dev->net);
+			axusbnet_defer_kevent(dev, EVENT_LINK_RESET);
+		} else
+			netif_carrier_off(dev->net);
+		devwarn(dev, "ax8817x - Link status is: %d", link);
+	}
+}
+
+static void ax88772_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88172_int_data *event;
+	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
+	int link;
+
+	if (urb->actual_length < 8)
+		return;
+
+	event = urb->transfer_buffer;
+	link = event->link & 0x01;
+
+	if (netif_carrier_ok(dev->net) != link) {
+		if (link) {
+			netif_carrier_on(dev->net);
+			ax772_data->Event = AX_SET_RX_CFG;
+		} else {
+			netif_carrier_off(dev->net);
+			if (ax772_data->Event == AX_NOP) {
+				ax772_data->Event = PHY_POWER_DOWN;
+				ax772_data->TickToExpire = 25;
+			}
+		}
+
+		devwarn(dev, "ax88772 - Link status is: %d", link);
+	}
+
+	if (ax772_data->Event)
+		queue_work(ax772_data->ax_work, &ax772_data->check_link);
+}
+
+static void ax88772a_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88172_int_data *event;
+	struct ax88772a_data *ax772a_data = (struct ax88772a_data *)dev->priv;
+	int link;
+	int powsave = (ax772a_data->EepromData >> 14);
+
+	if (urb->actual_length < 8)
+		return;
+
+	event = urb->transfer_buffer;
+	link = event->link & 0x01;
+
+	if (netif_carrier_ok(dev->net) != link) {
+
+		if (link) {
+			netif_carrier_on(dev->net);
+			ax772a_data->Event = AX_SET_RX_CFG;
+		} else if ((powsave == 0x3) || (powsave == 0x1)) {
+			netif_carrier_off(dev->net);
+			if (ax772a_data->Event == AX_NOP) {
+				ax772a_data->Event = CHK_CABLE_EXIST;
+				ax772a_data->TickToExpire = 14;
+			}
+		} else {
+			netif_carrier_off(dev->net);
+			ax772a_data->Event = AX_NOP;
+		}
+
+		devwarn(dev, "ax88772a - Link status is: %d", link);
+	}
+
+	if (ax772a_data->Event)
+		queue_work(ax772a_data->ax_work, &ax772a_data->check_link);
+}
+
+static int ax88772b_stop(struct usbnet *dev)
+{
+	u16 *medium;
+
+	medium = kmalloc(2, GFP_ATOMIC);
+	if (medium) {
+		ax8817x_read_cmd(dev, AX_CMD_READ_MEDIUM_MODE, 0, 0, 2, medium);
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+				  (*medium & ~AX88772_MEDIUM_RX_ENABLE),
+				  0, 0, NULL);
+
+		kfree(medium);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int ax88772b_reset(struct usbnet *dev)
+{
+	int ret;
+
+	/* Set the MAC address */
+	ret = ax8817x_write_cmd(dev, AX88772_CMD_WRITE_NODE_ID,
+				0, 0, ETH_ALEN, dev->net->dev_addr);
+	if (ret < 0)
+		deverr(dev, "set MAC address failed: %d", ret);
+
+	/* stop MAC operation */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, AX_RX_CTL_STOP,
+				0, 0, NULL);
+	if (ret < 0)
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+				AX88772_MEDIUM_DEFAULT, 0, 0,
+				NULL);
+	if (ret < 0)
+		deverr(dev, "Write medium mode register: %d", ret);
+
+	return ret;
+}
+
+static void ax88772b_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+	struct ax88172_int_data *event;
+	int link;
+
+	if (urb->actual_length < 8)
+		return;
+
+	if (ax772b_data->OperationMode == OPERATION_PHY_MODE)
+		return;
+
+	event = urb->transfer_buffer;
+	if (ax772b_data->PhySelect == 0 &&
+	    ax772b_data->OperationMode == OPERATION_MAC_MODE)
+		link = (event->link & AX_INT_SPLS_LINK) >> 1;
+	else
+		link = event->link & AX_INT_PPLS_LINK;
+
+	if (netif_carrier_ok(dev->net) != link) {
+		if (link) {
+			netif_carrier_on(dev->net);
+			ax772b_data->Event = AX_SET_RX_CFG;
+		} else {
+			netif_carrier_off(dev->net);
+			ax772b_data->time_to_chk = jiffies;
+		}
+		devwarn(dev, "ax88772b - Link status is: %d", link);
+	}
+
+	if (!link) {
+
+		int no_cable = (event->link & AX_INT_CABOFF_UNPLUG) ? 1 : 0;
+
+		if (no_cable) {
+			if ((ax772b_data->psc &
+			    (AX_SWRESET_IPPSL_0 | AX_SWRESET_IPPSL_1)) &&
+			     !ax772b_data->pw_enabled) {
+				/*
+				 * AX88772B already entered power saving state
+				 */
+				ax772b_data->pw_enabled = 1;
+			}
+			if (ax772b_data->psc & AX_SWRESET_AUTODETACH)
+				ax772b_data->Event = AX_CHK_AUTODETACH;
+
+		} else {
+			/* AX88772B resumed from power saving state */
+			if (ax772b_data->pw_enabled ||
+				(jiffies > (ax772b_data->time_to_chk +
+				 AX88772B_WATCHDOG))) {
+				if (ax772b_data->pw_enabled)
+					ax772b_data->pw_enabled = 0;
+				ax772b_data->Event = PHY_POWER_UP;
+				ax772b_data->time_to_chk = jiffies;
+			}
+		}
+	}
+
+	if (ax772b_data->Event)
+		queue_work(ax772b_data->ax_work, &ax772b_data->check_link);
+}
+
+static void ax88772c_status(struct usbnet *dev, struct urb *urb)
+{
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+	struct ax88172_int_data *event;
+	int link;
+
+	if (urb->actual_length < 8)
+		return;
+
+	if (ax772b_data->OperationMode == OPERATION_PHY_MODE)
+		return;
+
+	event = urb->transfer_buffer;
+	if (ax772b_data->PhySelect == 0 &&
+	    ax772b_data->OperationMode == OPERATION_MAC_MODE)
+		link = (event->link & AX_INT_SPLS_LINK) >> 1;
+	else
+		link = event->link & AX_INT_PPLS_LINK;
+
+	if (netif_carrier_ok(dev->net) != link) {
+		if (link) {
+			netif_carrier_on(dev->net);
+			ax772b_data->Event = AX_SET_RX_CFG;
+		} else {
+			netif_carrier_off(dev->net);
+			ax772b_data->time_to_chk = jiffies;
+		}
+		devwarn(dev, "ax88772c - Link status is: %d", link);
+	}
+
+	if (!link) {
+
+		int no_cable = (event->link & AX_INT_CABOFF_UNPLUG) ? 1 : 0;
+
+		if (no_cable) {
+			if ((ax772b_data->psc &
+			    (AX_SWRESET_IPPSL_0 | AX_SWRESET_IPPSL_1)) &&
+			     !ax772b_data->pw_enabled) {
+				/*
+				 * AX88772B already entered power saving state
+				 */
+				ax772b_data->pw_enabled = 1;
+			}
+			if (ax772b_data->psc & AX_SWRESET_AUTODETACH)
+				ax772b_data->Event = AX_CHK_AUTODETACH;
+		} else {
+			/* AX88772B resumed from power saving state */
+			if (ax772b_data->pw_enabled ||
+				(jiffies > (ax772b_data->time_to_chk +
+				 AX88772B_WATCHDOG))) {
+				if (ax772b_data->pw_enabled)
+					ax772b_data->pw_enabled = 0;
+				ax772b_data->Event = PHY_POWER_UP;
+				ax772b_data->time_to_chk = jiffies;
+			}
+		}
+	}
+
+	if (ax772b_data->Event)
+		queue_work(ax772b_data->ax_work, &ax772b_data->check_link);
+}
+
+void
+ax8817x_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,
+				    u16 size, void *data)
+{
+	struct usb_ctrlrequest *req;
+	int status;
+	struct urb *urb;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (urb == NULL) {
+		deverr(dev, "Error allocating URB in write_cmd_async!");
+		return;
+	}
+
+	req = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);
+	if (req == NULL) {
+		deverr(dev, "Failed to allocate memory for control request");
+		usb_free_urb(urb);
+		return;
+	}
+
+	req->bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+	req->bRequest = cmd;
+	req->wValue = cpu_to_le16(value);
+	req->wIndex = cpu_to_le16(index);
+	req->wLength = cpu_to_le16(size);
+
+	usb_fill_control_urb(urb, dev->udev,
+			     usb_sndctrlpipe(dev->udev, 0),
+			     (void *)req, data, size,
+			     ax8817x_async_cmd_callback, req);
+
+	status = usb_submit_urb(urb, GFP_ATOMIC);
+	if (status < 0) {
+		deverr(dev, "Error submitting the control message: status=%d",
+				status);
+		kfree(req);
+		usb_free_urb(urb);
+	}
+}
+
+static void ax8817x_set_multicast(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	u8 rx_ctl = AX_RX_CTL_START | AX_RX_CTL_AB;
+	int mc_count;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+	mc_count = net->mc_count;
+#else
+	mc_count = netdev_mc_count(net);
+#endif
+
+	if (net->flags & IFF_PROMISC) {
+		rx_ctl |= AX_RX_CTL_PRO;
+	} else if (net->flags & IFF_ALLMULTI
+		   || mc_count > AX_MAX_MCAST) {
+		rx_ctl |= AX_RX_CTL_AMALL;
+	} else if (mc_count == 0) {
+		/* just broadcast and directed */
+	} else {
+		/* We use the 20 byte dev->data
+		 * for our 8 byte filter buffer
+		 * to avoid allocating memory that
+		 * is tricky to free later */
+		u32 crc_bits;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+		struct dev_mc_list *mc_list = net->mc_list;
+		int i;
+
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+
+		/* Build the multicast hash filter. */
+		for (i = 0; i < net->mc_count; i++) {
+			crc_bits =
+			    ether_crc(ETH_ALEN,
+				      mc_list->dmi_addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+			    1 << (crc_bits & 7);
+			mc_list = mc_list->next;
+		}
+#else
+		struct netdev_hw_addr *ha;
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+		netdev_for_each_mc_addr(ha, net) {
+			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+				1 << (crc_bits & 7);
+		}
+#endif
+		ax8817x_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
+				   AX_MCAST_FILTER_SIZE, data->multi_filter);
+
+		rx_ctl |= AX_RX_CTL_AM;
+	}
+
+	ax8817x_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
+}
+
+static void ax88178_set_multicast(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	u16 rx_ctl = (AX_RX_CTL_START | AX_RX_CTL_AB |  AX_RX_CTL_MFB);
+	int mc_count;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+	mc_count = net->mc_count;
+#else
+	mc_count = netdev_mc_count(net);
+#endif
+
+	if (net->flags & IFF_PROMISC) {
+		rx_ctl |= AX_RX_CTL_PRO;
+	} else if (net->flags & IFF_ALLMULTI
+		   || mc_count > AX_MAX_MCAST) {
+		rx_ctl |= AX_RX_CTL_AMALL;
+	} else if (mc_count == 0) {
+		/* just broadcast and directed */
+	} else {
+		/* We use the 20 byte dev->data
+		 * for our 8 byte filter buffer
+		 * to avoid allocating memory that
+		 * is tricky to free later */
+		u32 crc_bits;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+		struct dev_mc_list *mc_list = net->mc_list;
+		int i;
+
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+
+		/* Build the multicast hash filter. */
+		for (i = 0; i < net->mc_count; i++) {
+			crc_bits =
+			    ether_crc(ETH_ALEN,
+				      mc_list->dmi_addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+			    1 << (crc_bits & 7);
+			mc_list = mc_list->next;
+		}
+#else
+		struct netdev_hw_addr *ha;
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+		netdev_for_each_mc_addr(ha, net) {
+			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+				1 << (crc_bits & 7);
+		}
+#endif
+		ax8817x_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
+				   AX_MCAST_FILTER_SIZE, data->multi_filter);
+
+		rx_ctl |= AX_RX_CTL_AM;
+	}
+
+	ax8817x_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
+}
+
+static void ax88772b_set_multicast(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	u16 rx_ctl = (AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_HEADER_DEFAULT);
+	int mc_count;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+	mc_count = net->mc_count;
+#else
+	mc_count = netdev_mc_count(net);
+#endif
+
+	if (net->flags & IFF_PROMISC) {
+		rx_ctl |= AX_RX_CTL_PRO;
+	} else if (net->flags & IFF_ALLMULTI
+		   || mc_count > AX_MAX_MCAST) {
+		rx_ctl |= AX_RX_CTL_AMALL;
+	} else if (mc_count == 0) {
+		/* just broadcast and directed */
+	} else {
+		/* We use the 20 byte dev->data
+		 * for our 8 byte filter buffer
+		 * to avoid allocating memory that
+		 * is tricky to free later */
+		u32 crc_bits;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+		struct dev_mc_list *mc_list = net->mc_list;
+		int i;
+
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+
+		/* Build the multicast hash filter. */
+		for (i = 0; i < net->mc_count; i++) {
+			crc_bits =
+			    ether_crc(ETH_ALEN,
+				      mc_list->dmi_addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+			    1 << (crc_bits & 7);
+			mc_list = mc_list->next;
+		}
+#else
+		struct netdev_hw_addr *ha;
+		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
+		netdev_for_each_mc_addr(ha, net) {
+			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			data->multi_filter[crc_bits >> 3] |=
+				1 << (crc_bits & 7);
+		}
+#endif
+		ax8817x_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
+				   AX_MCAST_FILTER_SIZE, data->multi_filter);
+
+		rx_ctl |= AX_RX_CTL_AM;
+	}
+
+	ax8817x_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
+}
+
+static int ax8817x_mdio_read(struct net_device *netdev, int phy_id, int loc)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	u16 *res, ret;
+	u8 smsr;
+	int i = 0;
+
+	res = kmalloc(2, GFP_ATOMIC);
+	if (!res)
+		return 0;
+
+	do {
+		ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+		
+		msleep(1);
+
+		ax8817x_read_cmd(dev, AX_CMD_READ_STATMNGSTS_REG, 0, 0, 1, &smsr);
+	} while (!(smsr & AX_HOST_EN) && (i++ < 30));
+	
+	ax8817x_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id, (__u16)loc, 2, res);
+	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
+
+	ret = *res & 0xffff;
+	kfree(res);
+
+	return ret;
+}
+
+static int
+ax8817x_swmii_mdio_read(struct net_device *netdev, int phy_id, int loc)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	u16 *res;
+	u16 ret;
+
+	res = kmalloc(2, GFP_ATOMIC);
+	if (!res)
+		return 0;
+
+	ax8817x_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id,
+				(__u16)loc, 2, res);
+
+	ret = *res & 0xffff;
+	kfree(res);
+
+	return ret;
+}
+
+/* same as above, but converts resulting value to cpu byte order */
+static int ax8817x_mdio_read_le(struct net_device *netdev, int phy_id, int loc)
+{
+	return le16_to_cpu(ax8817x_mdio_read(netdev, phy_id, loc));
+}
+
+static int
+ax8817x_swmii_mdio_read_le(struct net_device *netdev, int phy_id, int loc)
+{
+	return le16_to_cpu(ax8817x_swmii_mdio_read(netdev, phy_id, loc));
+}
+
+static void
+ax8817x_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	u16 *res;
+	u8 smsr;
+	int i = 0;
+
+	res = kmalloc(2, GFP_ATOMIC);
+	if (!res)
+		return;
+	*res = val;
+
+	do {
+		ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+
+		msleep(1);
+
+		ax8817x_read_cmd(dev, AX_CMD_READ_STATMNGSTS_REG, 0, 0, 1, &smsr);
+	} while (!(smsr & AX_HOST_EN) && (i++ < 30));	
+		
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
+			  (__u16)loc, 2, res);
+	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
+
+	kfree(res);
+}
+
+static void ax8817x_swmii_mdio_write(struct net_device *netdev, int phy_id,
+				     int loc, int val)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	u16 *res;
+
+	res = kmalloc(2, GFP_ATOMIC);
+	if (!res)
+		return;
+	*res = val;
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
+				(__u16)loc, 2, res);
+
+	kfree(res);
+}
+
+static void
+ax88772b_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	u16 *res;
+
+	res = kmalloc(2, GFP_ATOMIC);
+	if (!res)
+		return;
+	*res = val;
+
+	ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
+				(__u16)loc, 2, res);
+
+	if (loc == MII_ADVERTISE) {
+		*res = cpu_to_le16(BMCR_ANENABLE | BMCR_ANRESTART);
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
+				(__u16)MII_BMCR, 2, res);
+	}
+
+	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
+
+	kfree(res);
+}
+
+/* same as above, but converts new value to le16 byte order before writing */
+static void
+ax8817x_mdio_write_le(struct net_device *netdev, int phy_id, int loc, int val)
+{
+	ax8817x_mdio_write(netdev, phy_id, loc, cpu_to_le16(val));
+}
+
+static void ax8817x_swmii_mdio_write_le(struct net_device *netdev,
+			int phy_id, int loc, int val)
+{
+	ax8817x_swmii_mdio_write(netdev, phy_id, loc, cpu_to_le16(val));
+}
+
+static void
+ax88772b_mdio_write_le(struct net_device *netdev, int phy_id, int loc, int val)
+{
+	ax88772b_mdio_write(netdev, phy_id, loc, cpu_to_le16(val));
+}
+
+static int ax88772_suspend(struct usb_interface *intf,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+			   pm_message_t message)
+#else
+			   u32 message)
+#endif
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	u16 *medium;
+
+	medium = kmalloc(2, GFP_ATOMIC);
+	if (!medium)
+		return axusbnet_suspend(intf, message);
+
+	ax8817x_read_cmd(dev, AX_CMD_READ_MEDIUM_MODE, 0, 0, 2, medium);
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+			(*medium & ~AX88772_MEDIUM_RX_ENABLE), 0, 0, NULL);
+
+	kfree(medium);
+	return axusbnet_suspend(intf, message);
+}
+
+static int ax88772b_suspend(struct usb_interface *intf,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+			    pm_message_t message)
+#else
+			    u32 message)
+#endif
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+	u16 *tmp16;
+	u8 *opt;
+//	u32 tmp32;
+
+	tmp16 = kmalloc(2, GFP_ATOMIC);
+	if (!tmp16)
+		return axusbnet_suspend(intf, message);
+	opt = (u8 *)tmp16;
+#if 0
+	/* Read Wake-up Frame Array Register (Mask Wakeup Timer) */
+	ax8817x_read_cmd(dev, AX_CMD_READ_WKFARY, 0x0b, 0, 4, &tmp32);
+	tmp32 &= 0xFFF0FFFF;
+	/* 8 second */
+	tmp32 |= 0xFFF2FFFF;
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_WKFARY, 0x0b, 0, 4, &tmp32);
+#endif
+	/* Preserve BMCR for restoring */
+	ax772b_data->presvd_phy_bmcr = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_BMCR);
+
+	/* Preserve Advertisement control reg for restoring */
+	ax772b_data->presvd_phy_advertise = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+
+	ax8817x_read_cmd(dev, AX_CMD_READ_MEDIUM_MODE, 0, 0, 2, tmp16);
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+			  (*tmp16 & ~AX88772_MEDIUM_RX_ENABLE),
+			  0, 0, NULL);
+
+	ax8817x_read_cmd(dev, AX_CMD_READ_MONITOR_MODE, 0, 0, 1, opt);
+	if (!(*opt & AX_MONITOR_LINK) && !(*opt & AX_MONITOR_MAGIC)) {
+		ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				  AX_SWRESET_IPRL | AX_SWRESET_IPPD,
+				  0, 0, NULL);
+	} else {
+
+		if (ax772b_data->psc & AX_SWRESET_WOLLP) {
+			*tmp16 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+						      MII_BMCR);
+			ax8817x_mdio_write_le(dev->net, dev->mii.phy_id,
+					      MII_BMCR, *tmp16 | BMCR_ANENABLE);
+
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					  AX_SWRESET_IPRL | ax772b_data->psc,
+					  0, 0, NULL);
+		}
+
+		if (ax772b_data->psc &
+		    (AX_SWRESET_IPPSL_0 | AX_SWRESET_IPPSL_1)) {
+			*opt |= AX_MONITOR_LINK;
+			ax8817x_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE, *opt,
+					  0, 0, NULL);
+		}
+	}
+
+	kfree(tmp16);
+	return axusbnet_suspend(intf, message);
+}
+
+static int ax88772_resume(struct usb_interface *intf)
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+
+	netif_carrier_off(dev->net);
+
+	return axusbnet_resume(intf);
+}
+
+static int ax88772b_resume(struct usb_interface *intf)
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	if (ax772b_data->psc & AX_SWRESET_WOLLP) {
+		ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				  AX_SWRESET_IPRL | (ax772b_data->psc & 0x7FFF),
+				  0, 0, NULL);
+	}
+
+	if (ax772b_data->psc & (AX_SWRESET_IPPSL_0 | AX_SWRESET_IPPSL_1))
+		ax88772a_phy_powerup(dev);
+
+	netif_carrier_off(dev->net);
+
+	if (ax772b_data->OperationMode == OPERATION_PHY_MODE)
+		netif_carrier_on(dev->net);
+
+	return axusbnet_resume(intf);
+}
+
+static int ax88172_link_reset(struct usbnet *dev)
+{
+	u16 lpa;
+	u16 adv;
+	u16 res;
+	u8 mode;
+
+	mode = AX_MEDIUM_TX_ABORT_ALLOW | AX_MEDIUM_FLOW_CONTROL_EN;
+	lpa = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_LPA);
+	adv = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+	res = mii_nway_result(lpa|adv);
+	if (res & LPA_DUPLEX)
+		mode |= AX_MEDIUM_FULL_DUPLEX;
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode, 0, 0, NULL);
+
+	return 0;
+}
+
+static void
+ax8817x_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
+{
+	struct usbnet *dev = netdev_priv(net);
+	u8 *opt;
+
+	wolinfo->supported = 0;
+	wolinfo->wolopts = 0;
+
+	opt = kmalloc(1, GFP_KERNEL);
+	if (!opt)
+		return;
+
+	if (ax8817x_read_cmd(dev, AX_CMD_READ_MONITOR_MODE, 0, 0, 1, opt) < 0) {
+		kfree(opt);
+		return;
+	}
+
+	wolinfo->supported = WAKE_PHY | WAKE_MAGIC;
+
+	if (*opt & AX_MONITOR_LINK)
+		wolinfo->wolopts |= WAKE_PHY;
+	if (*opt & AX_MONITOR_MAGIC)
+		wolinfo->wolopts |= WAKE_MAGIC;
+
+	kfree(opt);
+}
+
+static int
+ax8817x_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
+{
+	struct usbnet *dev = netdev_priv(net);
+	u8 *opt;
+
+	opt = kmalloc(1, GFP_KERNEL);
+	if (!opt)
+		return -ENOMEM;
+
+	*opt = 0;
+	if (wolinfo->wolopts & WAKE_PHY)
+		*opt |= AX_MONITOR_LINK;
+	if (wolinfo->wolopts & WAKE_MAGIC)
+		*opt |= AX_MONITOR_MAGIC;
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE, *opt, 0, 0, NULL);
+
+	kfree(opt);
+	return 0;
+}
+
+static int ax8817x_get_eeprom_len(struct net_device *net)
+{
+	return AX_EEPROM_LEN;
+}
+
+static int ax8817x_get_eeprom(struct net_device *net,
+			      struct ethtool_eeprom *eeprom, u8 *data)
+{
+	struct usbnet *dev = netdev_priv(net);
+	u16 *ebuf = (u16 *)data;
+	int i;
+
+	/* Crude hack to ensure that we don't overwrite memory
+	 * if an odd length is supplied
+	 */
+	if (eeprom->len % 2)
+		return -EINVAL;
+
+	eeprom->magic = AX_EEPROM_MAGIC;
+
+	/* ax8817x returns 2 bytes from eeprom on read */
+	for (i = 0; i < eeprom->len / 2; i++) {
+		if (ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM,
+				     eeprom->offset + i, 0, 2,
+				     &ebuf[i]) < 0)
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static void ax8817x_get_drvinfo(struct net_device *net,
+				struct ethtool_drvinfo *info)
+{
+	/* Inherit standard device info */
+	axusbnet_get_drvinfo(net, info);
+	info->eedump_len = 0x3e;
+}
+
+static int ax8817x_get_settings(struct net_device *net, struct ethtool_cmd *cmd)
+{
+	struct usbnet *dev = netdev_priv(net);
+	return mii_ethtool_gset(&dev->mii, cmd);
+}
+
+static int ax8817x_set_settings(struct net_device *net, struct ethtool_cmd *cmd)
+{
+	struct usbnet *dev = netdev_priv(net);
+	return mii_ethtool_sset(&dev->mii, cmd);
+}
+
+/* We need to override some ethtool_ops so we require our
+   own structure so we don't interfere with other usbnet
+   devices that may be connected at the same time. */
+static struct ethtool_ops ax8817x_ethtool_ops = {
+	.get_drvinfo		= ax8817x_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+	.get_msglevel		= axusbnet_get_msglevel,
+	.set_msglevel		= axusbnet_set_msglevel,
+	.get_wol		= ax8817x_get_wol,
+	.set_wol		= ax8817x_set_wol,
+	.get_eeprom_len	= ax8817x_get_eeprom_len,
+	.get_eeprom		= ax8817x_get_eeprom,
+	.get_settings		= ax8817x_get_settings,
+	.set_settings		= ax8817x_set_settings,
+};
+
+static int ax8817x_ioctl(struct net_device *net, struct ifreq *rq, int cmd)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	return generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+static const struct net_device_ops ax88x72_netdev_ops = {
+	.ndo_open			= axusbnet_open,
+	.ndo_stop			= axusbnet_stop,
+	.ndo_start_xmit	= axusbnet_start_xmit,
+	.ndo_tx_timeout	= axusbnet_tx_timeout,
+	.ndo_change_mtu	= axusbnet_change_mtu,
+	.ndo_get_stats		= axusbnet_get_stats,
+	.ndo_do_ioctl		= ax8817x_ioctl,
+	.ndo_set_mac_address		= ax8817x_set_mac_addr,
+	.ndo_validate_addr		= eth_validate_addr,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 2, 0)
+	.ndo_set_multicast_list	= ax8817x_set_multicast,
+#else
+	.ndo_set_rx_mode	= ax8817x_set_multicast,
+#endif
+};
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+static const struct net_device_ops ax88178_netdev_ops = {
+	.ndo_open			= axusbnet_open,
+	.ndo_stop			= axusbnet_stop,
+	.ndo_start_xmit	= axusbnet_start_xmit,
+	.ndo_tx_timeout	= axusbnet_tx_timeout,
+	.ndo_change_mtu	= axusbnet_change_mtu,
+	.ndo_get_stats		= axusbnet_get_stats,
+	.ndo_do_ioctl		= ax8817x_ioctl,
+	.ndo_set_mac_address		= ax8817x_set_mac_addr,
+	.ndo_validate_addr		= eth_validate_addr,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 2, 0)
+	.ndo_set_multicast_list	= ax88178_set_multicast,
+#else
+	.ndo_set_rx_mode	= ax88178_set_multicast,
+#endif
+};
+#endif
+
+static int access_eeprom_mac(struct usbnet *dev, u8 *buf, u8 offset, bool wflag)
+{
+	int ret = 0, i;
+	u16* tmp = (u16*)buf;
+
+	if (wflag) {
+		ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_EEPROM_EN,
+						0, 0, 0, NULL);
+		if (ret < 0)
+			 return ret;
+
+		mdelay(15);
+	}
+
+	for (i = 0; i < (ETH_ALEN >> 1); i++) {
+		if (wflag) {
+			u16 wd = cpu_to_le16(*(tmp + i));
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_EEPROM, offset + i,
+						wd, 0, NULL);
+			if (ret < 0)
+				break;
+
+			mdelay(15);
+		}
+		else {
+			ret = ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM,
+					       offset + i, 0, 2, tmp + i);
+			if (ret < 0)
+				break;
+		}
+	}
+
+	if (!wflag) {
+		if (ret < 0) {
+			#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+				netdev_dbg(dev->net, "Failed to read MAC address from EEPROM: %d\n", ret);
+			#else
+				devdbg(dev, "Failed to read MAC address from EEPROM: %d\n", ret);
+			#endif
+			return ret;
+		}
+		memcpy(dev->net->dev_addr, buf, ETH_ALEN);
+	}
+	else {
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_EEPROM_DIS,
+				  0, 0, 0, NULL);
+		if (ret < 0)
+			 return ret;
+
+		/* reload eeprom data */
+		ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					AXGPIOS_RSE, 0, 0, NULL);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int ax8817x_check_ether_addr(struct usbnet *dev)
+{
+	unsigned char *tmp = (unsigned char*)dev->net->dev_addr;
+	u8 default_mac[6] = {0, 0x0e, 0xc6, 0x87, 0x72, 0x01};
+
+	if (((*((u8*)tmp) == 0) && (*((u8*)tmp + 1) == 0) && (*((u8*)tmp + 2) == 0)) ||
+	    !is_valid_ether_addr((u8*)tmp) ||
+	    !memcmp(dev->net->dev_addr, default_mac, ETH_ALEN)) {
+		int i;
+
+		printk("Found invalid EEPROM MAC address value ");
+
+		for (i = 0; i < ETH_ALEN; i++) {
+			printk("%02X", *((u8*)tmp + i));
+			if (i != 5)
+				printk("-");
+		}
+		printk("\n");
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+		eth_hw_addr_random(dev->net);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+		dev->net->addr_assign_type |= NET_ADDR_RANDOM;
+#endif
+		random_ether_addr(dev->net->dev_addr); 
+#endif
+		*tmp = 0;
+		*(tmp + 1) = 0x0E;
+		*(tmp + 2) = 0xC6;
+		*(tmp + 3) = 0x8F;
+
+		return -EADDRNOTAVAIL;	
+	} 
+	return 0;
+}
+
+static int ax8817x_get_mac(struct usbnet *dev, u8* buf)
+{
+	int ret, i;
+	
+
+	ret = access_eeprom_mac(dev, buf, 0x04, 0);
+	if (ret < 0)
+		goto out;
+
+	if (ax8817x_check_ether_addr(dev)) {
+		ret = access_eeprom_mac(dev, dev->net->dev_addr, 0x04, 1);
+		if (ret < 0) {
+			deverr(dev, "Failed to write MAC to EEPROM: %d", ret);
+			goto out;
+		}
+
+		msleep(5);
+
+		ret = ax8817x_read_cmd(dev, AX88772_CMD_READ_NODE_ID,
+				       0, 0, ETH_ALEN, buf);
+		if (ret < 0) {
+			deverr(dev, "Failed to read MAC address: %d", ret);
+			goto out;
+		}
+
+		for (i = 0; i < ETH_ALEN; i++)
+			if (*(dev->net->dev_addr + i) != *((u8*)buf + i)) {
+				devwarn(dev, "Found invalid EEPROM part or non-EEPROM");
+				break;
+			}
+	}
+
+	memcpy(dev->net->perm_addr, dev->net->dev_addr, ETH_ALEN);
+
+	/* Set the MAC address */
+	ax8817x_write_cmd (dev, AX88772_CMD_WRITE_NODE_ID, 0, 0,
+			   ETH_ALEN, dev->net->dev_addr);
+	
+	if (ret < 0) {
+		deverr(dev, "Failed to write MAC address: %d", ret);
+		goto out;
+	}
+
+	return 0;
+out:
+	return ret;
+}
+
+static int ax8817x_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+	int ret = 0;
+	void *buf;
+	int i;
+	unsigned long gpio_bits = dev->driver_info->data;
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+
+	axusbnet_get_endpoints(dev, intf);
+
+	buf = kmalloc(ETH_ALEN, GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto out1;
+	}
+
+	/* Toggle the GPIOs in a manufacturer/model specific way */
+	for (i = 2; i >= 0; i--) {
+		ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(gpio_bits >> (i * 8)) & 0xff,
+					0, 0, NULL);
+		if (ret < 0)
+			goto out2;
+
+		msleep(5);
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, 0x80, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "send AX_CMD_WRITE_RX_CTL failed: %d", ret);
+		goto out2;
+	}
+
+	/* Get the MAC address */
+	memset(buf, 0, ETH_ALEN);
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_NODE_ID, 0, 0, 6, buf);
+	if (ret < 0) {
+		deverr(dev, "read AX_CMD_READ_NODE_ID failed: %d", ret);
+		goto out2;
+	}
+	memcpy(dev->net->dev_addr, buf, ETH_ALEN);
+
+	/* Get the PHY id */
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf);
+	if (ret < 0) {
+		deverr(dev, "error on read AX_CMD_READ_PHY_ID: %02x", ret);
+		goto out2;
+	} else if (ret < 2) {
+		/* this should always return 2 bytes */
+		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
+				ret);
+		ret = -EIO;
+		goto out2;
+	}
+
+	/* Initialize MII structure */
+	dev->mii.dev = dev->net;
+	dev->mii.mdio_read = ax8817x_mdio_read_le;
+	dev->mii.mdio_write = ax8817x_mdio_write_le;
+	dev->mii.phy_id_mask = 0x3f;
+	dev->mii.reg_num_mask = 0x1f;
+	dev->mii.phy_id = *((u8 *)buf + 1);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	dev->net->do_ioctl = ax8817x_ioctl;
+	dev->net->set_multicast_list = ax8817x_set_multicast;
+	dev->net->set_mac_address = ax8817x_set_mac_addr;
+#else
+	dev->net->netdev_ops = &ax88x72_netdev_ops;
+#endif
+
+	dev->net->ethtool_ops = &ax8817x_ethtool_ops;
+
+	/* Register suspend and resume functions */
+	data->suspend = axusbnet_suspend;
+	data->resume = axusbnet_resume;
+
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+		ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+	mii_nway_restart(&dev->mii);
+
+	printk(version);
+
+	return 0;
+out2:
+	kfree(buf);
+out1:
+	return ret;
+}
+
+static struct ethtool_ops ax88772_ethtool_ops = {
+	.get_drvinfo		= ax8817x_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+	.get_msglevel		= axusbnet_get_msglevel,
+	.set_msglevel		= axusbnet_set_msglevel,
+	.get_wol		= ax8817x_get_wol,
+	.set_wol		= ax8817x_set_wol,
+	.get_eeprom_len		= ax8817x_get_eeprom_len,
+	.get_eeprom		= ax8817x_get_eeprom,
+	.get_settings		= ax8817x_get_settings,
+	.set_settings		= ax8817x_set_settings,
+};
+
+static int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+	int ret;
+	void *buf;
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	struct ax88772_data *ax772_data = NULL;
+
+	axusbnet_get_endpoints(dev, intf);
+
+	buf = kmalloc(6, GFP_KERNEL);
+	if (!buf) {
+		deverr(dev, "Cannot allocate memory for buffer");
+		ret = -ENOMEM;
+		goto out1;
+	}
+
+	ax772_data = kmalloc(sizeof(*ax772_data), GFP_KERNEL);
+	if (!ax772_data) {
+		deverr(dev, "Cannot allocate memory for AX88772 data");
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	memset(ax772_data, 0, sizeof(*ax772_data));
+	dev->priv = ax772_data;
+
+	ax772_data->ax_work = create_singlethread_workqueue("ax88772");
+	if (!ax772_data->ax_work) {
+		kfree(ax772_data);
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	ax772_data->dev = dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+	INIT_WORK(&ax772_data->check_link, ax88772_link_reset, dev);
+#else
+	INIT_WORK(&ax772_data->check_link, ax88772_link_reset);
+#endif
+
+	/* reload eeprom data */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS, 0x00B0, 0, 0, NULL);
+	if (ret < 0)
+		goto out2;
+
+	msleep(5);
+
+	/* Initialize MII structure */
+	dev->mii.dev = dev->net;
+	dev->mii.mdio_read = ax8817x_mdio_read_le;
+	dev->mii.mdio_write = ax8817x_mdio_write_le;
+	dev->mii.phy_id_mask = 0xff;
+	dev->mii.reg_num_mask = 0xff;
+
+	/* Get the PHY id */
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf);
+	if (ret < 0) {
+		deverr(dev, "Error reading PHY ID: %02x", ret);
+		goto out2;
+	} else if (ret < 2) {
+		/* this should always return 2 bytes */
+		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
+		    ret);
+		ret = -EIO;
+		goto out2;
+	}
+	dev->mii.phy_id = *((u8 *)buf + 1);
+
+	if (dev->mii.phy_id == 0x10) {
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
+					0x0001, 0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Select PHY #1 failed: %d", ret);
+			goto out2;
+		}
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPPD,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Failed to power down PHY: %d", ret);
+			goto out2;
+		}
+
+		msleep(150);
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_CLEAR,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Failed to perform software reset: %d",
+			       ret);
+			goto out2;
+		}
+
+		msleep(150);
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPRL | AX_SWRESET_PRL,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev,
+			      "Failed to set PHY reset control: %d", ret);
+			goto out2;
+		}
+	} else {
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
+					0x0000, 0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Select PHY #1 failed: %d", ret);
+			goto out2;
+		}
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPPD | AX_SWRESET_PRL,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Failed to power down internal PHY: %d",
+			       ret);
+			goto out2;
+		}
+	}
+
+	msleep(150);
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+				0x0000, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to reset RX_CTL: %d", ret);
+		goto out2;
+	}
+
+	/* Get the MAC address */
+	memset(buf, 0, ETH_ALEN);
+	ret = ax8817x_get_mac(dev, buf);
+	if (ret < 0) {
+		deverr(dev, "Get HW address failed: %d", ret);
+		goto out2;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Enabling software MII failed: %d", ret);
+		goto out2;
+	}
+
+	if (dev->mii.phy_id == 0x10) {
+		ret = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 2);
+		if (ret != 0x003b) {
+			deverr(dev, "Read PHY register 2 must be 0x3b00: %d",
+			       ret);
+			goto out2;
+		}
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_PRL,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Set external PHY reset pin level: %d",
+			       ret);
+			goto out2;
+		}
+		msleep(150);
+
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPRL | AX_SWRESET_PRL,
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev,
+			       "Set Internal/External PHY reset control: %d",
+			       ret);
+			goto out2;
+		}
+		msleep(150);
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	dev->net->do_ioctl = ax8817x_ioctl;
+	dev->net->set_multicast_list = ax8817x_set_multicast;
+	dev->net->set_mac_address = ax8817x_set_mac_addr;
+#else
+	dev->net->netdev_ops = &ax88x72_netdev_ops;
+#endif
+
+	dev->net->ethtool_ops = &ax88772_ethtool_ops;
+
+	/* Register suspend and resume functions */
+	data->suspend = ax88772_suspend;
+	data->resume = ax88772_resume;
+
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+			ADVERTISE_ALL | ADVERTISE_CSMA);
+
+	mii_nway_restart(&dev->mii);
+	ax772_data->autoneg_start = jiffies;
+	ax772_data->Event = WAIT_AUTONEG_COMPLETE;
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Write medium mode register: %d", ret);
+		goto out2;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0,
+				AX88772_IPG0_DEFAULT |
+				(AX88772_IPG1_DEFAULT << 8),
+				AX88772_IPG2_DEFAULT, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Write IPG,IPG1,IPG2 failed: %d", ret);
+		goto out2;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to set hardware MII: %02x", ret);
+		goto out2;
+	}
+
+	/* Set RX_CTL to default values with 2k buffer, and enable cactus */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, 0x0088, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+		goto out2;
+	}
+
+	/* Asix framing packs multiple eth frames into a 2K usb bulk transfer */
+	if (dev->driver_info->flags & FLAG_FRAMING_AX) {
+		/* hard_mtu  is still the default - the device does not support
+		   jumbo eth frames */
+		dev->rx_urb_size = 2048;
+	}
+
+	kfree(buf);
+	printk(version);
+	return 0;
+
+out2:
+	destroy_workqueue(ax772_data->ax_work);
+	kfree(ax772_data);
+	kfree(buf);
+out1:
+	return ret;
+}
+
+static void ax88772_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
+
+	if (ax772_data) {
+		flush_workqueue(ax772_data->ax_work);
+		destroy_workqueue(ax772_data->ax_work);
+
+		/* stop MAC operation */
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, AX_RX_CTL_STOP,
+				  0, 0, NULL);
+
+		/* Power down PHY */
+		ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPPD,
+				  0, 0, NULL);
+
+		kfree(ax772_data);
+	}
+}
+
+static int ax88772a_phy_powerup(struct usbnet *dev)
+{
+	int ret;
+	/* set the embedded Ethernet PHY in power-down state */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_IPPD | AX_SWRESET_IPRL, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to power down PHY: %d", ret);
+		return ret;
+	}
+
+	msleep(10);
+
+	/* set the embedded Ethernet PHY in power-up state */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPRL,
+				0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to reset PHY: %d", ret);
+		return ret;
+	}
+
+	msleep(600);
+
+	/* set the embedded Ethernet PHY in reset state */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_CLEAR,
+				0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to power up PHY: %d", ret);
+		return ret;
+	}
+
+	/* set the embedded Ethernet PHY in power-up state */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPRL,
+				0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to reset PHY: %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ax88772a_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+	int ret = -EIO;
+	void *buf;
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	struct ax88772a_data *ax772a_data = NULL;
+
+	printk(version);
+
+	axusbnet_get_endpoints(dev, intf);
+
+	buf = kmalloc(6, GFP_KERNEL);
+	if (!buf) {
+		deverr(dev, "Cannot allocate memory for buffer");
+		ret = -ENOMEM;
+		goto out1;
+	}
+
+	ax772a_data = kmalloc(sizeof(*ax772a_data), GFP_KERNEL);
+	if (!ax772a_data) {
+		deverr(dev, "Cannot allocate memory for AX88772A data");
+		kfree(buf);
+		return -ENOMEM;
+	}
+	memset(ax772a_data, 0, sizeof(*ax772a_data));
+	dev->priv = ax772a_data;
+
+	ax772a_data->ax_work = create_singlethread_workqueue("ax88772a");
+	if (!ax772a_data->ax_work) {
+		kfree(ax772a_data);
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	ax772a_data->dev = dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+	INIT_WORK(&ax772a_data->check_link, ax88772a_link_reset, dev);
+#else
+	INIT_WORK(&ax772a_data->check_link, ax88772a_link_reset);
+#endif
+
+	/* Get the EEPROM data*/
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM, 0x0017, 0, 2,
+			       (void *)&ax772a_data->EepromData);
+	if (ret < 0) {
+		deverr(dev, "read SROM address 17h failed: %d", ret);
+		goto out2;
+	}
+	le16_to_cpus(&ax772a_data->EepromData);
+	/* End of get EEPROM data */
+
+	/* reload eeprom data */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+				AXGPIOS_RSE, 0, 0, NULL);
+	if (ret < 0)
+		goto out2;
+
+	msleep(5);
+
+	/* Initialize MII structure */
+	dev->mii.dev = dev->net;
+	dev->mii.mdio_read = ax8817x_mdio_read_le;
+	dev->mii.mdio_write = ax8817x_mdio_write_le;
+	dev->mii.phy_id_mask = 0xff;
+	dev->mii.reg_num_mask = 0xff;
+
+	/* Get the PHY id */
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf);
+	if (ret < 0) {
+		deverr(dev, "Error reading PHY ID: %02x", ret);
+		goto out2;
+	} else if (ret < 2) {
+		/* this should always return 2 bytes */
+		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
+			ret);
+		goto out2;
+	}
+	dev->mii.phy_id = *((u8 *)buf + 1);
+
+	if (dev->mii.phy_id != 0x10) {
+		deverr(dev, "Got wrong PHY ID: %02x", dev->mii.phy_id);
+		goto out2;
+	}
+
+	/* select the embedded 10/100 Ethernet PHY */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
+			AX_PHYSEL_SSEN | AX_PHYSEL_PSEL | AX_PHYSEL_SSMII,
+			0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Select PHY #1 failed: %d", ret);
+		goto out2;
+	}
+
+	ret = ax88772a_phy_powerup(dev);
+	if (ret < 0)
+		goto out2;
+
+	/* stop MAC operation */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, AX_RX_CTL_STOP,
+				0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+		goto out2;
+	}
+
+	/* Get the MAC address */
+	memset(buf, 0, ETH_ALEN);
+	ret = ax8817x_get_mac(dev, buf);
+	if (ret < 0) {
+		deverr(dev, "Get HW address failed: %d", ret);
+		goto out2;
+	}	
+
+	/* make sure the driver can enable sw mii operation */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Enabling software MII failed: %d", ret);
+		goto out2;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	dev->net->do_ioctl = ax8817x_ioctl;
+	dev->net->set_multicast_list = ax8817x_set_multicast;
+	dev->net->set_mac_address = ax8817x_set_mac_addr;
+#else
+	dev->net->netdev_ops = &ax88x72_netdev_ops;
+#endif
+
+	dev->net->ethtool_ops = &ax88772_ethtool_ops;
+
+	/* Register suspend and resume functions */
+	data->suspend = ax88772_suspend;
+	data->resume = ax88772_resume;
+
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+			ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+
+	mii_nway_restart(&dev->mii);
+	ax772a_data->autoneg_start = jiffies;
+	ax772a_data->Event = WAIT_AUTONEG_COMPLETE;
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+				0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Write medium mode register: %d", ret);
+		goto out2;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0,
+			AX88772A_IPG0_DEFAULT | AX88772A_IPG1_DEFAULT << 8,
+			AX88772A_IPG2_DEFAULT, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Write IPG,IPG1,IPG2 failed: %d", ret);
+		goto out2;
+	}
+
+	memset(buf, 0, 4);
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_IPG012, 0, 0, 3, buf);
+	*((u8 *)buf + 3) = 0x00;
+	if (ret < 0) {
+		deverr(dev, "Failed to read IPG,IPG1,IPG2 failed: %d", ret);
+		goto out2;
+	} else {
+		__u32 tmp32 = *((u32*)buf);
+		le32_to_cpus(&tmp32);
+		if (tmp32 != (AX88772A_IPG2_DEFAULT << 16 |
+			AX88772A_IPG1_DEFAULT << 8 | AX88772A_IPG0_DEFAULT)) {
+			printk("Non-authentic ASIX product\nASIX does not support it\n");
+			ret = -ENODEV;		
+			goto out2;
+		}
+	}
+
+	/* Set RX_CTL to default values with 2k buffer, and enable cactus */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+			(AX_RX_CTL_START | AX_RX_CTL_AB),
+			0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+		goto out2;
+	}
+
+	/* Asix framing packs multiple eth frames into a 2K usb bulk transfer */
+	if (dev->driver_info->flags & FLAG_FRAMING_AX) {
+		/* hard_mtu  is still the default - the device does not support
+		   jumbo eth frames */
+		dev->rx_urb_size = 2048;
+	}
+
+	kfree(buf);
+
+	return ret;
+out2:
+	destroy_workqueue(ax772a_data->ax_work);
+	kfree(ax772a_data);
+	kfree(buf);
+out1:
+	return ret;
+}
+
+static void ax88772a_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+	struct ax88772a_data *ax772a_data = (struct ax88772a_data *)dev->priv;
+
+	if (ax772a_data) {
+
+		flush_workqueue(ax772a_data->ax_work);
+		destroy_workqueue(ax772a_data->ax_work);
+
+		/* stop MAC operation */
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+					AX_RX_CTL_STOP, 0, 0, NULL);
+
+		/* Power down PHY */
+		ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPPD, 0, 0, NULL);
+
+		kfree(ax772a_data);
+	}
+}
+
+static int ax88772b_set_csums(struct usbnet *dev)
+{
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+	u16 checksum;
+
+	if (ax772b_data->checksum & AX_RX_CHECKSUM)
+		checksum = AX_RXCOE_DEF_CSUM;
+	else
+		checksum = 0;
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_RXCOE_CTL,
+				 checksum, 0, 0, NULL);
+
+	if (ax772b_data->checksum & AX_TX_CHECKSUM)
+		checksum = AX_TXCOE_DEF_CSUM;
+	else
+		checksum = 0;
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_TXCOE_CTL,
+				 checksum, 0, 0, NULL);
+
+	return 0;
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)
+static u32 ax88772b_get_tx_csum(struct net_device *netdev)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	return ax772b_data->checksum & AX_TX_CHECKSUM;
+}
+
+static u32 ax88772b_get_rx_csum(struct net_device *netdev)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	return ax772b_data->checksum & AX_RX_CHECKSUM;
+}
+
+static int ax88772b_set_rx_csum(struct net_device *netdev, u32 val)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	if (val)
+		ax772b_data->checksum |= AX_RX_CHECKSUM;
+	else
+		ax772b_data->checksum &= ~AX_RX_CHECKSUM;
+
+	return ax88772b_set_csums(dev);
+}
+
+static int ax88772b_set_tx_csum(struct net_device *netdev, u32 val)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	if (val)
+		ax772b_data->checksum |= AX_TX_CHECKSUM;
+	else
+		ax772b_data->checksum &= ~AX_TX_CHECKSUM;
+
+	ethtool_op_set_tx_csum(netdev, val);
+
+	return ax88772b_set_csums(dev);
+}
+#endif
+static struct ethtool_ops ax88772b_ethtool_ops = {
+	.get_drvinfo		= ax8817x_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+	.get_msglevel		= axusbnet_get_msglevel,
+	.set_msglevel		= axusbnet_set_msglevel,
+	.get_wol		= ax8817x_get_wol,
+	.set_wol		= ax8817x_set_wol,
+	.get_eeprom_len		= ax8817x_get_eeprom_len,
+	.get_eeprom		= ax8817x_get_eeprom,
+	.get_settings		= ax8817x_get_settings,
+	.set_settings		= ax8817x_set_settings,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)
+	.set_tx_csum		= ax88772b_set_tx_csum,
+	.get_tx_csum		= ax88772b_get_tx_csum,
+	.get_rx_csum		= ax88772b_get_rx_csum,
+	.set_rx_csum		= ax88772b_set_rx_csum,
+#endif
+};
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+static const struct net_device_ops ax88772b_netdev_ops = {
+	.ndo_open		= axusbnet_open,
+	.ndo_stop		= axusbnet_stop,
+	.ndo_start_xmit		= axusbnet_start_xmit,
+	.ndo_tx_timeout		= axusbnet_tx_timeout,
+	.ndo_change_mtu		= axusbnet_change_mtu,
+	.ndo_do_ioctl		= ax8817x_ioctl,
+	.ndo_get_stats		= axusbnet_get_stats,
+	.ndo_set_mac_address	= ax8817x_set_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3, 2, 0)
+	.ndo_set_multicast_list	= ax88772b_set_multicast,
+#else
+	.ndo_set_rx_mode	= ax88772b_set_multicast,
+#endif
+};
+#endif
+
+static int ax88772b_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+	int ret;
+	void *buf;
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	struct ax88772b_data *ax772b_data;
+	u16 *tmp16;
+	u8 tempphyselect;
+	bool internalphy;
+
+	printk(version);
+
+	axusbnet_get_endpoints(dev, intf);
+
+	buf = kmalloc(6, GFP_KERNEL);
+	if (!buf) {
+		deverr(dev, "Cannot allocate memory for buffer");
+		return -ENOMEM;
+	}
+	tmp16 = (u16 *)buf;
+
+	ax772b_data = kmalloc(sizeof(*ax772b_data), GFP_KERNEL);
+	if (!ax772b_data) {
+		deverr(dev, "Cannot allocate memory for AX88772B data");
+		kfree(buf);
+		return -ENOMEM;
+	}
+	memset(ax772b_data, 0, sizeof(*ax772b_data));
+	dev->priv = ax772b_data;
+
+	ax772b_data->ax_work = create_singlethread_workqueue("ax88772b");
+	if (!ax772b_data->ax_work) {
+		kfree(buf);
+		kfree(ax772b_data);
+		return -ENOMEM;
+	}
+
+	ax772b_data->dev = dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+	INIT_WORK(&ax772b_data->check_link, ax88772b_link_reset, dev);
+#else
+	INIT_WORK(&ax772b_data->check_link, ax88772b_link_reset);
+#endif
+	ret = ax8817x_read_cmd(dev, AX_CMD_SW_PHY_STATUS,
+			       0, 0, 1, &tempphyselect);
+	if (ret < 0) {
+		deverr(dev,
+		       "read SW interface selection status register failed: %d\n",
+		       ret);
+		goto err_out;
+	}
+
+	tempphyselect &= 0x0C;
+
+	if (tempphyselect == AX_PHYSEL_SSRMII) {
+		internalphy = false;
+		ax772b_data->OperationMode = OPERATION_MAC_MODE;
+		ax772b_data->PhySelect = 0x00;
+	} else if (tempphyselect == AX_PHYSEL_SSRRMII) {
+		internalphy = true;
+		ax772b_data->OperationMode = OPERATION_PHY_MODE;
+		ax772b_data->PhySelect = 0x00;
+	} else if (tempphyselect == AX_PHYSEL_SSMII) {
+		internalphy = true;
+		ax772b_data->OperationMode = OPERATION_MAC_MODE;
+		ax772b_data->PhySelect = 0x01;
+	} else {
+		deverr(dev, "Unknown MII type\n");
+		goto err_out;
+	}
+
+	/* reload eeprom data */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS, AXGPIOS_RSE,
+				0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to enable GPIO finction: %d", ret);
+		goto err_out;
+	}
+	msleep(5);
+
+	/* Get the EEPROM data*/
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM, 0x18, 0, 2,
+			       (void *)tmp16);
+	if (ret < 0) {
+		deverr(dev, "read SROM address 18h failed: %d", ret);
+		goto err_out;
+	}
+	le16_to_cpus(tmp16);
+	ax772b_data->psc = *tmp16 & 0xFF00;
+	/* End of get EEPROM data */
+
+	/* Get the MAC address */
+	memset(buf, 0, ETH_ALEN);
+	ret = ax8817x_get_mac(dev, buf);
+	if (ret < 0) {
+		deverr(dev, "Get HW address failed: %d", ret);
+		goto err_out;
+	}
+
+	/* Initialize MII structure */
+	dev->mii.dev = dev->net;
+	dev->mii.mdio_read = ax8817x_mdio_read_le;
+	dev->mii.mdio_write = ax88772b_mdio_write_le;
+	dev->mii.phy_id_mask = 0xff;
+	dev->mii.reg_num_mask = 0xff;
+
+	/* Get the PHY id */
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf);
+	if (ret < 0) {
+		deverr(dev, "Error reading PHY ID: %02x", ret);
+		goto err_out;
+	} else if (ret < 2) {
+		/* this should always return 2 bytes */
+		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
+		    ret);
+		ret = -EIO;
+		goto err_out;
+	}
+
+	if (internalphy)
+		dev->mii.phy_id = *((u8 *)buf + 1);
+	else
+		dev->mii.phy_id = *((u8 *)buf);
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
+				ax772b_data->PhySelect, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Select PHY #1 failed: %d", ret);
+		goto err_out;
+	}
+
+#if 0
+	/* select the embedded 10/100 Ethernet PHY */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
+			AX_PHYSEL_SSEN | AX_PHYSEL_PSEL | AX_PHYSEL_SSMII,
+			0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Select PHY #1 failed: %d", ret);
+		goto err_out;
+	}
+
+	if (dev->mii.phy_id != 0x10) {
+		deverr(dev, "Got wrong PHY ID: %02x", dev->mii.phy_id);
+		ret = -EIO;
+		goto err_out;
+	}
+#endif
+	ret = ax88772a_phy_powerup(dev);
+	if (ret < 0)
+		goto err_out;
+
+	/* stop MAC operation */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+				AX_RX_CTL_STOP, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+		goto err_out;
+	}
+
+	/* make sure the driver can enable sw mii operation */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Enabling software MII failed: %d", ret);
+		goto err_out;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	dev->net->do_ioctl = ax8817x_ioctl;
+	dev->net->set_multicast_list = ax88772b_set_multicast;
+	dev->net->set_mac_address = ax88772b_set_mac_addr;
+#else
+	dev->net->netdev_ops = &ax88772b_netdev_ops;
+#endif
+
+	dev->net->ethtool_ops = &ax88772b_ethtool_ops;
+
+	/* Register suspend and resume functions */
+	data->suspend = ax88772b_suspend;
+	data->resume = ax88772b_resume;
+
+	if (ax772b_data->OperationMode == OPERATION_PHY_MODE)
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id
+						, MII_BMCR, 0x3900);
+
+	if (dev->mii.phy_id != 0x10)
+		ax8817x_mdio_write_le(dev->net, 0x10, MII_BMCR, 0x3900);
+
+	if (dev->mii.phy_id == 0x10 && ax772b_data->OperationMode
+						!= OPERATION_PHY_MODE) {
+
+		*tmp16 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, 0x12,
+					((*tmp16 & 0xFF9F) | 0x0040));
+	}
+
+	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+			ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+
+	mii_nway_restart(&dev->mii);
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+				0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to write medium mode: %d", ret);
+		goto err_out;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0,
+			AX88772A_IPG0_DEFAULT | AX88772A_IPG1_DEFAULT << 8,
+			AX88772A_IPG2_DEFAULT, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Failed to write interframe gap: %d", ret);
+		goto err_out;
+	}
+
+	memset(buf, 0, 4);
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_IPG012, 0, 0, 3, buf);
+	*((u8 *)buf + 3) = 0x00;
+	if (ret < 0) {
+		deverr(dev, "Failed to read IPG,IPG1,IPG2 failed: %d", ret);
+		goto err_out;
+	} else {
+		__u32 tmp32 = *((u32*)buf);
+		le32_to_cpus(&tmp32);
+		if (tmp32 != (AX88772A_IPG2_DEFAULT << 16 |
+			AX88772A_IPG1_DEFAULT << 8 | AX88772A_IPG0_DEFAULT)) {
+			printk("Non-authentic ASIX product\nASIX does not support it\n");
+			ret = -ENODEV;		
+			goto err_out;
+		}
+	}
+
+	dev->net->features |= NETIF_F_IP_CSUM;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22)
+	dev->net->features |= NETIF_F_IPV6_CSUM;
+#endif
+
+	ax772b_data->checksum = AX_RX_CHECKSUM | AX_TX_CHECKSUM;
+	ret = ax88772b_set_csums(dev);
+	if (ret < 0) {
+		deverr(dev, "Write RX_COE/TX_COE failed: %d", ret);
+		goto err_out;
+	}
+
+	dev->rx_size = bsize & 0x07;
+	if (dev->udev->speed == USB_SPEED_HIGH) {
+
+		ret = ax8817x_write_cmd(dev, 0x2A,
+				AX88772B_BULKIN_SIZE[dev->rx_size].byte_cnt,
+				AX88772B_BULKIN_SIZE[dev->rx_size].threshold,
+				0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Reset RX_CTL failed: %d", ret);
+			goto err_out;
+		}
+
+		dev->rx_urb_size = AX88772B_BULKIN_SIZE[dev->rx_size].size;
+	} else {
+		ret = ax8817x_write_cmd(dev, 0x2A,
+				0x8000, 0x8001, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Reset RX_CTL failed: %d", ret);
+			goto err_out;
+		}
+		dev->rx_urb_size = 2048;
+	}
+
+	/* Configure RX header type */
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+		      (AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_HEADER_DEFAULT),
+		      0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Reset RX_CTL failed: %d", ret);
+		goto err_out;
+	}
+
+	/* Overwrite power saving configuration from eeprom */
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPRL |
+				(ax772b_data->psc & 0x7FFF), 0, 0, NULL);
+
+	if (ret < 0) {
+		deverr(dev, "Failed to configure PHY power saving: %d", ret);
+		goto err_out;
+	}
+
+	if (ax772b_data->OperationMode == OPERATION_PHY_MODE)
+		netif_carrier_on(dev->net);
+
+	kfree(buf);
+
+	return ret;
+err_out:
+	destroy_workqueue(ax772b_data->ax_work);
+	kfree(buf);
+	kfree(ax772b_data);
+	return ret;
+}
+
+static void ax88772b_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	if (ax772b_data) {
+
+		flush_workqueue(ax772b_data->ax_work);
+		destroy_workqueue(ax772b_data->ax_work);
+
+		/* stop MAC operation */
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+					AX_RX_CTL_STOP, 0, 0, NULL);
+
+		/* Power down PHY */
+		ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPPD, 0, 0, NULL);
+
+		kfree(ax772b_data);
+	}
+}
+
+static int
+ax88178_media_check(struct usbnet *dev, struct ax88178_data *ax178dataptr)
+{
+	int fullduplex, i = 0;
+	u16 tempshort = 0;
+	u16 media;
+	u16 advertise, lpa, result, stat1000, _lpa, _stat1000, delay = 5 * HZ;
+	unsigned long jtimeout;
+
+	jtimeout = jiffies + delay;
+	do {
+		_lpa = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_LPA);
+		_stat1000 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+						  MII_STAT1000);
+
+		lpa = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_LPA);
+		stat1000 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+						MII_STAT1000);
+
+		if (time_after(jiffies, jtimeout))
+			break;
+
+	} while ((_lpa != lpa) || (_stat1000 != stat1000) || i++ < 3);
+
+	advertise = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+					 MII_ADVERTISE);
+	result = advertise & lpa;
+
+	if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+	    (ax178dataptr->LedMode == 1)) {
+		tempshort = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+						 MARVELL_MANUAL_LED) & 0xfc0f;
+	}
+
+	fullduplex = 1;
+	if (stat1000 & LPA_1000FULL) {
+		media = MEDIUM_GIGA_MODE | MEDIUM_FULL_DUPLEX_MODE |
+			MEDIUM_ENABLE_125MHZ | MEDIUM_ENABLE_RECEIVE;
+		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+		    (ax178dataptr->LedMode == 1))
+			tempshort |= 0x3e0;
+	} else if (result & LPA_100FULL) {
+		media = MEDIUM_FULL_DUPLEX_MODE | MEDIUM_ENABLE_RECEIVE |
+			MEDIUM_MII_100M_MODE;
+		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+		    (ax178dataptr->LedMode == 1))
+			tempshort |= 0x3b0;
+	} else if (result & LPA_100HALF) {
+		fullduplex = 0;
+		media = MEDIUM_ENABLE_RECEIVE | MEDIUM_MII_100M_MODE;
+		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+		    (ax178dataptr->LedMode == 1))
+			tempshort |= 0x3b0;
+	} else if (result & LPA_10FULL) {
+		media = MEDIUM_FULL_DUPLEX_MODE | MEDIUM_ENABLE_RECEIVE;
+		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+		    (ax178dataptr->LedMode == 1))
+			tempshort |= 0x2f0;
+	} else {
+		media = MEDIUM_ENABLE_RECEIVE;
+		fullduplex = 0;
+		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+		    (ax178dataptr->LedMode == 1))
+				tempshort |= 0x02f0;
+	}
+
+	if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
+	    (ax178dataptr->LedMode == 1)) {
+		ax8817x_mdio_write_le(dev->net,
+			dev->mii.phy_id, MARVELL_MANUAL_LED, tempshort);
+	}
+
+	media |= 0x0004;
+	if (ax178dataptr->UseRgmii)
+		media |= 0x0008;
+	if (fullduplex) {
+		media |= 0x0020;  /* ebable tx flow control as default; */
+		media |= 0x0010;  /* ebable rx flow control as default; */
+	}
+
+	return media;
+}
+
+static void Vitess_8601_Init(struct usbnet *dev, int state)
+{
+	u16 reg;
+
+	switch (state) {
+	case 0:	/* tx, rx clock skew */
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id, 31, 1);
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id, 28, 0);
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id, 31, 0);
+		break;
+
+	case 1:
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 31, 0x52B5);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18, 0x009E);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, 0xDD39);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87AA);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0xA7B4);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18,
+				ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 18));
+
+		reg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 17) & ~0x003f) | 0x003c;
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, reg);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87B4);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0xa794);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18,
+				ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 18));
+
+		reg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 17) & ~0x003f) | 0x003e;
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, reg);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x8794);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18, 0x00f7);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, 0xbe36);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x879e);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0xa7a0);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18,
+				ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 18));
+
+		reg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 17) & ~0x003f) | 0x0034;
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, reg);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87a0);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18, 0x003c);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, 0xf3cf);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87a2);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18, 0x003c);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, 0xf3cf);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87a4);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18, 0x003c);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, 0xd287);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87a6);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0xa7a8);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18,
+				ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 18));
+
+		reg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 17) & ~0x0fff) | 0x0125;
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, reg);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87a8);
+
+		/* Enable Smart Pre-emphasis */
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0xa7fa);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 18,
+				ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 18));
+
+		reg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 17) & ~0x0008) | 0x0008;
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 17, reg);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 16, 0x87fa);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 31, 0);
+
+		break;
+	}
+}
+
+static void
+marvell_88E1510_magic_init(struct usbnet *dev)
+{
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 22, 0xff);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 17, 0x214b);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 16, 0x2144);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 17, 0x0c28);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 16, 0x2146);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 17, 0xb233);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 16, 0x214d);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 17, 0xcc0c);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 16, 0x2159);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 22, 0x00fb);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 7, 0xc00d);
+	ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 22, 0);
+}
+
+static int
+ax88178_phy_init(struct usbnet *dev, struct ax88178_data *ax178dataptr)
+{
+	int i;
+	u16 phyanar, phyauxctrl, phyctrl, tempshort, phyid1;
+	u16 phyreg = 0;
+
+	/* Disable MII operation of AX88178 Hardware */
+	ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0x0000, 0, 0, NULL);
+
+
+	/* Read SROM - MiiPhy Address (ID) */
+	ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, &dev->mii.phy_id);
+	le32_to_cpus(&dev->mii.phy_id);
+
+	/* Initialize MII structure */
+	dev->mii.phy_id >>= 8;
+	dev->mii.phy_id &= PHY_ID_MASK;
+	dev->mii.dev = dev->net;
+	dev->mii.mdio_read = ax8817x_mdio_read_le;
+	dev->mii.mdio_write = ax8817x_mdio_write_le;
+	dev->mii.phy_id_mask = 0x3f;
+	dev->mii.reg_num_mask = 0x1f;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 11)
+	dev->mii.supports_gmii = 1;
+#endif
+
+	if (ax178dataptr->PhyMode == PHY_MODE_MAC_TO_MAC_GMII) {
+		ax178dataptr->UseRgmii = 0;
+		ax178dataptr->MediaLink = MEDIUM_GIGA_MODE |
+					  MEDIUM_FULL_DUPLEX_MODE |
+					  MEDIUM_ENABLE_125MHZ |
+					  MEDIUM_ENABLE_RECEIVE |
+					  MEDIUM_ENABLE_RX_FLOWCTRL |
+					  MEDIUM_ENABLE_TX_FLOWCTRL;
+		goto SKIPPHYSETTING;
+	}
+
+	/* test read phy register 2 */
+	if (!ax178dataptr->UseGpio0) {
+		i = 1000;
+		while (i--) {
+			phyid1 = ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, GMII_PHY_OUI);
+			if ((phyid1 == 0x000f) || (phyid1 == 0x0141) ||
+			    (phyid1 == 0x0282) || (phyid1 == 0x004d) ||
+			    (phyid1 == 0x0243) || (phyid1 == 0x001C) ||
+			    (phyid1 == 0x0007))
+				break;
+			msleep(5);
+		}
+		if (i < 0)
+			return -EIO;
+	}
+
+	ax178dataptr->UseRgmii = 0;
+	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
+		phyreg = ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 27);
+		if (!(phyreg & 4) && !(ax178dataptr->LedMode & 0x10)) {
+			ax178dataptr->UseRgmii = 1;
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 20, 0x82);
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		} else if (ax178dataptr->LedMode & 0x10) {
+
+			ax178dataptr->UseRgmii = 1;
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+			marvell_88E1510_magic_init(dev);
+
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 22, 2);
+
+			phyreg = ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 21);
+
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 21, phyreg | 0x30);
+
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 22, 0);
+		}
+	} else if ((ax178dataptr->PhyMode == PHY_MODE_AGERE_V0) ||
+		 (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0_GMII)) {
+		if (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0) {
+			ax178dataptr->UseRgmii = 1;
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		}
+	} else if (ax178dataptr->PhyMode == PHY_MODE_CICADA_V1) {
+		/* not Cameo */
+		if (!ax178dataptr->UseGpio0 || ax178dataptr->LedMode) {
+			ax178dataptr->UseRgmii = 1;
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		}
+
+		for (i = 0; i < (sizeof(CICADA_FAMILY_HWINIT) /
+				 sizeof(CICADA_FAMILY_HWINIT[0])); i++) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+						    dev->mii.phy_id,
+					CICADA_FAMILY_HWINIT[i].offset,
+					CICADA_FAMILY_HWINIT[i].value);
+		}
+
+	} else if (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2) {
+		/* not Cameo */
+		if (!ax178dataptr->UseGpio0 || ax178dataptr->LedMode) {
+			ax178dataptr->UseRgmii = 1;
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		}
+
+		for (i = 0; i < (sizeof(CICADA_V2_HWINIT) /
+				 sizeof(CICADA_V2_HWINIT[0])); i++) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, CICADA_V2_HWINIT[i].offset,
+				CICADA_V2_HWINIT[i].value);
+		}
+	} else if (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2_ASIX) {
+		/* not Cameo */
+		if (!ax178dataptr->UseGpio0 || ax178dataptr->LedMode) {
+			ax178dataptr->UseRgmii = 1;
+			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		}
+
+		for (i = 0; i < (sizeof(CICADA_V2_HWINIT) /
+				 sizeof(CICADA_V2_HWINIT[0])); i++) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, CICADA_V2_HWINIT[i].offset,
+				CICADA_V2_HWINIT[i].value);
+		}
+	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8211CL) {
+		ax178dataptr->UseRgmii = 1;
+		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8211BN) {
+		ax178dataptr->UseRgmii = 1;
+		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8251CL) {
+		ax178dataptr->UseRgmii = 1;
+		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+	} else if (ax178dataptr->PhyMode == PHY_MODE_VSC8601) {
+		ax178dataptr->UseRgmii = 1;
+		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
+		/* Vitess_8601_Init (dev, 0); */
+	}
+
+	if (ax178dataptr->PhyMode != PHY_MODE_ATTANSIC_V0) {
+		/* software reset */
+		ax8817x_swmii_mdio_write_le(
+			dev->net, dev->mii.phy_id, GMII_PHY_CONTROL,
+			ax8817x_swmii_mdio_read_le(
+				dev->net, dev->mii.phy_id, GMII_PHY_CONTROL)
+				| GMII_CONTROL_RESET);
+		msleep(1);
+	}
+
+	if ((ax178dataptr->PhyMode == PHY_MODE_AGERE_V0) ||
+	    (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0_GMII)) {
+		if (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0) {
+			i = 1000;
+			while (i--) {
+				ax8817x_swmii_mdio_write_le(dev->net,
+						dev->mii.phy_id, 21, 0x1001);
+
+				phyreg = ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 21);
+				if ((phyreg & 0xf00f) == 0x1001)
+					break;
+			}
+			if (i < 0)
+				return -EIO;
+		}
+
+		if (ax178dataptr->LedMode == 4) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 28, 0x7417);
+		} else if (ax178dataptr->LedMode == 9) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 28, 0x7a10);
+		} else if (ax178dataptr->LedMode == 10) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 28, 0x7a13);
+		}
+
+		for (i = 0; i < (sizeof(AGERE_FAMILY_HWINIT) /
+				 sizeof(AGERE_FAMILY_HWINIT[0])); i++) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, AGERE_FAMILY_HWINIT[i].offset,
+				AGERE_FAMILY_HWINIT[i].value);
+		}
+	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8211CL) {
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 0x1f, 0x0005);
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 0x0c, 0);
+
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id, 0x01,
+					(ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 0x01) | 0x0080));
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, 0x1f, 0);
+
+		if (ax178dataptr->LedMode == 12) {
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 0x1f, 0x0002);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 0x1a, 0x00cb);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 0x1f, 0);
+		}
+	} else if (ax178dataptr->PhyMode == PHY_MODE_VSC8601) {
+		Vitess_8601_Init(dev, 1);
+	}
+
+	/* read phy register 0 */
+	phyctrl = ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, GMII_PHY_CONTROL);
+	tempshort = phyctrl;
+	phyctrl &= ~(GMII_CONTROL_POWER_DOWN | GMII_CONTROL_ISOLATE);
+	if (phyctrl != tempshort) {
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, GMII_PHY_CONTROL, phyctrl);
+	}
+
+	/* LED */
+	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
+		if (ax178dataptr->LedMode == 1)	{
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+				dev->mii.phy_id, 24) & 0xf8ff) | (1 + 0x100);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+			phyreg = ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 25) & 0xfc0f;
+		} else if (ax178dataptr->LedMode == 2) {
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 24) & 0xf886) |
+					(1 + 0x10 + 0x300);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+		} else if (ax178dataptr->LedMode == 5) {
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 24) & 0xf8be) |
+					(1 + 0x40 + 0x300);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+		} else if (ax178dataptr->LedMode == 7) {
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+						dev->mii.phy_id, 24) & 0xf8ff) |
+						(1 + 0x100);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+
+		} else if (ax178dataptr->LedMode == 8) {
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 24) & 0xf8be) |
+					(1 + 0x40 + 0x100);
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+
+		} else if (ax178dataptr->LedMode == 11) {
+
+			phyreg = ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 24) & 0x4106;
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 24, phyreg);
+		} else if (ax178dataptr->LedMode == 0x10) {
+			/* MARVEL 88e1510 use default led setting */
+		}
+
+	} else if ((ax178dataptr->PhyMode == PHY_MODE_CICADA_V1) ||
+		   (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2) ||
+		   (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2_ASIX)) {
+
+		if (ax178dataptr->LedMode == 3) {
+
+			phyreg = (ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 27) & 0xFCFF) | 0x0100;
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 27, phyreg);
+		}
+
+	}
+
+	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
+		if (ax178dataptr->LedMode == 1)
+			phyreg |= 0x3f0;
+	}
+
+	phyanar = 1 | (GMII_ANAR_PAUSE | GMII_ANAR_100TXFD | GMII_ANAR_100TX |
+		       GMII_ANAR_10TFD | GMII_ANAR_10T | GMII_ANAR_ASYM_PAUSE);
+
+	phyauxctrl = GMII_1000_AUX_CTRL_FD_CAPABLE;
+
+	ax8817x_swmii_mdio_write_le(dev->net,
+			dev->mii.phy_id, GMII_PHY_ANAR, phyanar);
+	ax8817x_swmii_mdio_write_le(dev->net,
+			dev->mii.phy_id, GMII_PHY_1000BT_CONTROL, phyauxctrl);
+
+	if (ax178dataptr->PhyMode == PHY_MODE_VSC8601) {
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id,
+					    31, 0x52B5);
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id,
+					    16, 0xA7F8);
+
+		tempshort = ax8817x_swmii_mdio_read_le(dev->net,
+					dev->mii.phy_id, 17) & (~0x0018);
+
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id,
+					    17, tempshort);
+
+		tempshort = ax8817x_swmii_mdio_read_le(dev->net,
+						       dev->mii.phy_id, 18);
+
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id, 18,
+					    tempshort);
+
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id,
+					    16, 0x87F8);
+		ax8817x_swmii_mdio_write_le(dev->net, dev->mii.phy_id,
+					    31, 0);
+	}
+
+	if (ax178dataptr->PhyMode == PHY_MODE_ATTANSIC_V0) {
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, GMII_PHY_CONTROL, 0x9000);
+
+	} else {
+		phyctrl &= ~GMII_CONTROL_LOOPBACK;
+		phyctrl |= (GMII_CONTROL_ENABLE_AUTO | GMII_CONTROL_START_AUTO);
+
+		ax8817x_swmii_mdio_write_le(dev->net,
+				dev->mii.phy_id, GMII_PHY_CONTROL, phyctrl);
+	}
+
+	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
+		if (ax178dataptr->LedMode == 1)
+			ax8817x_swmii_mdio_write_le(dev->net,
+					dev->mii.phy_id, 25, phyreg);
+	}
+
+SKIPPHYSETTING:
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+			ax178dataptr->MediaLink, 0, 0, NULL);
+
+	ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0,
+			AX88772_IPG0_DEFAULT | (AX88772_IPG1_DEFAULT << 8),
+			AX88772_IPG2_DEFAULT, 0, NULL);
+
+	msleep(1);
+
+	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
+
+	return 0;
+}
+
+static int ax88178_bind(struct usbnet *dev, struct usb_interface *intf)
+{
+	int ret;
+	void *buf;
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+	struct ax88178_data *ax178dataptr = NULL;
+
+	axusbnet_get_endpoints(dev, intf);
+
+	buf = kmalloc(6, GFP_KERNEL);
+	if (!buf) {
+		deverr(dev, "Cannot allocate memory for buffer");
+		return -ENOMEM;
+	}
+
+	/* allocate 178 data */
+	ax178dataptr = kmalloc(sizeof(*ax178dataptr), GFP_KERNEL);
+	if (!ax178dataptr) {
+		deverr(dev, "Cannot allocate memory for AX88178 data");
+		ret = -ENOMEM;
+		goto error_out;
+	}
+	memset(ax178dataptr, 0, sizeof(struct ax88178_data));
+	dev->priv = ax178dataptr;
+	/* end of allocate 178 data */
+
+	/* Get the EEPROM data*/
+	ret = ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM, 0x0017, 0, 2,
+			       (void *)(&ax178dataptr->EepromData));
+	if (ret < 0) {
+		deverr(dev, "read SROM address 17h failed: %d", ret);
+		goto error_out;
+	}
+	le16_to_cpus(&ax178dataptr->EepromData);
+	/* End of get EEPROM data */
+
+	if (ax178dataptr->EepromData == 0xffff) {
+		ax178dataptr->PhyMode  = PHY_MODE_MARVELL;
+		ax178dataptr->LedMode  = 0;
+		ax178dataptr->UseGpio0 = 1; /* True */
+	} else {
+		ax178dataptr->PhyMode = (u8)(ax178dataptr->EepromData &
+					     EEPROMMASK);
+		ax178dataptr->LedMode = (u8)(ax178dataptr->EepromData >> 8);
+
+		/* for buffalo new (use gpio2) */
+		if (ax178dataptr->LedMode == 6)
+			ax178dataptr->LedMode = 1;
+		else if (ax178dataptr->LedMode == 1)
+			ax178dataptr->BuffaloOld = 1;
+
+
+		if (ax178dataptr->EepromData & 0x80)
+			ax178dataptr->UseGpio0 = 0; /* MARVEL se and other */
+		else
+			ax178dataptr->UseGpio0 = 1; /* cameo */
+	}
+
+	if (ax178dataptr->UseGpio0) {
+
+		if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					AXGPIOS_GPO0EN | AXGPIOS_RSE,
+					0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(25);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_GPO2 | AXGPIOS_GPO2EN |
+					 AXGPIOS_GPO0EN), 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(15);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					AXGPIOS_GPO2EN | AXGPIOS_GPO0EN,
+					0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(245);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_GPO2 | AXGPIOS_GPO2EN |
+					 AXGPIOS_GPO0EN), 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+		} else { /* vitesse */
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_RSE | AXGPIOS_GPO0EN |
+					 AXGPIOS_GPO0), 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(25);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_GPO0EN | AXGPIOS_GPO0 |
+					 AXGPIOS_GPO2EN | AXGPIOS_GPO2),
+					0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(25);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_GPO0EN | AXGPIOS_GPO0 |
+					 AXGPIOS_GPO2EN), 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(245);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						(AXGPIOS_GPO0EN | AXGPIOS_GPO0 |
+						AXGPIOS_GPO2EN | AXGPIOS_GPO2),
+						0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+		}
+	} else {	/* use gpio1 */
+		ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+					(AXGPIOS_GPO1 | AXGPIOS_GPO1EN |
+					AXGPIOS_RSE), 0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "write GPIO failed: %d", ret);
+			goto error_out;
+		}
+
+		if (ax178dataptr->BuffaloOld) {
+			msleep(350);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						AXGPIOS_GPO1EN, 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(350);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						AXGPIOS_GPO1EN | AXGPIOS_GPO1,
+						0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+		} else {
+			msleep(25);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						(AXGPIOS_GPO1EN | AXGPIOS_GPO1 |
+						AXGPIOS_GPO2EN | AXGPIOS_GPO2),
+						0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(25);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						(AXGPIOS_GPO1EN | AXGPIOS_GPO1 |
+						AXGPIOS_GPO2EN), 0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+
+			msleep(245);
+
+			ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
+						(AXGPIOS_GPO1EN | AXGPIOS_GPO1 |
+						AXGPIOS_GPO2EN | AXGPIOS_GPO2),
+						0, 0, NULL);
+			if (ret < 0) {
+				deverr(dev, "write GPIO failed: %d", ret);
+				goto error_out;
+			}
+		}
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Select PHY failed: %d", ret);
+		goto error_out;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPPD |
+				AX_SWRESET_PRL, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Issue sw reset failed: %d", ret);
+		goto error_out;
+	}
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, 0, 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "Issue rx ctrl failed: %d", ret);
+		goto error_out;
+	}
+
+	/* Get the MAC address */
+	memset(buf, 0, ETH_ALEN);
+	ax8817x_get_mac(dev, buf);
+	if (ret < 0)
+		goto error_out;
+	/* End of get MAC address */
+
+	ret = ax88178_phy_init(dev, ax178dataptr);
+	if (ret < 0)
+		goto error_out;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	dev->net->do_ioctl = ax8817x_ioctl;
+	dev->net->set_multicast_list = ax88178_set_multicast;
+	dev->net->set_mac_address = ax8817x_set_mac_addr;
+#else
+	dev->net->netdev_ops = &ax88178_netdev_ops;
+#endif
+	dev->net->ethtool_ops = &ax8817x_ethtool_ops;
+
+	/* Register suspend and resume functions */
+	data->suspend = ax88772_suspend;
+	data->resume = ax88772_resume;
+
+	if (dev->driver_info->flags & FLAG_FRAMING_AX)
+		dev->rx_urb_size = 16384;
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, (AX_RX_CTL_MFB |
+				AX_RX_CTL_START | AX_RX_CTL_AB), 0, 0, NULL);
+	if (ret < 0) {
+		deverr(dev, "write RX ctrl reg failed: %d", ret);
+		goto error_out;
+	}
+
+	kfree(buf);
+	printk(version);
+	return ret;
+
+error_out:
+	kfree(ax178dataptr);
+	kfree(buf);
+	return ret;
+}
+
+static void ax88178_unbind(struct usbnet *dev, struct usb_interface *intf)
+{
+	struct ax88178_data *ax178dataptr = (struct ax88178_data *)dev->priv;
+
+	if (ax178dataptr) {
+
+		/* stop MAC operation */
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
+					AX_RX_CTL_STOP, 0, 0, NULL);
+
+		kfree(ax178dataptr);
+	}
+}
+
+static int ax88772_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+{
+	u8  *head;
+	u32  header;
+	char *packet;
+	struct sk_buff *ax_skb;
+	u16 size;
+
+	head = (u8 *) skb->data;
+	memcpy(&header, head, sizeof(header));
+	le32_to_cpus(&header);
+	packet = head + sizeof(header);
+
+	skb_pull(skb, 4);
+
+	while (skb->len > 0) {
+		if ((short)(header & 0x00007ff) !=
+		    ~((short)(((header & 0xffff0000) | 0xf8000000) >> 16))) {
+			deverr(dev, "header length data is error 0x%08x, %d\n",
+				header, skb->len);
+		}
+		/* get the packet length */
+		size = (u16) (header & 0x00007ff);
+
+		if ((skb->len) - ((size + 1) & 0xfffe) == 0) {
+
+			/* Make sure ip header is aligned on 32-bit boundary */
+			if (!((unsigned long)skb->data & 0x02)) {
+				memmove(skb->data - 2, skb->data, size);
+				skb->data -= 2;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+				skb->tail = skb->data + size;
+#else
+				skb_set_tail_pointer(skb, size);
+#endif
+			}
+			skb->truesize = size + sizeof(struct sk_buff);
+			skb->len = size;
+
+			return 2;
+		}
+
+		if (size > ETH_FRAME_LEN) {
+			deverr(dev, "invalid rx length %d", size);
+			return 0;
+		}
+#ifndef RX_SKB_COPY
+		ax_skb = skb_clone(skb, GFP_ATOMIC);
+#else
+		ax_skb = alloc_skb(size + NET_IP_ALIGN, GFP_ATOMIC);	
+		skb_reserve(ax_skb, NET_IP_ALIGN);
+#endif
+		if (ax_skb) {
+#ifndef RX_SKB_COPY
+			/* Make sure ip header is aligned on 32-bit boundary */
+			if (!((unsigned long)packet & 0x02)) {
+				memmove(packet - 2, packet, size);
+				packet -= 2;
+			}
+			ax_skb->data = packet;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+			ax_skb->tail = packet + size;
+#else
+			skb_set_tail_pointer(ax_skb, size);
+#endif
+
+#else
+			skb_put(ax_skb, size);
+			memcpy(ax_skb->data, packet , size);
+#endif
+			ax_skb->truesize = size + sizeof(struct sk_buff);
+			axusbnet_skb_return(dev, ax_skb);
+
+		} else {
+			return 0;
+		}
+
+		skb_pull(skb, (size + 1) & 0xfffe);
+
+		if (skb->len == 0)
+			break;
+
+		head = (u8 *) skb->data;
+		memcpy(&header, head, sizeof(header));
+		le32_to_cpus(&header);
+		packet = head + sizeof(header);
+		skb_pull(skb, 4);
+	}
+
+	if (skb->len < 0) {
+		deverr(dev, "invalid rx length %d", skb->len);
+		return 0;
+	}
+	return 1;
+}
+
+static struct sk_buff *ax88772_tx_fixup(struct usbnet *dev, struct sk_buff *skb,
+					gfp_t flags)
+{
+	int padlen = ((skb->len + 4) % 512) ? 0 : 4;
+	u32 packet_len;
+	u32 padbytes = 0xffff0000;
+
+#if (!AX_FORCE_BUFF_ALIGN)
+	int headroom = skb_headroom(skb);
+	int tailroom = skb_tailroom(skb);
+
+	if ((!skb_cloned(skb))
+	    && ((headroom + tailroom) >= (4 + padlen))) {
+		if ((headroom < 4) || (tailroom < padlen)) {
+			skb->data = memmove(skb->head + 4, skb->data, skb->len);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+		skb->tail = skb->data + skb->len;
+#else
+		skb_set_tail_pointer(skb, skb->len);
+#endif
+		}
+	} else
+#endif
+	{
+		struct sk_buff *skb2;
+		skb2 = skb_copy_expand(skb, 4, padlen, flags);
+		dev_kfree_skb_any(skb);
+		skb = skb2;
+		if (!skb)
+			return NULL;
+	}
+
+	skb_push(skb, 4);
+	packet_len = (((skb->len - 4) ^ 0x0000ffff) << 16) + (skb->len - 4);
+	cpu_to_le32s(&packet_len);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+	memcpy(skb->data, &packet_len, sizeof(packet_len));
+#else
+	skb_copy_to_linear_data(skb, &packet_len, sizeof(packet_len));
+#endif
+
+	if ((skb->len % 512) == 0) {
+		cpu_to_le32s(&padbytes);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+		memcpy(skb->tail, &padbytes, sizeof(padbytes));
+#else
+		memcpy(skb_tail_pointer(skb), &padbytes, sizeof(padbytes));
+#endif
+		skb_put(skb, sizeof(padbytes));
+	}
+	return skb;
+}
+
+static void
+ax88772b_rx_checksum(struct sk_buff *skb, struct ax88772b_rx_header *rx_hdr)
+{
+	skb->ip_summed = CHECKSUM_NONE;
+
+	/* checksum error bit is set */
+	if (rx_hdr->l3_csum_err || rx_hdr->l4_csum_err)
+		return;
+
+	/* It must be a TCP or UDP packet with a valid checksum */
+	if ((rx_hdr->l4_type == AX_RXHDR_L4_TYPE_TCP) ||
+	    (rx_hdr->l4_type == AX_RXHDR_L4_TYPE_UDP)) {
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	}
+}
+
+static int ax88772b_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+{
+	struct ax88772b_rx_header rx_hdr;
+	struct sk_buff *ax_skb;
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+
+	while (skb->len > 0) {
+
+		le16_to_cpus((u16 *)skb->data);
+		le16_to_cpus(((u16 *)skb->data) + 1);
+
+		memcpy(&rx_hdr, skb->data, sizeof(struct ax88772b_rx_header));
+
+		if ((short)rx_hdr.len != (~((short)rx_hdr.len_bar) & 0x7FF))
+			return 0;
+
+		if (rx_hdr.len > (ETH_FRAME_LEN + 4)) {
+			deverr(dev, "invalid rx length %d", rx_hdr.len);
+			return 0;
+		}
+
+		if (skb->len - ((rx_hdr.len +
+				 sizeof(struct ax88772b_rx_header) + 3) &
+				 0xfffc) == 0) {
+			skb_pull(skb, sizeof(struct ax88772b_rx_header));
+			skb->len = rx_hdr.len;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+			skb->tail = skb->data + rx_hdr.len;
+#else
+			skb_set_tail_pointer(skb, rx_hdr.len);
+#endif
+			skb->truesize = rx_hdr.len + sizeof(struct sk_buff);
+
+			if (ax772b_data->checksum & AX_RX_CHECKSUM)
+				ax88772b_rx_checksum(skb, &rx_hdr);
+
+			return 2;
+		}
+#ifndef RX_SKB_COPY
+		ax_skb = skb_clone(skb, GFP_ATOMIC);
+#else
+		ax_skb = alloc_skb(rx_hdr.len + NET_IP_ALIGN, GFP_ATOMIC);
+		skb_reserve(ax_skb, NET_IP_ALIGN);	
+#endif
+		if (ax_skb) {
+#ifndef RX_SKB_COPY
+			ax_skb->len = rx_hdr.len;
+			ax_skb->data = skb->data +
+				       sizeof(struct ax88772b_rx_header);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+			ax_skb->tail = ax_skb->data + rx_hdr.len;
+#else
+			skb_set_tail_pointer(ax_skb, rx_hdr.len);
+#endif
+
+#else
+			skb_put(ax_skb, rx_hdr.len);
+			memcpy(ax_skb->data, skb->data + sizeof(struct ax88772b_rx_header), rx_hdr.len); 
+#endif
+
+			ax_skb->truesize = rx_hdr.len + sizeof(struct sk_buff);
+
+			if (ax772b_data->checksum & AX_RX_CHECKSUM)
+				ax88772b_rx_checksum(ax_skb, &rx_hdr);
+
+			axusbnet_skb_return(dev, ax_skb);
+
+		} else {
+			return 0;
+		}
+
+		skb_pull(skb, ((rx_hdr.len +
+				sizeof(struct ax88772b_rx_header) + 3)
+				& 0xfffc));
+	}
+
+	if (skb->len < 0) {
+		deverr(dev, "invalid rx length %d", skb->len);
+		return 0;
+	}
+	return 1;
+}
+
+static struct sk_buff *
+ax88772b_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
+{
+	int padlen = ((skb->len + 4) % 512) ? 0 : 4;
+	u32 packet_len;
+	u32 padbytes = 0xffff0000;
+
+#if (!AX_FORCE_BUFF_ALIGN)
+	int headroom = skb_headroom(skb);
+	int tailroom = skb_tailroom(skb);
+
+	if ((!skb_cloned(skb))
+	    && ((headroom + tailroom) >= (4 + padlen))) {
+		if ((headroom < 4) || (tailroom < padlen)) {
+			skb->data = memmove(skb->head + 4, skb->data, skb->len);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+			skb->tail = skb->data + skb->len;
+#else
+			skb_set_tail_pointer(skb, skb->len);
+#endif
+		}
+	} else
+#endif
+	{
+		struct sk_buff *skb2;
+		skb2 = skb_copy_expand(skb, 4, padlen, flags);
+		dev_kfree_skb_any(skb);
+		skb = skb2;
+		if (!skb)
+			return NULL;
+	}
+
+	skb_push(skb, 4);
+	packet_len = (((skb->len - 4) ^ 0x0000ffff) << 16) + (skb->len - 4);
+
+	cpu_to_le32s(&packet_len);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+	memcpy(skb->data, &packet_len, sizeof(packet_len));
+#else
+	skb_copy_to_linear_data(skb, &packet_len, sizeof(packet_len));
+#endif
+
+	if ((skb->len % 512) == 0) {
+		cpu_to_le32s(&padbytes);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+		memcpy(skb->tail, &padbytes, sizeof(padbytes));
+#else
+		memcpy(skb_tail_pointer(skb), &padbytes, sizeof(padbytes));
+#endif
+		skb_put(skb, sizeof(padbytes));
+	}
+
+	return skb;
+}
+
+static const u8 chkcntsel[6][3] = {
+	{12, 23, 31},
+	{12, 31, 23},
+	{23, 31, 12},
+	{23, 12, 31},
+	{31, 12, 23},
+	{31, 23, 12}
+};
+
+static void ax88772_save_bmcr_anar(struct usbnet *dev)
+{
+	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
+
+	if (ax772_data) {
+		/* Preserve BMCR for restoring */
+		ax772_data->presvd_phy_bmcr =
+			ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_BMCR);
+
+		/* Preserve Advertisement control reg for restoring */
+		ax772_data->presvd_phy_advertise =
+			ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+	}
+}
+
+static void ax88772_restore_bmcr_anar(struct usbnet *dev)
+{
+	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
+
+	if (ax772_data && ax772_data->presvd_phy_advertise && ax772_data->presvd_phy_bmcr) {
+		/* Restore Advertisement control reg */
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+				      ax772_data->presvd_phy_advertise);
+		/* Restore BMCR */
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR,
+				      ax772_data->presvd_phy_bmcr);
+		ax772_data->presvd_phy_advertise = 0;
+		ax772_data->presvd_phy_bmcr = 0;
+	}
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void ax88772_link_reset(void *data)
+{
+	struct usbnet *dev = (struct usbnet *)data;
+	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
+#else
+static void ax88772_link_reset(struct work_struct *work)
+{
+	struct ax88772_data *ax772_data = container_of(work,
+						       struct ax88772_data,
+						       check_link);
+	struct usbnet *dev = ax772_data->dev;
+#endif
+	if (ax772_data->Event == AX_SET_RX_CFG) {
+		u16 bmcr;
+		u16 mode;
+
+		ax772_data->Event = AX_NOP;
+
+		mode = AX88772_MEDIUM_DEFAULT;
+
+		bmcr = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+					    MII_BMCR);
+		if (!(bmcr & BMCR_FULLDPLX))
+			mode &= ~AX88772_MEDIUM_FULL_DUPLEX;
+		if (!(bmcr & BMCR_SPEED100))
+			mode &= ~AX88772_MEDIUM_100MB;
+
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
+				  mode, 0, 0, NULL);
+		return;
+	}
+
+	switch (ax772_data->Event) {
+	case WAIT_AUTONEG_COMPLETE:
+		if (jiffies > (ax772_data->autoneg_start + 5 * HZ)) {
+			ax772_data->Event = PHY_POWER_DOWN;
+			ax772_data->TickToExpire = 23;
+		}
+		break;
+	case PHY_POWER_DOWN:
+		if (ax772_data->TickToExpire == 23) {
+			ax88772_save_bmcr_anar(dev);
+			/* Set Phy Power Down */
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET, AX_SWRESET_IPPD,
+					  0, 0, NULL);
+			--ax772_data->TickToExpire;
+		} else if (--ax772_data->TickToExpire == 0) {
+			/* Set Phy Power Up */
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_IPRL, 0, 0, NULL);
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_IPPD | AX_SWRESET_IPRL, 0, 0, NULL);
+			msleep(10);
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_IPRL, 0, 0, NULL);
+			msleep(60);
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_CLEAR, 0, 0, NULL);
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+				AX_SWRESET_IPRL, 0, 0, NULL);
+
+			if (ax772_data->presvd_phy_advertise && ax772_data->presvd_phy_bmcr) {
+				ax88772_restore_bmcr_anar(dev);
+				
+			} else {
+				ax8817x_mdio_write_le(dev->net, dev->mii.phy_id,
+						      MII_ADVERTISE,
+						      ADVERTISE_ALL | ADVERTISE_CSMA |
+						      ADVERTISE_PAUSE_CAP);
+				mii_nway_restart(&dev->mii);
+			}
+
+			ax772_data->Event = PHY_POWER_UP;
+			ax772_data->TickToExpire = 47;
+		}
+		break;
+	case PHY_POWER_UP:
+		if (--ax772_data->TickToExpire == 0) {
+			ax772_data->Event = PHY_POWER_DOWN;
+			ax772_data->TickToExpire = 23;
+		}
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void ax88772a_link_reset(void *data)
+{
+	struct usbnet *dev = (struct usbnet *)data;
+	struct ax88772a_data *ax772a_data = (struct ax88772a_data *)dev->priv;
+#else
+static void ax88772a_link_reset(struct work_struct *work)
+{
+	struct ax88772a_data *ax772a_data = container_of(work,
+							 struct ax88772a_data,
+							 check_link);
+	struct usbnet *dev = ax772a_data->dev;
+#endif
+	int powsave = (ax772a_data->EepromData >> 14);
+	u16 phy_reg;
+
+	if (ax772a_data->Event == AX_SET_RX_CFG) {
+		u16 bmcr;
+		u16 mode;
+
+		ax772a_data->Event = AX_NOP;
+
+		mode = AX88772_MEDIUM_DEFAULT;
+
+		bmcr = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id,
+					    MII_BMCR);
+		if (!(bmcr & BMCR_FULLDPLX))
+			mode &= ~AX88772_MEDIUM_FULL_DUPLEX;
+		if (!(bmcr & BMCR_SPEED100))
+			mode &= ~AX88772_MEDIUM_100MB;
+
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode,
+				  0, 0, NULL);
+
+		if (ax772a_data->presvd_phy_advertise && ax772a_data->presvd_phy_bmcr) {
+
+			/* Restore Advertisement control reg */
+			ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+					      ax772a_data->presvd_phy_advertise);
+			/* Restore BMCR */
+			ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR,
+					      ax772a_data->presvd_phy_bmcr);
+			ax772a_data->presvd_phy_advertise = 0;
+			ax772a_data->presvd_phy_bmcr = 0;
+		}
+
+		return;
+	}
+
+	switch (ax772a_data->Event) {
+	case WAIT_AUTONEG_COMPLETE:
+		if (jiffies > (ax772a_data->autoneg_start + 5 * HZ)) {
+			ax772a_data->Event = CHK_CABLE_EXIST;
+			ax772a_data->TickToExpire = 14;
+		}
+		break;
+	case CHK_CABLE_EXIST:
+		phy_reg = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
+		if ((phy_reg != 0x8012) && (phy_reg != 0x8013)) {
+			ax8817x_mdio_write_le(dev->net,
+				dev->mii.phy_id, 0x16, 0x4040);
+			mii_nway_restart(&dev->mii);
+			ax772a_data->Event = CHK_CABLE_STATUS;
+			ax772a_data->TickToExpire = 31;
+		} else if (--ax772a_data->TickToExpire == 0) {
+			mii_nway_restart(&dev->mii);
+			ax772a_data->Event = CHK_CABLE_EXIST_AGAIN;
+			if (powsave == 0x03) {
+				ax772a_data->TickToExpire = 47;
+			} else if (powsave == 0x01) {
+				ax772a_data->DlyIndex = (u8)(jiffies % 6);
+				ax772a_data->DlySel = 0;
+				ax772a_data->TickToExpire =
+			chkcntsel[ax772a_data->DlyIndex][ax772a_data->DlySel];
+			}
+		}
+		break;
+	case CHK_CABLE_EXIST_AGAIN:
+		/* if cable disconnected */
+		phy_reg = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
+		if ((phy_reg != 0x8012) && (phy_reg != 0x8013)) {
+			mii_nway_restart(&dev->mii);
+			ax772a_data->Event = CHK_CABLE_STATUS;
+			ax772a_data->TickToExpire = 31;
+		} else if (--ax772a_data->TickToExpire == 0) {
+			if (!ax772a_data->presvd_phy_advertise && !ax772a_data->presvd_phy_bmcr) {
+				/* Preserve BMCR for restoring */
+				ax772a_data->presvd_phy_bmcr =
+					ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_BMCR);
+
+				/* Preserve Advertisement control reg for restoring */
+				ax772a_data->presvd_phy_advertise =
+					ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+			}
+
+
+			/* Power down PHY */
+			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					  AX_SWRESET_IPPD,
+					  0, 0, NULL);
+			ax772a_data->Event = PHY_POWER_DOWN;
+			if (powsave == 0x03)
+				ax772a_data->TickToExpire = 23;
+			else if (powsave == 0x01)
+				ax772a_data->TickToExpire = 31;
+		}
+		break;
+	case PHY_POWER_DOWN:
+		if (--ax772a_data->TickToExpire == 0)
+			ax772a_data->Event = PHY_POWER_UP;
+		break;
+	case CHK_CABLE_STATUS:
+		if (--ax772a_data->TickToExpire == 0) {
+			ax8817x_mdio_write_le(dev->net,
+					dev->mii.phy_id, 0x16, 0x4040);
+			mii_nway_restart(&dev->mii);
+			ax772a_data->Event = CHK_CABLE_EXIST_AGAIN;
+			if (powsave == 0x03) {
+				ax772a_data->TickToExpire = 47;
+			} else if (powsave == 0x01) {
+				ax772a_data->DlyIndex = (u8)(jiffies % 6);
+				ax772a_data->DlySel = 0;
+				ax772a_data->TickToExpire =
+			chkcntsel[ax772a_data->DlyIndex][ax772a_data->DlySel];
+			}
+		}
+		break;
+	case PHY_POWER_UP:
+
+		if (!ax772a_data->presvd_phy_advertise && !ax772a_data->presvd_phy_bmcr) {
+			/* Preserve BMCR for restoring */
+			ax772a_data->presvd_phy_bmcr =
+				ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_BMCR);
+
+			/* Preserve Advertisement control reg for restoring */
+			ax772a_data->presvd_phy_advertise =
+				ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+		}
+
+		ax88772a_phy_powerup(dev);
+
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+			ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
+
+		mii_nway_restart(&dev->mii);
+
+		ax772a_data->Event = CHK_CABLE_EXIST_AGAIN;
+
+		if (powsave == 0x03) {
+			ax772a_data->TickToExpire = 47;
+		} else if (powsave == 0x01) {
+			if (++ax772a_data->DlySel >= 3) {
+				ax772a_data->DlyIndex = (u8)(jiffies % 6);
+				ax772a_data->DlySel = 0;
+			}
+			ax772a_data->TickToExpire =
+			chkcntsel[ax772a_data->DlyIndex][ax772a_data->DlySel];
+		}
+		break;
+	default:
+		break;
+	}
+
+	return;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void ax88772b_link_reset(void *data)
+{
+	struct usbnet *dev = (struct usbnet *)data;
+	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
+#else
+static void ax88772b_link_reset(struct work_struct *work)
+{
+	struct ax88772b_data *ax772b_data = container_of(work,
+							 struct ax88772b_data,
+							 check_link);
+	struct usbnet *dev = ax772b_data->dev;
+#endif
+
+	switch (ax772b_data->Event) {
+
+	case AX_SET_RX_CFG:
+	{
+		u16 bmcr = ax8817x_mdio_read_le(dev->net,
+					dev->mii.phy_id, MII_BMCR);
+		u16 mode = AX88772_MEDIUM_DEFAULT;
+
+		if (!(bmcr & BMCR_FULLDPLX))
+			mode &= ~AX88772_MEDIUM_FULL_DUPLEX;
+		if (!(bmcr & BMCR_SPEED100))
+			mode &= ~AX88772_MEDIUM_100MB;
+
+		ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode,
+				  0, 0, NULL);
+		break;
+	}
+	case PHY_POWER_UP:
+	{
+		u16 tmp16;
+
+		if (!ax772b_data->presvd_phy_advertise && !ax772b_data->presvd_phy_bmcr) {
+			/* Preserve BMCR for restoring */
+			ax772b_data->presvd_phy_bmcr =
+				ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_BMCR);
+
+			/* Preserve Advertisement control reg for restoring */
+			ax772b_data->presvd_phy_advertise =
+				ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
+		}
+
+		ax88772a_phy_powerup(dev);
+		tmp16 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, 0x12,
+				((tmp16 & 0xFF9F) | 0x0040));
+
+		/* Restore Advertisement control reg */
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
+				      ax772b_data->presvd_phy_advertise);
+		/* Restore BMCR */
+		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR,
+				      ax772b_data->presvd_phy_bmcr);
+		ax772b_data->presvd_phy_advertise = 0;
+		ax772b_data->presvd_phy_bmcr = 0;
+
+		break;
+	}
+
+	case AX_CHK_AUTODETACH:
+	{
+		int ret;
+		ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
+					AX_SWRESET_IPRL |
+					(ax772b_data->psc & 0x7FFF),
+					0, 0, NULL);
+		if (ret < 0) {
+			deverr(dev, "Failed to configure PHY power saving: %d",
+			       ret);
+		}
+
+		break;
+	}
+	default:
+		break;
+	}
+
+	ax772b_data->Event = AX_NOP;
+	
+	return;
+}
+
+static int ax88178_set_media(struct usbnet *dev)
+{
+	int	ret;
+	struct ax88178_data *ax178dataptr = (struct ax88178_data *)dev->priv;
+	int media;
+
+	media = ax88178_media_check(dev, ax178dataptr);
+	if (media < 0)
+		return media;
+
+	ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, media, 0,
+				0, NULL);
+	if (ret < 0) {
+		deverr(dev, "write mode medium reg failed: %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ax88178_link_reset(struct usbnet *dev)
+{
+	return ax88178_set_media(dev);
+}
+
+static int ax_suspend(struct usb_interface *intf,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+			pm_message_t message)
+#else
+			u32 message)
+#endif
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+
+	return data->suspend(intf, message);
+}
+
+static int ax_resume(struct usb_interface *intf)
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
+
+	return data->resume(intf);
+}
+
+static const struct driver_info ax88178_info = {
+	.description = "ASIX AX88178 USB 2.0 Ethernet",
+	.bind	= ax88178_bind,
+	.unbind = ax88178_unbind,
+	.status = ax88178_status,
+	.link_reset = ax88178_link_reset,
+	.reset	= ax88178_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
+#endif
+	.rx_fixup = ax88772_rx_fixup,
+	.tx_fixup = ax88772_tx_fixup,
+};
+
+static const struct driver_info belkin178_info = {
+	.description = "Belkin Gigabit USB 2.0 Network Adapter",
+	.bind	= ax88178_bind,
+	.unbind	= ax88178_unbind,
+	.status	= ax88178_status,
+	.link_reset = ax88178_link_reset,
+	.reset	= ax88178_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
+#endif
+	.rx_fixup = ax88772_rx_fixup,
+	.tx_fixup = ax88772_tx_fixup,
+};
+
+static const struct driver_info ax8817x_info = {
+	.description = "ASIX AX8817x USB 2.0 Ethernet",
+	.bind	= ax8817x_bind,
+	.status	= ax8817x_status,
+	.link_reset = ax88172_link_reset,
+	.reset	= ax88172_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER,
+#endif
+};
+
+static const struct driver_info dlink_dub_e100_info = {
+	.description = "DLink DUB-E100 USB Ethernet",
+	.bind	= ax8817x_bind,
+	.status	= ax8817x_status,
+	.link_reset = ax88172_link_reset,
+	.reset	= ax88172_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER,
+#endif
+};
+
+static const struct driver_info netgear_fa120_info = {
+	.description = "Netgear FA-120 USB Ethernet",
+	.bind	= ax8817x_bind,
+	.status = ax8817x_status,
+	.link_reset = ax88172_link_reset,
+	.reset	= ax88172_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER,
+#endif
+};
+
+static const struct driver_info hawking_uf200_info = {
+	.description = "Hawking UF200 USB Ethernet",
+	.bind	= ax8817x_bind,
+	.status = ax8817x_status,
+	.link_reset = ax88172_link_reset,
+	.reset	= ax88172_link_reset,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER,
+#endif
+};
+
+static const struct driver_info ax88772_info = {
+	.description = "ASIX AX88772 USB 2.0 Ethernet",
+	.bind	= ax88772_bind,
+	.unbind = ax88772_unbind,
+	.status = ax88772_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
+#endif
+	.rx_fixup = ax88772_rx_fixup,
+	.tx_fixup = ax88772_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info dlink_dub_e100b_info = {
+	.description = "D-Link DUB-E100 USB 2.0 Fast Ethernet Adapter",
+	.bind	= ax88772_bind,
+	.unbind = ax88772_unbind,
+	.status = ax88772_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
+#endif
+	.rx_fixup = ax88772_rx_fixup,
+	.tx_fixup = ax88772_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info dlink_dub_e100_772b_info = {
+	.description = "D-Link DUB-E100 USB 2.0 Fast Ethernet Adapter",
+	.bind	= ax88772b_bind,
+	.unbind = ax88772b_unbind,
+	.status = ax88772b_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT,
+#endif
+	.rx_fixup = ax88772b_rx_fixup,
+	.tx_fixup = ax88772b_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info dlink_dub_e100_772c_info = {
+	.description = "D-Link DUB-E100 USB 2.0 Fast Ethernet Adapter",
+	.bind	= ax88772b_bind,
+	.unbind = ax88772b_unbind,
+	.status = ax88772b_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT,
+#endif
+	.rx_fixup = ax88772b_rx_fixup,
+	.tx_fixup = ax88772b_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info ax88772a_info = {
+	.description = "ASIX AX88772A USB 2.0 Ethernet",
+	.bind	= ax88772a_bind,
+	.unbind = ax88772a_unbind,
+	.status = ax88772a_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
+#endif
+	.rx_fixup = ax88772_rx_fixup,
+	.tx_fixup = ax88772_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info ax88772b_info = {
+	.description = "ASIX AX88772B USB 2.0 Ethernet",
+	.bind	= ax88772b_bind,
+	.unbind = ax88772b_unbind,
+	.status = ax88772b_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT,
+#endif
+	.rx_fixup = ax88772b_rx_fixup,
+	.tx_fixup = ax88772b_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct driver_info ax88772c_info = {
+	.description = "ASIX AX88772C USB 2.0 Ethernet",
+	.bind	= ax88772b_bind,
+	.unbind = ax88772b_unbind,
+	.status = ax88772c_status,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	.stop	= ax88772b_stop,
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT | FLAG_AVOID_UNLINK_URBS,
+#else
+	.flags	= FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT,
+#endif
+	.rx_fixup = ax88772b_rx_fixup,
+	.tx_fixup = ax88772b_tx_fixup,
+	.reset	= ax88772b_reset,
+};
+
+static const struct usb_device_id products[] = {
+{
+	/* 88178 */
+	USB_DEVICE(0x0b95, 0x1780),
+	.driver_info =	(unsigned long) &ax88178_info,
+}, {
+	/* 88178 for billianton linksys */
+	USB_DEVICE(0x077b, 0x2226),
+	.driver_info =	(unsigned long) &ax88178_info,
+}, {
+	/* ABOCOM for linksys */
+	USB_DEVICE(0x1737, 0x0039),
+	.driver_info =	(unsigned long) &ax88178_info,
+}, {
+	/* ABOCOM  for pci */
+	USB_DEVICE(0x14ea, 0xab11),
+	.driver_info =	(unsigned long) &ax88178_info,
+}, {
+	/* Belkin */
+	USB_DEVICE(0x050d, 0x5055),
+	.driver_info =	(unsigned long) &belkin178_info,
+}, {
+	/* Linksys USB200M */
+	USB_DEVICE(0x077b, 0x2226),
+	.driver_info =	(unsigned long) &ax8817x_info,
+}, {
+	/* Netgear FA120 */
+	USB_DEVICE(0x0846, 0x1040),
+	.driver_info =  (unsigned long) &netgear_fa120_info,
+}, {
+	/* DLink DUB-E100 */
+	USB_DEVICE(0x2001, 0x1a00),
+	.driver_info =  (unsigned long) &dlink_dub_e100_info,
+}, {
+	/* DLink DUB-E100B */
+	USB_DEVICE(0x2001, 0x3c05),
+	.driver_info =  (unsigned long) &dlink_dub_e100b_info,
+}, {
+	/* DLink DUB-E100B */
+	USB_DEVICE(0x07d1, 0x3c05),
+	.driver_info =  (unsigned long) &dlink_dub_e100b_info,
+}, {
+	/* DLink DUB-E100 (AX88772B)*/
+	USB_DEVICE_VER(0x2001, 0x1a02, 0, 1),
+	.driver_info =  (unsigned long) &dlink_dub_e100_772b_info,
+}, {
+	/* DLink DUB-E100 (AX88772C)*/
+	USB_DEVICE_VER(0x2001, 0x1a02, 0, 2),
+	.driver_info =  (unsigned long) &dlink_dub_e100_772c_info,
+}, {
+	/* Intellinet, ST Lab USB Ethernet */
+	USB_DEVICE(0x0b95, 0x1720),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* Hawking UF200, TrendNet TU2-ET100 */
+	USB_DEVICE(0x07b8, 0x420a),
+	.driver_info =  (unsigned long) &hawking_uf200_info,
+}, {
+	/* Billionton Systems, USB2AR */
+	USB_DEVICE(0x08dd, 0x90ff),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* ATEN UC210T */
+	USB_DEVICE(0x0557, 0x2009),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* Buffalo LUA-U2-KTX */
+	USB_DEVICE(0x0411, 0x003d),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* Sitecom LN-029 "USB 2.0 10/100 Ethernet adapter" */
+	USB_DEVICE(0x6189, 0x182d),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* corega FEther USB2-TX */
+	USB_DEVICE(0x07aa, 0x0017),
+	.driver_info =  (unsigned long) &ax8817x_info,
+}, {
+	/* Surecom EP-1427X-2 */
+	USB_DEVICE(0x1189, 0x0893),
+	.driver_info = (unsigned long) &ax8817x_info,
+}, {
+	/* goodway corp usb gwusb2e */
+	USB_DEVICE(0x1631, 0x6200),
+	.driver_info = (unsigned long) &ax8817x_info,
+}, {
+	/* ASIX AX88772 10/100 */
+	USB_DEVICE(0x0b95, 0x7720),
+	.driver_info = (unsigned long) &ax88772_info,
+}, {
+	/* ASIX AX88772 10/100 */
+	USB_DEVICE(0x125E, 0x180D),
+	.driver_info = (unsigned long) &ax88772_info,
+}, {
+	/* ASIX AX88772A 10/100 */
+	USB_DEVICE(0x0b95, 0x772A),
+	.driver_info = (unsigned long) &ax88772a_info,
+}, {
+	/* ASIX AX88772A 10/100 */
+	USB_DEVICE(0x0db0, 0xA877),
+	.driver_info = (unsigned long) &ax88772a_info,
+}, {
+	/* ASIX AX88772A 10/100 */
+	USB_DEVICE(0x0421, 0x772A),
+	.driver_info = (unsigned long) &ax88772a_info,
+}, {
+	/* Linksys 200M */
+	 USB_DEVICE(0x13B1, 0x0018),
+	.driver_info = (unsigned long) &ax88772a_info,
+}, {
+	USB_DEVICE(0x05ac, 0x1402),
+	.driver_info = (unsigned long) &ax88772a_info,
+}, {
+	/* ASIX AX88772B 10/100 */
+	USB_DEVICE_VER(0x0b95, 0x772B, 0, 1),
+	.driver_info = (unsigned long) &ax88772b_info,
+}, {
+	/* Asus AX88772B 10/100 */
+	USB_DEVICE_VER(0x0b95, 0x7e2b, 0, 1),
+	.driver_info = (unsigned long) &ax88772b_info,
+}, {
+	/* Lenovo AX88772B 10/100 */
+	USB_DEVICE_VER(0x17ef, 0x7203, 0, 1),
+	.driver_info = (unsigned long) &ax88772b_info,
+},{
+	/* ASIX AX88772B ver.2 10/100 */
+	USB_DEVICE_VER(0x0b95, 0x772B, 0, 2),
+	.driver_info = (unsigned long) &ax88772c_info,
+},
+	{ },		/* END */
+};
+MODULE_DEVICE_TABLE(usb, products);
+
+static struct usb_driver asix_driver = {
+	/* .owner =	THIS_MODULE, */
+	.name =		"asix",
+	.id_table =	products,
+	.probe =	axusbnet_probe,
+	.suspend =	ax_suspend,
+	.resume =	ax_resume,
+	.disconnect =	axusbnet_disconnect,
+};
+
+static int __init asix_init(void)
+{
+	return usb_register(&asix_driver);
+}
+module_init(asix_init);
+
+static void __exit asix_exit(void)
+{
+	usb_deregister(&asix_driver);
+}
+module_exit(asix_exit);
+
+MODULE_AUTHOR("David Hollis");
+MODULE_DESCRIPTION("ASIX AX8817X based USB 2.0 Ethernet Devices");
+MODULE_LICENSE("GPL");
+
diff --no-dereference -Nru kernel-22/kernel/drivers/net/usb/axusbnet.c kernel-central/kernel/drivers/net/usb/axusbnet.c
--- kernel-22/kernel/drivers/net/usb/axusbnet.c	1970-01-01 03:00:00.000000000 +0300
+++ kernel-central/kernel/drivers/net/usb/axusbnet.c	2016-11-23 05:02:31.000000000 +0200
@@ -0,0 +1,1460 @@
+/*
+ * USB Network driver infrastructure
+ * Copyright (C) 2000-2005 by David Brownell
+ * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This is a generic "USB networking" framework that works with several
+ * kinds of full and high speed networking devices:  host-to-host cables,
+ * smart usb peripherals, and actual Ethernet adapters.
+ *
+ * These devices usually differ in terms of control protocols (if they
+ * even have one!) and sometimes they define new framing to wrap or batch
+ * Ethernet packets.  Otherwise, they talk to USB pretty much the same,
+ * so interface (un)binding, endpoint I/O queues, fault handling, and other
+ * issues can usefully be addressed by this framework.
+ */
+
+/* error path messages, extra info */
+#define	DEBUG
+/* more; success messages */
+/* #define	VERBOSE	*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ctype.h>
+#include <linux/ethtool.h>
+#include <linux/workqueue.h>
+#include <linux/mii.h>
+#include <linux/usb.h>
+/*#include <linux/usb/usbnet.h>*/
+
+#include "asix.h"
+#include "axusbnet.h"
+
+#define DRIVER_VERSION		"22-Aug-2005"
+
+static void axusbnet_unlink_rx_urbs(struct usbnet *);
+
+static void
+ax8817x_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,
+				    u16 size, void *data);
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * Nineteen USB 1.1 max size bulk transactions per frame (ms), max.
+ * Several dozen bytes of IPv4 data can fit in two such transactions.
+ * One maximum size Ethernet packet takes twenty four of them.
+ * For high speed, each frame comfortably fits almost 36 max size
+ * Ethernet packets (so queues should be bigger).
+ *
+ * REVISIT qlens should be members of 'struct usbnet'; the goal is to
+ * let the USB host controller be busy for 5msec or more before an irq
+ * is required, under load.  Jumbograms change the equation.
+ */
+#define RX_MAX_QUEUE_MEMORY (60 * 1518)
+#define	RX_QLEN(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? \
+			(RX_MAX_QUEUE_MEMORY/(dev)->rx_urb_size) : 4)
+#define	TX_QLEN(dev) (((dev)->udev->speed == USB_SPEED_HIGH) ? \
+			(RX_MAX_QUEUE_MEMORY/(dev)->hard_mtu) : 4)
+
+/* reawaken network queue this soon after stopping; else watchdog barks */
+/* #define TX_TIMEOUT_JIFFIES	(5 * HZ) */
+#define TX_TIMEOUT_JIFFIES	(30 * HZ)
+
+/* throttle rx/tx briefly after some faults, so khubd might disconnect() */
+/* us (it polls at HZ/4 usually) before we report too many false errors. */
+#define THROTTLE_JIFFIES	(HZ / 8)
+
+/* between wakeups */
+#define UNLINK_TIMEOUT_MS	3
+
+/*-------------------------------------------------------------------------*/
+
+static const char driver_name[] = "axusbnet";
+
+/* use ethtool to change the level for any given device */
+static int msg_level = -1;
+module_param(msg_level, int, 0);
+MODULE_PARM_DESC(msg_level, "Override default message level");
+
+/*-------------------------------------------------------------------------*/
+
+/* handles CDC Ethernet and many other network "bulk data" interfaces */
+static
+int axusbnet_get_endpoints(struct usbnet *dev, struct usb_interface *intf)
+{
+	int				tmp;
+	struct usb_host_interface	*alt = NULL;
+	struct usb_host_endpoint	*in = NULL, *out = NULL;
+	struct usb_host_endpoint	*status = NULL;
+
+	for (tmp = 0; tmp < intf->num_altsetting; tmp++) {
+		unsigned	ep;
+
+		in = out = status = NULL;
+		alt = intf->altsetting + tmp;
+
+		/* take the first altsetting with in-bulk + out-bulk;
+		 * remember any status endpoint, just in case;
+		 * ignore other endpoints and altsetttings.
+		 */
+		for (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {
+			struct usb_host_endpoint	*e;
+			int				intr = 0;
+
+			e = alt->endpoint + ep;
+			switch (e->desc.bmAttributes) {
+			case USB_ENDPOINT_XFER_INT:
+				if (!(e->desc.bEndpointAddress & USB_DIR_IN))
+					continue;
+				intr = 1;
+				/* FALLTHROUGH */
+			case USB_ENDPOINT_XFER_BULK:
+				break;
+			default:
+				continue;
+			}
+			if (e->desc.bEndpointAddress & USB_DIR_IN) {
+				if (!intr && !in)
+					in = e;
+				else if (intr && !status)
+					status = e;
+			} else {
+				if (!out)
+					out = e;
+			}
+		}
+		if (in && out)
+			break;
+	}
+	if (!alt || !in || !out)
+		return -EINVAL;
+
+	if (alt->desc.bAlternateSetting != 0
+			|| !(dev->driver_info->flags & FLAG_NO_SETINT)) {
+		tmp = usb_set_interface(dev->udev, alt->desc.bInterfaceNumber,
+				alt->desc.bAlternateSetting);
+		if (tmp < 0)
+			return tmp;
+	}
+
+	dev->in = usb_rcvbulkpipe(dev->udev,
+			in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
+	dev->out = usb_sndbulkpipe(dev->udev,
+			out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
+	dev->status = status;
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void intr_complete(struct urb *urb, struct pt_regs *regs);
+#else
+static void intr_complete(struct urb *urb);
+#endif
+
+static int init_status(struct usbnet *dev, struct usb_interface *intf)
+{
+	char		*buf = NULL;
+	unsigned	pipe = 0;
+	unsigned	maxp;
+	unsigned	period;
+
+	if (!dev->driver_info->status)
+		return 0;
+
+	pipe = usb_rcvintpipe(dev->udev,
+			dev->status->desc.bEndpointAddress
+				& USB_ENDPOINT_NUMBER_MASK);
+	maxp = usb_maxpacket(dev->udev, pipe, 0);
+
+	/* avoid 1 msec chatter:  min 8 msec poll rate */
+	period = max((int) dev->status->desc.bInterval,
+		(dev->udev->speed == USB_SPEED_HIGH) ? 7 : 3);
+
+	buf = kmalloc(maxp, GFP_KERNEL);
+	if (buf) {
+		dev->interrupt = usb_alloc_urb(0, GFP_KERNEL);
+		if (!dev->interrupt) {
+			kfree(buf);
+			return -ENOMEM;
+		} else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+			dev->interrupt->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+			usb_fill_int_urb(dev->interrupt, dev->udev, pipe,
+				buf, maxp, intr_complete, dev, period);
+			devdbg(dev,
+			       "status ep%din, %d bytes period %d",
+			       usb_pipeendpoint(pipe), maxp, period);
+		}
+	}
+	return 0;
+}
+
+/* Passes this packet up the stack, updating its accounting.
+ * Some link protocols batch packets, so their rx_fixup paths
+ * can return clones as well as just modify the original skb.
+ */
+static
+void axusbnet_skb_return(struct usbnet *dev, struct sk_buff *skb)
+{
+	int	status;
+
+	skb->dev = dev->net;
+	skb->protocol = eth_type_trans(skb, dev->net);
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += skb->len;
+
+	if (netif_msg_rx_status(dev))
+		devdbg(dev, "< rx, len %zu, type 0x%x",
+		       skb->len + sizeof(struct ethhdr), skb->protocol);
+	memset(skb->cb, 0, sizeof(struct skb_data));
+	status = netif_rx(skb);
+	if (status != NET_RX_SUCCESS && netif_msg_rx_err(dev))
+		devdbg(dev, "netif_rx status %d", status);
+}
+
+/*-------------------------------------------------------------------------
+ *
+ * Network Device Driver (peer link to "Host Device", from USB host)
+ *
+ *-------------------------------------------------------------------------*/
+
+static
+int axusbnet_change_mtu(struct net_device *net, int new_mtu)
+{
+	struct usbnet	*dev = netdev_priv(net);
+	int		ll_mtu = new_mtu + net->hard_header_len;
+	int		old_hard_mtu = dev->hard_mtu;
+	int		old_rx_urb_size = dev->rx_urb_size;
+
+	if (new_mtu <= 0)
+		return -EINVAL;
+	/* no second zero-length packet read wanted after mtu-sized packets */
+	if ((ll_mtu % dev->maxpacket) == 0)
+		return -EDOM;
+	net->mtu = new_mtu;
+
+	dev->hard_mtu = net->mtu + net->hard_header_len;
+	if (dev->rx_urb_size == old_hard_mtu) {
+		dev->rx_urb_size = dev->hard_mtu;
+		if (dev->rx_urb_size > old_rx_urb_size)
+			axusbnet_unlink_rx_urbs(dev);
+	}
+
+	return 0;
+}
+
+static struct net_device_stats *axusbnet_get_stats(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+	return &dev->stats;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* some LK 2.4 HCDs oopsed if we freed or resubmitted urbs from
+ * completion callbacks.  2.5 should have fixed those bugs...
+ */
+
+static enum skb_state defer_bh(struct usbnet *dev, struct sk_buff *skb,
+                struct sk_buff_head *list, enum skb_state state)
+{
+        unsigned long           flags;
+        enum skb_state          old_state;
+        struct skb_data *entry = (struct skb_data *) skb->cb;
+
+        spin_lock_irqsave(&list->lock, flags);
+        old_state = entry->state;
+        entry->state = state;
+        __skb_unlink(skb, list);
+
+        /* defer_bh() is never called with list == &dev->done.
+         * spin_lock_nested() tells lockdep that it is OK to take
+         * dev->done.lock here with list->lock held.
+         */
+        spin_lock_nested(&dev->done.lock, SINGLE_DEPTH_NESTING);
+
+        __skb_queue_tail(&dev->done, skb);
+        if (dev->done.qlen == 1)
+                tasklet_schedule(&dev->bh);
+
+        spin_unlock(&dev->done.lock);
+        spin_unlock_irqrestore(&list->lock, flags);
+	
+        return old_state;
+}
+
+/* some work can't be done in tasklets, so we use keventd
+ *
+ * NOTE:  annoying asymmetry:  if it's active, schedule_work() fails,
+ * but tasklet_schedule() doesn't.  hope the failure is rare.
+ */
+static
+void axusbnet_defer_kevent(struct usbnet *dev, int work)
+{
+	set_bit(work, &dev->flags);
+	if (!schedule_work(&dev->kevent))
+		deverr(dev, "kevent %d may have been dropped", work);
+	else
+		devdbg(dev, "kevent %d scheduled", work);
+}
+
+/*-------------------------------------------------------------------------*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void rx_complete(struct urb *urb, struct pt_regs *regs);
+#else
+static void rx_complete(struct urb *urb);
+#endif
+
+static void rx_submit(struct usbnet *dev, struct urb *urb, gfp_t flags)
+{
+	struct sk_buff		*skb;
+	struct skb_data		*entry;
+	int			retval = 0;
+	unsigned long		lockflags;
+	size_t			size = dev->rx_urb_size;
+	struct driver_info	*info = dev->driver_info;
+	u8			align;
+
+	/* prevent rx skb allocation when error ratio is high */
+	if (test_bit(EVENT_RX_KILL, &dev->flags)) {
+		    usb_free_urb(urb);
+		    return;
+	}
+
+#if (AX_FORCE_BUFF_ALIGN)
+	align = 0;
+#else
+	if (!(info->flags & FLAG_HW_IP_ALIGNMENT))
+		align = NET_IP_ALIGN;
+	else
+		align = 0;
+#endif
+	skb = alloc_skb(size + align, flags);
+	if (skb == NULL) {
+
+		if (netif_msg_rx_err(dev))
+			devdbg(dev, "no rx skb");
+
+		if ((dev->rx_urb_size > 2048) && dev->rx_size) {
+			dev->rx_size--;
+			dev->rx_urb_size =
+				AX88772B_BULKIN_SIZE[dev->rx_size].size;
+
+			ax8817x_write_cmd_async(dev, 0x2A,
+				AX88772B_BULKIN_SIZE[dev->rx_size].byte_cnt,
+				AX88772B_BULKIN_SIZE[dev->rx_size].threshold,
+				0, NULL);
+		}
+
+		if (!(dev->flags & EVENT_RX_MEMORY))
+			axusbnet_defer_kevent(dev, EVENT_RX_MEMORY);
+		usb_free_urb(urb);
+		return;
+	}
+
+	if (align)
+		skb_reserve(skb, NET_IP_ALIGN);
+
+	entry = (struct skb_data *) skb->cb;
+	entry->urb = urb;
+	entry->dev = dev;
+	entry->state = rx_start;
+	entry->length = 0;
+
+	usb_fill_bulk_urb(urb, dev->udev, dev->in, skb->data,
+			  size, rx_complete, skb);
+
+	spin_lock_irqsave(&dev->rxq.lock, lockflags);
+
+	if (netif_running(dev->net)
+			&& netif_device_present(dev->net)
+			&& !test_bit(EVENT_RX_HALT, &dev->flags)) {
+		switch (retval = usb_submit_urb(urb, GFP_ATOMIC)) {
+		case -EPIPE:
+			axusbnet_defer_kevent(dev, EVENT_RX_HALT);
+			break;
+		case -ENOMEM:
+			axusbnet_defer_kevent(dev, EVENT_RX_MEMORY);
+			break;
+		case -ENODEV:
+			if (netif_msg_ifdown(dev))
+				devdbg(dev, "device gone");
+			netif_device_detach(dev->net);
+			break;
+		default:
+			if (netif_msg_rx_err(dev))
+				devdbg(dev, "rx submit, %d", retval);
+			tasklet_schedule(&dev->bh);
+			break;
+		case 0:
+			__skb_queue_tail(&dev->rxq, skb);
+		}
+	} else {
+		if (netif_msg_ifdown(dev))
+			devdbg(dev, "rx: stopped");
+		retval = -ENOLINK;
+	}
+	spin_unlock_irqrestore(&dev->rxq.lock, lockflags);
+	if (retval) {
+		dev_kfree_skb_any(skb);
+		usb_free_urb(urb);
+	}
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+static inline void rx_process(struct usbnet *dev, struct sk_buff *skb)
+{
+	if (dev->driver_info->rx_fixup
+			&& !dev->driver_info->rx_fixup(dev, skb))
+		goto error;
+	/* else network stack removes extra byte if we forced a short packet */
+
+	if (skb->len)
+		axusbnet_skb_return(dev, skb);
+	else {
+		if (netif_msg_rx_err(dev))
+			devdbg(dev, "drop");
+error:
+		dev->stats.rx_errors++;
+		skb_queue_tail(&dev->done, skb);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void rx_complete(struct urb *urb, struct pt_regs *regs)
+#else
+static void rx_complete(struct urb *urb)
+#endif
+{
+	struct sk_buff		*skb = (struct sk_buff *) urb->context;
+	struct skb_data		*entry = (struct skb_data *) skb->cb;
+	struct usbnet		*dev = entry->dev;
+	int			urb_status = urb->status;
+	enum skb_state          state;
+
+	skb_put(skb, urb->actual_length);
+	state = rx_done;
+	entry->urb = NULL;
+
+	switch (urb_status) {
+	/* success */
+	case 0:
+		if (skb->len < dev->net->hard_header_len) {
+			entry->state = rx_cleanup;
+			dev->stats.rx_errors++;
+			dev->stats.rx_length_errors++;
+			if (netif_msg_rx_err(dev))
+				devdbg(dev, "rx length %d", skb->len);
+		}
+		break;
+
+	/* stalls need manual reset. this is rare ... except that
+	 * when going through USB 2.0 TTs, unplug appears this way.
+	 * we avoid the highspeed version of the ETIMEDOUT/EILSEQ
+	 * storm, recovering as needed.
+	 */
+	case -EPIPE:
+		dev->stats.rx_errors++;
+		axusbnet_defer_kevent(dev, EVENT_RX_HALT);
+		/* FALLTHROUGH */
+
+	/* software-driven interface shutdown */
+	case -ECONNRESET:		/* async unlink */
+	case -ESHUTDOWN:		/* hardware gone */
+		if (netif_msg_ifdown(dev))
+			devdbg(dev, "rx shutdown, code %d", urb_status);
+		goto block;
+
+	/* we get controller i/o faults during khubd disconnect() delays.
+	 * throttle down resubmits, to avoid log floods; just temporarily,
+	 * so we still recover when the fault isn't a khubd delay.
+	 */
+	case -EPROTO:
+	case -ETIME:
+	case -EILSEQ:
+		dev->stats.rx_errors++;
+		if (!timer_pending(&dev->delay)) {
+			mod_timer(&dev->delay, jiffies + THROTTLE_JIFFIES);
+			if (netif_msg_link(dev))
+				devdbg(dev, "rx throttle %d", urb_status);
+		}
+block:
+		state = rx_cleanup;
+		entry->urb = urb;
+		urb = NULL;
+		break;
+
+	/* data overrun ... flush fifo? */
+	case -EOVERFLOW:
+		dev->stats.rx_over_errors++;
+		/* FALLTHROUGH */
+
+	default:
+		state = rx_cleanup;
+		dev->stats.rx_errors++;
+		if (netif_msg_rx_err(dev))
+			devdbg(dev, "rx status %d", urb_status);
+		break;
+	}
+
+	/* stop rx if packet error rate is high */
+        if (++dev->pkt_cnt > 30) {
+                dev->pkt_cnt = 0;
+                dev->pkt_err = 0;
+        } else {
+                if (state == rx_cleanup)
+                        dev->pkt_err++;
+                if (dev->pkt_err > 20)
+                        set_bit(EVENT_RX_KILL, &dev->flags);
+        }
+
+	state = defer_bh(dev, skb, &dev->rxq, state);
+
+	if (urb) {
+		if (netif_running(dev->net) &&
+		    !test_bit(EVENT_RX_HALT, &dev->flags) &&
+			 state != unlink_start) {
+			rx_submit(dev, urb, GFP_ATOMIC);
+			return;
+		}
+		usb_free_urb(urb);
+	}
+	if (netif_msg_rx_err(dev))
+		devdbg(dev, "no read resubmitted");
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void intr_complete(struct urb *urb, struct pt_regs *regs)
+#else
+static void intr_complete(struct urb *urb)
+#endif
+{
+	struct usbnet	*dev = urb->context;
+	int		status = urb->status;
+
+	switch (status) {
+	/* success */
+	case 0:
+		dev->driver_info->status(dev, urb);
+		break;
+
+	/* software-driven interface shutdown */
+	case -ENOENT:		/* urb killed */
+	case -ESHUTDOWN:	/* hardware gone */
+		if (netif_msg_ifdown(dev))
+			devdbg(dev, "intr shutdown, code %d", status);
+		return;
+
+	/* NOTE:  not throttling like RX/TX, since this endpoint
+	 * already polls infrequently
+	 */
+	default:
+		devdbg(dev, "intr status %d", status);
+		break;
+	}
+
+	if (!netif_running(dev->net))
+		return;
+
+	memset(urb->transfer_buffer, 0, urb->transfer_buffer_length);
+	status = usb_submit_urb(urb, GFP_ATOMIC);
+	if (status != 0 && netif_msg_timer(dev))
+		deverr(dev, "intr resubmit --> %d", status);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* unlink pending rx/tx; completion handlers do all other cleanup */
+
+static int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)
+{
+        unsigned long           flags;
+        struct sk_buff          *skb;
+        int                     count = 0;
+
+        spin_lock_irqsave (&q->lock, flags);
+        while (!skb_queue_empty(q)) {
+                struct skb_data         *entry;
+                struct urb              *urb;
+                int                     retval;
+
+                skb_queue_walk(q, skb) {
+                        entry = (struct skb_data *) skb->cb;
+                        if (entry->state != unlink_start)
+                                goto found;
+                }
+                break;
+found:
+                entry->state = unlink_start;
+                urb = entry->urb;
+
+                /*
+                 * Get reference count of the URB to avoid it to be
+                 * freed during usb_unlink_urb, which may trigger
+                 * use-after-free problem inside usb_unlink_urb since
+                 * usb_unlink_urb is always racing with .complete
+                 * handler(include defer_bh).
+                 */
+                usb_get_urb(urb);
+                spin_unlock_irqrestore(&q->lock, flags);
+                // during some PM-driven resume scenarios,
+                // these (async) unlinks complete immediately
+                retval = usb_unlink_urb (urb);
+                if (retval != -EINPROGRESS && retval != 0)
+                        printk(DEBUG "unlink urb err, %d\n", retval);
+                else
+                        count++;
+                usb_put_urb(urb);
+                spin_lock_irqsave(&q->lock, flags);
+        }
+        spin_unlock_irqrestore (&q->lock, flags);
+
+        return count;
+}
+
+/* Flush all pending rx urbs */
+/* minidrivers may need to do this when the MTU changes */
+
+static
+void axusbnet_unlink_rx_urbs(struct usbnet *dev)
+{
+	if (netif_running(dev->net)) {
+		(void) unlink_urbs(dev, &dev->rxq);
+		tasklet_schedule(&dev->bh);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* precondition: never called in_interrupt */
+
+static
+int axusbnet_stop(struct net_device *net)
+{
+	struct usbnet		*dev = netdev_priv(net);
+	struct driver_info	*info = dev->driver_info;
+	int			temp;
+	int			retval;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18)
+	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(unlink_wakeup);
+#else
+	DECLARE_WAIT_QUEUE_HEAD(unlink_wakeup);
+#endif
+	DECLARE_WAITQUEUE(wait, current);
+
+	netif_stop_queue(net);
+
+	if (netif_msg_ifdown(dev))
+		devinfo(dev, "stop stats: rx/tx %ld/%ld, errs %ld/%ld",
+			dev->stats.rx_packets, dev->stats.tx_packets,
+			dev->stats.rx_errors, dev->stats.tx_errors);
+
+	/* allow minidriver to stop correctly (wireless devices to turn off
+	 * radio etc) */
+	if (info->stop) {
+		retval = info->stop(dev);
+		if (retval < 0 && netif_msg_ifdown(dev))
+			devinfo(dev,
+				"stop fail (%d) usbnet usb-%s-%s, %s",
+				retval,
+				dev->udev->bus->bus_name, dev->udev->devpath,
+				info->description);
+	}
+
+	if (!(info->flags & FLAG_AVOID_UNLINK_URBS)) {
+		/* ensure there are no more active urbs */
+		add_wait_queue(&unlink_wakeup, &wait);
+		dev->wait = &unlink_wakeup;
+		temp = unlink_urbs(dev, &dev->txq) +
+			unlink_urbs(dev, &dev->rxq);
+
+		/* maybe wait for deletions to finish. */
+		while (!skb_queue_empty(&dev->rxq)
+				&& !skb_queue_empty(&dev->txq)
+				&& !skb_queue_empty(&dev->done)) {
+			msleep(UNLINK_TIMEOUT_MS);
+			if (netif_msg_ifdown(dev))
+				devdbg(dev, "waited for %d urb completions",
+				       temp);
+		}
+		dev->wait = NULL;
+		remove_wait_queue(&unlink_wakeup, &wait);
+	}
+
+	usb_kill_urb(dev->interrupt);
+
+	/* deferred work (task, timer, softirq) must also stop.
+	 * can't flush_scheduled_work() until we drop rtnl (later),
+	 * else workers could deadlock; so make workers a NOP.
+	 */
+	dev->flags = 0;
+	del_timer_sync(&dev->delay);
+	tasklet_kill(&dev->bh);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* posts reads, and enables write queuing */
+
+/* precondition: never called in_interrupt */
+
+static
+int axusbnet_open(struct net_device *net)
+{
+	struct usbnet		*dev = netdev_priv(net);
+	int			retval = 0;
+	struct driver_info	*info = dev->driver_info;
+
+	/* put into "known safe" state */
+	if (info->reset) {
+		retval = info->reset(dev);
+		if (retval < 0) {
+			if (netif_msg_ifup(dev))
+				devinfo(dev,
+					"open reset fail (%d) usbnet usb-%s-%s, %s",
+					retval,
+					dev->udev->bus->bus_name,
+					dev->udev->devpath,
+					info->description);
+			goto done;
+		}
+	}
+
+	/* insist peer be connected */
+	if (info->check_connect) {
+		retval = info->check_connect(dev);
+		if (retval < 0) {
+			if (netif_msg_ifup(dev))
+				devdbg(dev, "can't open; %d", retval);
+			goto done;
+		}
+	}
+
+	/* start any status interrupt transfer */
+	if (dev->interrupt) {
+		retval = usb_submit_urb(dev->interrupt, GFP_KERNEL);
+		if (retval < 0) {
+			if (netif_msg_ifup(dev))
+				deverr(dev, "intr submit %d", retval);
+			goto done;
+		}
+	}
+
+	/* reset rx error state */
+    dev->pkt_cnt = 0;
+    dev->pkt_err = 0;
+	clear_bit(EVENT_RX_KILL, &dev->flags);
+
+	netif_start_queue(net);
+	if (netif_msg_ifup(dev)) {
+		char	*framing;
+
+		if (dev->driver_info->flags & FLAG_FRAMING_NC)
+			framing = "NetChip";
+		else if (dev->driver_info->flags & FLAG_FRAMING_GL)
+			framing = "GeneSys";
+		else if (dev->driver_info->flags & FLAG_FRAMING_Z)
+			framing = "Zaurus";
+		else if (dev->driver_info->flags & FLAG_FRAMING_RN)
+			framing = "RNDIS";
+		else if (dev->driver_info->flags & FLAG_FRAMING_AX)
+			framing = "ASIX";
+		else
+			framing = "simple";
+
+		devinfo(dev, "open: enable queueing (rx %d, tx %d) mtu %d %s framing",
+			(int)RX_QLEN(dev), (int)TX_QLEN(dev), dev->net->mtu,
+			framing);
+	}
+
+	/* delay posting reads until we're fully open */
+	tasklet_schedule(&dev->bh);
+	return retval;
+done:
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* ethtool methods; minidrivers may need to add some more, but
+ * they'll probably want to use this base set.
+ */
+
+static
+int axusbnet_get_settings(struct net_device *net, struct ethtool_cmd *cmd)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	if (!dev->mii.mdio_read)
+		return -EOPNOTSUPP;
+
+	return mii_ethtool_gset(&dev->mii, cmd);
+}
+
+static
+int axusbnet_set_settings(struct net_device *net, struct ethtool_cmd *cmd)
+{
+	struct usbnet *dev = netdev_priv(net);
+	int retval;
+
+	if (!dev->mii.mdio_write)
+		return -EOPNOTSUPP;
+
+	retval = mii_ethtool_sset(&dev->mii, cmd);
+
+	/* link speed/duplex might have changed */
+	if (dev->driver_info->link_reset)
+		dev->driver_info->link_reset(dev);
+
+	return retval;
+
+}
+
+static
+u32 axusbnet_get_link(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	/* If a check_connect is defined, return its result */
+	if (dev->driver_info->check_connect)
+		return dev->driver_info->check_connect(dev) == 0;
+
+	/* if the device has mii operations, use those */
+	if (dev->mii.mdio_read)
+		return mii_link_ok(&dev->mii);
+
+	/* Otherwise, dtrt for drivers calling netif_carrier_{on,off} */
+	return ethtool_op_get_link(net);
+}
+
+static
+int axusbnet_nway_reset(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	if (!dev->mii.mdio_write)
+		return -EOPNOTSUPP;
+
+	return mii_nway_restart(&dev->mii);
+}
+
+static
+void axusbnet_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	strncpy(info->driver, dev->driver_name, sizeof(info->driver));
+	strncpy(info->version, DRIVER_VERSION, sizeof(info->version));
+	strncpy(info->fw_version, dev->driver_info->description,
+		sizeof(info->fw_version));
+	usb_make_path(dev->udev, info->bus_info, sizeof(info->bus_info));
+}
+
+static
+u32 axusbnet_get_msglevel(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	return dev->msg_enable;
+}
+
+static
+void axusbnet_set_msglevel(struct net_device *net, u32 level)
+{
+	struct usbnet *dev = netdev_priv(net);
+
+	dev->msg_enable = level;
+}
+
+/* drivers may override default ethtool_ops in their bind() routine */
+static struct ethtool_ops axusbnet_ethtool_ops = {
+	.get_settings		= axusbnet_get_settings,
+	.set_settings		= axusbnet_set_settings,
+	.get_link		= axusbnet_get_link,
+	.nway_reset		= axusbnet_nway_reset,
+	.get_drvinfo		= axusbnet_get_drvinfo,
+	.get_msglevel		= axusbnet_get_msglevel,
+	.set_msglevel		= axusbnet_set_msglevel,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* work that cannot be done in interrupt context uses keventd.
+ *
+ * NOTE:  with 2.5 we could do more of this using completion callbacks,
+ * especially now that control transfers can be queued.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void kevent(void *data)
+{
+	struct usbnet *dev = (struct usbnet *)data;
+#else
+static void kevent(struct work_struct *work)
+{
+	struct usbnet		*dev =
+		container_of(work, struct usbnet, kevent);
+#endif
+	int			status;
+
+	/* usb_clear_halt() needs a thread context */
+	if (test_bit(EVENT_TX_HALT, &dev->flags)) {
+
+		unlink_urbs(dev, &dev->txq);
+		status = usb_clear_halt(dev->udev, dev->out);
+		if (status < 0
+				&& status != -EPIPE
+				&& status != -ESHUTDOWN) {
+			if (netif_msg_tx_err(dev))
+				deverr(dev, "can't clear tx halt, status %d",
+				       status);
+		} else {
+			clear_bit(EVENT_TX_HALT, &dev->flags);
+			if (status != -ESHUTDOWN)
+				netif_wake_queue(dev->net);
+		}
+	}
+	if (test_bit(EVENT_RX_HALT, &dev->flags)) {
+
+		unlink_urbs(dev, &dev->rxq);
+		status = usb_clear_halt(dev->udev, dev->in);
+		if (status < 0
+				&& status != -EPIPE
+				&& status != -ESHUTDOWN) {
+			if (netif_msg_rx_err(dev))
+				deverr(dev, "can't clear rx halt, status %d",
+				       status);
+		} else {
+			clear_bit(EVENT_RX_HALT, &dev->flags);
+			tasklet_schedule(&dev->bh);
+		}
+	}
+
+	/* tasklet could resubmit itself forever if memory is tight */
+	if (test_bit(EVENT_RX_MEMORY, &dev->flags)) {
+		struct urb	*urb = NULL;
+
+		if (netif_running(dev->net))
+			urb = usb_alloc_urb(0, GFP_KERNEL);
+		else
+			clear_bit(EVENT_RX_MEMORY, &dev->flags);
+		if (urb != NULL) {
+			clear_bit(EVENT_RX_MEMORY, &dev->flags);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+			urb->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+			rx_submit(dev, urb, GFP_KERNEL);
+			tasklet_schedule(&dev->bh);
+		}
+	}
+
+	if (test_bit(EVENT_LINK_RESET, &dev->flags)) {
+		struct driver_info	*info = dev->driver_info;
+		int			retval = 0;
+
+		clear_bit(EVENT_LINK_RESET, &dev->flags);
+
+		if (info->link_reset) {
+			retval = info->link_reset(dev);
+			if (retval < 0) {
+				devinfo(dev,
+					"link reset failed (%d) usbnet usb-%s-%s, %s",
+					retval,
+					dev->udev->bus->bus_name,
+					dev->udev->devpath,
+					info->description);
+			}
+		}
+	}
+
+	if (dev->flags)
+		devdbg(dev, "kevent done, flags = 0x%lx", dev->flags);
+}
+
+/*-------------------------------------------------------------------------*/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static void tx_complete(struct urb *urb, struct pt_regs *regs)
+#else
+static void tx_complete(struct urb *urb)
+#endif
+{
+	struct sk_buff		*skb = (struct sk_buff *) urb->context;
+	struct skb_data		*entry = (struct skb_data *) skb->cb;
+	struct usbnet		*dev = entry->dev;
+
+	if (urb->status == 0) {
+		dev->stats.tx_packets++;
+		dev->stats.tx_bytes += entry->length;
+	} else {
+		dev->stats.tx_errors++;
+
+		switch (urb->status) {
+		case -EPIPE:
+			axusbnet_defer_kevent(dev, EVENT_TX_HALT);
+			break;
+
+		/* software-driven interface shutdown */
+		case -ECONNRESET:		/* async unlink */
+		case -ESHUTDOWN:		/* hardware gone */
+			break;
+
+		/* like rx, tx gets controller i/o faults during khubd delays */
+		/* and so it uses the same throttling mechanism. */
+		case -EPROTO:
+		case -ETIME:
+		case -EILSEQ:
+			if (!timer_pending(&dev->delay)) {
+				mod_timer(&dev->delay,
+					  jiffies + THROTTLE_JIFFIES);
+				if (netif_msg_link(dev))
+					devdbg(dev, "tx throttle %d",
+					       urb->status);
+			}
+			netif_stop_queue(dev->net);
+			break;
+		default:
+			if (netif_msg_tx_err(dev))
+				devdbg(dev, "tx err %d", entry->urb->status);
+			break;
+		}
+	}
+
+	urb->dev = NULL;
+	entry->state = tx_done;
+	(void) defer_bh(dev, skb, &dev->txq, tx_done);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static
+void axusbnet_tx_timeout(struct net_device *net)
+{
+	struct usbnet *dev = netdev_priv(net);
+	struct driver_info	*info = dev->driver_info;
+
+	if (!(info->flags & FLAG_AVOID_UNLINK_URBS)) {
+		unlink_urbs(dev, &dev->txq);
+	}	
+	tasklet_schedule(&dev->bh);
+
+	/* FIXME: device recovery -- reset? */
+}
+
+/*-------------------------------------------------------------------------*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+static int
+#else
+static netdev_tx_t
+#endif
+axusbnet_start_xmit(struct sk_buff *skb, struct net_device *net)
+{
+	struct usbnet		*dev = netdev_priv(net);
+	int			length;
+	struct urb		*urb = NULL;
+	struct skb_data		*entry;
+	struct driver_info	*info = dev->driver_info;
+	unsigned long		flags;
+	int retval;
+
+	/* some devices want funky USB-level framing, for */
+	/* win32 driver (usually) and/or hardware quirks */
+	if (info->tx_fixup) {
+		skb = info->tx_fixup(dev, skb, GFP_ATOMIC);
+		if (!skb) {
+			if (netif_msg_tx_err(dev))
+				devdbg(dev, "can't tx_fixup skb");
+			goto drop;
+		}
+	}
+	length = skb->len;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb) {
+		if (netif_msg_tx_err(dev))
+			devdbg(dev, "no urb");
+		goto drop;
+	}
+
+	entry = (struct skb_data *) skb->cb;
+	entry->urb = urb;
+	entry->dev = dev;
+	entry->state = tx_start;
+	entry->length = length;
+
+	usb_fill_bulk_urb(urb, dev->udev, dev->out, skb->data,
+			  skb->len, tx_complete, skb);
+
+	/* don't assume the hardware handles USB_ZERO_PACKET
+	 * NOTE:  strictly conforming cdc-ether devices should expect
+	 * the ZLP here, but ignore the one-byte packet.
+	 */
+	if (!(info->flags & FLAG_SEND_ZLP) && (length % dev->maxpacket) == 0) {
+		urb->transfer_buffer_length++;
+		if (skb_tailroom(skb)) {
+			skb->data[skb->len] = 0;
+			__skb_put(skb, 1);
+		}
+	}
+
+	spin_lock_irqsave(&dev->txq.lock, flags);
+
+	switch ((retval = usb_submit_urb(urb, GFP_ATOMIC))) {
+	case -EPIPE:
+		netif_stop_queue(net);
+		axusbnet_defer_kevent(dev, EVENT_TX_HALT);
+		break;
+	default:
+		if (netif_msg_tx_err(dev))
+			devdbg(dev, "tx: submit urb err %d", retval);
+		break;
+	case 0:
+		net->trans_start = jiffies;
+		__skb_queue_tail(&dev->txq, skb);
+		if (dev->txq.qlen >= TX_QLEN(dev))
+			netif_stop_queue(net);
+	}
+	spin_unlock_irqrestore(&dev->txq.lock, flags);
+
+	if (retval) {
+		if (netif_msg_tx_err(dev))
+			devdbg(dev, "drop, code %d", retval);
+drop:
+		dev->stats.tx_dropped++;
+		if (skb)
+			dev_kfree_skb_any(skb);
+		usb_free_urb(urb);
+	} else if (netif_msg_tx_queued(dev)) {
+		devdbg(dev, "> tx, len %d, type 0x%x",
+		       length, skb->protocol);
+	}
+	return NETDEV_TX_OK;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* tasklet (work deferred from completions, in_irq) or timer */
+
+static void axusbnet_bh(unsigned long param)
+{
+	struct usbnet		*dev = (struct usbnet *) param;
+	struct sk_buff		*skb;
+	struct skb_data		*entry;
+
+	while ((skb = skb_dequeue(&dev->done))) {
+		entry = (struct skb_data *) skb->cb;
+		switch (entry->state) {
+		case rx_done:
+			entry->state = rx_cleanup;
+			rx_process(dev, skb);
+			continue;
+		case tx_done:
+		case rx_cleanup:
+			usb_free_urb(entry->urb);
+			dev_kfree_skb(skb);
+			continue;
+		default:
+			devdbg(dev, "bogus skb state %d", entry->state);
+		}
+	}
+
+	/* restart RX again after disabling due to high error rate */
+         clear_bit(EVENT_RX_KILL, &dev->flags);
+
+	/* waiting for all pending urbs to complete? */
+	if (dev->wait) {
+		if ((dev->txq.qlen + dev->rxq.qlen + dev->done.qlen) == 0)
+			wake_up(dev->wait);
+
+	/* or are we maybe short a few urbs? */
+	} else if (netif_running(dev->net)
+			&& netif_device_present(dev->net)
+			&& !timer_pending(&dev->delay)
+			&& !test_bit(EVENT_RX_HALT, &dev->flags)) {
+		int	temp = dev->rxq.qlen;
+		int	qlen = RX_QLEN(dev);
+
+		if (temp < qlen) {
+			struct urb	*urb;
+			int		i;
+
+			/* don't refill the queue all at once */
+			for (i = 0; i < 10 && dev->rxq.qlen < qlen; i++) {
+				urb = usb_alloc_urb(0, GFP_ATOMIC);
+				if (urb != NULL) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+					urb->transfer_flags |= URB_ASYNC_UNLINK;
+#endif
+					rx_submit(dev, urb, GFP_ATOMIC);
+				}
+			}
+			if (temp != dev->rxq.qlen && netif_msg_link(dev))
+				devdbg(dev, "rxqlen %d --> %d",
+				       temp, dev->rxq.qlen);
+			if (dev->rxq.qlen < qlen)
+				tasklet_schedule(&dev->bh);
+		}
+		if (dev->txq.qlen < TX_QLEN(dev))
+			netif_wake_queue(dev->net);
+	}
+}
+
+
+/*-------------------------------------------------------------------------
+ *
+ * USB Device Driver support
+ *
+ *-------------------------------------------------------------------------*/
+
+/* precondition: never called in_interrupt */
+
+static
+void axusbnet_disconnect(struct usb_interface *intf)
+{
+	struct usbnet		*dev;
+	struct usb_device	*xdev;
+	struct net_device	*net;
+
+	dev = usb_get_intfdata(intf);
+	usb_set_intfdata(intf, NULL);
+	if (!dev)
+		return;
+
+	xdev = interface_to_usbdev(intf);
+
+	if (netif_msg_probe(dev))
+		devinfo(dev, "unregister '%s' usb-%s-%s, %s",
+			intf->dev.driver->name,
+			xdev->bus->bus_name, xdev->devpath,
+			dev->driver_info->description);
+
+	net = dev->net;
+	unregister_netdev(net);
+
+	/* we don't hold rtnl here ... */
+	flush_scheduled_work();
+
+	if (dev->driver_info->unbind)
+		dev->driver_info->unbind(dev, intf);
+
+	free_netdev(net);
+	usb_put_dev(xdev);
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* precondition: never called in_interrupt */
+
+static int
+axusbnet_probe(struct usb_interface *udev, const struct usb_device_id *prod)
+{
+	struct usbnet			*dev;
+	struct net_device		*net;
+	struct usb_host_interface	*interface;
+	struct driver_info		*info;
+	struct usb_device		*xdev;
+	int				status;
+	const char			*name;
+
+	name = udev->dev.driver->name;
+	info = (struct driver_info *) prod->driver_info;
+	if (!info) {
+		printk(KERN_ERR "blacklisted by %s\n", name);
+		return -ENODEV;
+	}
+	xdev = interface_to_usbdev(udev);
+	interface = udev->cur_altsetting;
+
+	usb_get_dev(xdev);
+
+	status = -ENOMEM;
+
+	/* set up our own records */
+	net = alloc_etherdev(sizeof(*dev));
+	if (!net) {
+		printk(KERN_ERR "can't kmalloc dev");
+		goto out;
+	}
+
+	dev = netdev_priv(net);
+	dev->udev = xdev;
+	dev->intf = udev;
+	dev->driver_info = info;
+	dev->driver_name = name;
+	dev->msg_enable = netif_msg_init(msg_level, NETIF_MSG_DRV |
+					 NETIF_MSG_PROBE | NETIF_MSG_LINK);
+	skb_queue_head_init(&dev->rxq);
+	skb_queue_head_init(&dev->txq);
+	skb_queue_head_init(&dev->done);
+	dev->bh.func = axusbnet_bh;
+	dev->bh.data = (unsigned long) dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+	INIT_WORK(&dev->kevent, kevent, dev);
+#else
+	INIT_WORK(&dev->kevent, kevent);
+#endif
+
+	dev->delay.function = axusbnet_bh;
+	dev->delay.data = (unsigned long) dev;
+	init_timer(&dev->delay);
+	/* mutex_init(&dev->phy_mutex); */
+
+	dev->net = net;
+
+	/* rx and tx sides can use different message sizes;
+	 * bind() should set rx_urb_size in that case.
+	 */
+	dev->hard_mtu = net->mtu + net->hard_header_len;
+
+#if 0
+	/* dma_supported() is deeply broken on almost all architectures */
+	/* possible with some EHCI controllers */
+	if (dma_supported(&udev->dev, DMA_BIT_MASK(64)))
+		net->features |= NETIF_F_HIGHDMA;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
+	net->open		= axusbnet_open,
+	net->stop		= axusbnet_stop,
+	net->hard_start_xmit	= axusbnet_start_xmit,
+	net->tx_timeout	= axusbnet_tx_timeout,
+	net->get_stats = axusbnet_get_stats;
+#endif
+
+	net->watchdog_timeo = TX_TIMEOUT_JIFFIES;
+	net->ethtool_ops = &axusbnet_ethtool_ops;
+
+	/* allow device-specific bind/init procedures */
+	/* NOTE net->name still not usable ... */
+	status = info->bind(dev, udev);
+	if (status < 0) {
+		deverr(dev, "Binding device failed: %d", status);
+		goto out1;
+	}
+
+	/* maybe the remote can't receive an Ethernet MTU */
+	if (net->mtu > (dev->hard_mtu - net->hard_header_len))
+		net->mtu = dev->hard_mtu - net->hard_header_len;
+
+	status = init_status(dev, udev);
+	if (status < 0)
+		goto out3;
+
+	if (!dev->rx_urb_size)
+		dev->rx_urb_size = dev->hard_mtu;
+	dev->maxpacket = usb_maxpacket(dev->udev, dev->out, 1);
+
+	SET_NETDEV_DEV(net, &udev->dev);
+	status = register_netdev(net);
+	if (status) {
+		deverr(dev, "net device registration failed: %d", status);
+		goto out3;
+	}
+
+	if (netif_msg_probe(dev))
+		devinfo(dev, "register '%s' at usb-%s-%s, %s, %pM",
+			udev->dev.driver->name,
+			xdev->bus->bus_name, xdev->devpath,
+			dev->driver_info->description,
+			net->dev_addr);
+
+	/* ok, it's ready to go. */
+	usb_set_intfdata(udev, dev);
+
+	/* start as if the link is up */
+	netif_device_attach(net);
+
+	return 0;
+
+out3:
+	if (info->unbind)
+		info->unbind(dev, udev);
+out1:
+	free_netdev(net);
+out:
+	usb_put_dev(xdev);
+	return status;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * suspend the whole driver as soon as the first interface is suspended
+ * resume only when the last interface is resumed
+ */
+
+static int axusbnet_suspend(struct usb_interface *intf,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+pm_message_t message)
+#else
+u32 message)
+#endif
+{
+	struct usbnet *dev = usb_get_intfdata(intf);
+
+	if (!dev->suspend_count++) {
+		/*
+		 * accelerate emptying of the rx and queues, to avoid
+		 * having everything error out.
+		 */
+		netif_device_detach(dev->net);
+		(void) unlink_urbs(dev, &dev->rxq);
+		(void) unlink_urbs(dev, &dev->txq);
+		usb_kill_urb(dev->interrupt);
+		/*
+		 * reattach so runtime management can use and
+		 * wake the device
+		 */
+		netif_device_attach(dev->net);
+	}
+	return 0;
+}
+
+static int
+axusbnet_resume(struct usb_interface *intf)
+{
+	struct usbnet	*dev = usb_get_intfdata(intf);
+	int	retval = 0;
+
+	if (!--dev->suspend_count)
+		tasklet_schedule(&dev->bh);
+
+	retval = init_status(dev, intf);
+	if (retval < 0)
+		return retval;
+
+	if (dev->interrupt) {
+		retval = usb_submit_urb(dev->interrupt, GFP_KERNEL);
+		if (retval < 0 && netif_msg_ifup(dev))
+			deverr(dev, "intr submit %d", retval);
+	}
+
+	return retval;
+}
+
diff --no-dereference -Nru kernel-22/kernel/drivers/net/usb/axusbnet.h kernel-central/kernel/drivers/net/usb/axusbnet.h
--- kernel-22/kernel/drivers/net/usb/axusbnet.h	1970-01-01 03:00:00.000000000 +0300
+++ kernel-central/kernel/drivers/net/usb/axusbnet.h	2016-07-18 05:57:22.000000000 +0300
@@ -0,0 +1,211 @@
+/*
+ * USB Networking Link Interface
+ *
+ * Copyright (C) 2000-2005 by David Brownell <dbrownell@users.sourceforge.net>
+ * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef	__LINUX_USB_USBNET_H
+#define	__LINUX_USB_USBNET_H
+
+#ifndef gfp_t
+#define gfp_t int
+#endif
+
+/* interface from usbnet core to each USB networking link we handle */
+struct usbnet {
+	/* housekeeping */
+	struct usb_device	*udev;
+	struct usb_interface	*intf;
+	struct driver_info	*driver_info;
+	const char		*driver_name;
+	void			*driver_priv;
+	wait_queue_head_t	*wait;
+	/* struct mutex		phy_mutex; */
+	unsigned char		suspend_count;
+	unsigned char           pkt_cnt, pkt_err;
+
+	/* i/o info: pipes etc */
+	unsigned		in, out;
+	struct usb_host_endpoint *status;
+	unsigned		maxpacket;
+	struct timer_list	delay;
+
+	/* protocol/interface state */
+	struct net_device	*net;
+	struct net_device_stats stats;
+	int			msg_enable;
+	unsigned long		data[5];
+	u32			xid;
+	u32			hard_mtu;	/* count any extra framing */
+	size_t			rx_urb_size;	/* size for rx urbs */
+	struct mii_if_info	mii;
+
+	/* various kinds of pending driver work */
+	struct sk_buff_head	rxq;
+	struct sk_buff_head	txq;
+	struct sk_buff_head	done;
+	struct sk_buff_head	rxq_pause;
+	struct urb		*interrupt;
+	struct tasklet_struct	bh;
+
+	struct work_struct	kevent;
+	unsigned long		flags;
+#		define EVENT_TX_HALT	0
+#		define EVENT_RX_HALT	1
+#		define EVENT_RX_MEMORY	2
+#		define EVENT_STS_SPLIT	3
+#		define EVENT_LINK_RESET	4
+#		define EVENT_RX_PAUSED	5
+#		define EVENT_RX_KILL    10
+
+	void			*priv;	/* point to minidriver private data */
+	unsigned char		rx_size;
+};
+
+static inline struct usb_driver *driver_of(struct usb_interface *intf)
+{
+	return to_usb_driver(intf->dev.driver);
+}
+
+/* interface from the device/framing level "minidriver" to core */
+struct driver_info {
+	char		*description;
+
+	int		flags;
+/* framing is CDC Ethernet, not writing ZLPs (hw issues), or optionally: */
+#define FLAG_FRAMING_NC	0x0001		/* guard against device dropouts */
+#define FLAG_FRAMING_GL	0x0002		/* genelink batches packets */
+#define FLAG_FRAMING_Z	0x0004		/* zaurus adds a trailer */
+#define FLAG_FRAMING_RN	0x0008		/* RNDIS batches, plus huge header */
+
+#define FLAG_NO_SETINT	0x0010		/* device can't set_interface() */
+#define FLAG_ETHER	0x0020		/* maybe use "eth%d" names */
+
+#define FLAG_FRAMING_AX 0x0040		/* AX88772/178 packets */
+#define FLAG_WLAN	0x0080		/* use "wlan%d" names */
+#define FLAG_AVOID_UNLINK_URBS	0x0100	/* don't unlink urbs at usbnet_stop() */
+#define FLAG_SEND_ZLP	0x0200		/* hw requires ZLPs are sent */
+#define FLAG_HW_IP_ALIGNMENT	0x0400	/* AX88772B support hardware IP alignment */
+
+
+	/* init device ... can sleep, or cause probe() failure */
+	int	(*bind)(struct usbnet *, struct usb_interface *);
+
+	/* cleanup device ... can sleep, but can't fail */
+	void	(*unbind)(struct usbnet *, struct usb_interface *);
+
+	/* reset device ... can sleep */
+	int	(*reset)(struct usbnet *);
+
+	/* stop device ... can sleep */
+	int	(*stop)(struct usbnet *);
+
+	/* see if peer is connected ... can sleep */
+	int	(*check_connect)(struct usbnet *);
+
+	/* for status polling */
+	void	(*status)(struct usbnet *, struct urb *);
+
+	/* link reset handling, called from defer_kevent */
+	int	(*link_reset)(struct usbnet *);
+
+	/* fixup rx packet (strip framing) */
+	int	(*rx_fixup)(struct usbnet *dev, struct sk_buff *skb);
+
+	/* fixup tx packet (add framing) */
+	struct sk_buff	*(*tx_fixup)(struct usbnet *dev,
+				struct sk_buff *skb, gfp_t flags);
+
+	/* early initialization code, can sleep. This is for minidrivers
+	 * having 'subminidrivers' that need to do extra initialization
+	 * right after minidriver have initialized hardware. */
+	int	(*early_init)(struct usbnet *dev);
+
+	/* called by minidriver when receiving indication */
+	void	(*indication)(struct usbnet *dev, void *ind, int indlen);
+
+	/* for new devices, use the descriptor-reading code instead */
+	int		in;		/* rx endpoint */
+	int		out;		/* tx endpoint */
+
+	unsigned long	data;		/* Misc driver specific data */
+};
+
+/* Drivers that reuse some of the standard USB CDC infrastructure
+ * (notably, using multiple interfaces according to the CDC
+ * union descriptor) get some helper code.
+ */
+struct cdc_state {
+	struct usb_cdc_header_desc	*header;
+	struct usb_cdc_union_desc	*u;
+	struct usb_cdc_ether_desc	*ether;
+	struct usb_interface		*control;
+	struct usb_interface		*data;
+};
+
+/* CDC and RNDIS support the same host-chosen packet filters for IN transfers */
+#define	DEFAULT_FILTER	(USB_CDC_PACKET_TYPE_BROADCAST \
+			|USB_CDC_PACKET_TYPE_ALL_MULTICAST \
+			|USB_CDC_PACKET_TYPE_PROMISCUOUS \
+			|USB_CDC_PACKET_TYPE_DIRECTED)
+
+
+/* we record the state for each of our queued skbs */
+enum skb_state {
+	illegal = 0,
+	tx_start, tx_done,
+	rx_start, rx_done, rx_cleanup,
+	unlink_start
+};
+
+struct skb_data {	/* skb->cb is one of these */
+	struct urb		*urb;
+	struct usbnet		*dev;
+	enum skb_state		state;
+	size_t			length;
+};
+
+#ifndef skb_queue_walk_safe
+#define skb_queue_walk_safe(queue, skb, tmp)				\
+			for (skb = (queue)->next, tmp = skb->next;	\
+			skb != (struct sk_buff *)(queue);		\
+			skb = tmp, tmp = skb->next)
+#endif
+
+/* messaging support includes the interface name, so it must not be
+ * used before it has one ... notably, in minidriver bind() calls.
+ */
+#ifdef DEBUG
+#define devdbg(usbnet, fmt, arg...) \
+	printk("%s: " fmt "\n" , (usbnet)->net->name , ## arg)
+#else
+#define devdbg(usbnet, fmt, arg...) \
+	({ if (0) printk("%s: " fmt "\n" , (usbnet)->net->name , \
+		## arg); 0; })
+#endif
+
+#define deverr(usbnet, fmt, arg...) \
+	printk(KERN_ERR "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
+#define devwarn(usbnet, fmt, arg...) \
+	printk(KERN_WARNING "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
+
+#define devinfo(usbnet, fmt, arg...) \
+	printk(KERN_INFO "%s: " fmt "\n" , (usbnet)->net->name , ## arg); \
+
+
+#endif /* __LINUX_USB_USBNET_H */
diff --no-dereference -Nru kernel-22/kernel/drivers/net/usb/compatibility.h kernel-central/kernel/drivers/net/usb/compatibility.h
--- kernel-22/kernel/drivers/net/usb/compatibility.h	1970-01-01 03:00:00.000000000 +0300
+++ kernel-central/kernel/drivers/net/usb/compatibility.h	2016-05-25 06:10:36.000000000 +0300
@@ -0,0 +1,471 @@
+#ifndef LINUX_COMPATIBILITY_H
+#define LINUX_COMPATIBILITY_H
+
+/*
+ * Definition and macro
+ */
+
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/in.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+	#include <linux/mdio.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0)
+	#include <uapi/linux/mdio.h>
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0) */
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0)
+	#define NETIF_F_CSUM_MASK			NETIF_F_ALL_CSUM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+	#define skb_vlan_tag_present(__skb)		vlan_tx_tag_present(__skb)
+	#define skb_vlan_tag_get(__skb)			vlan_tx_tag_get(__skb)
+	#define skb_vlan_tag_get_id(__skb)		vlan_tx_tag_get_id(__skb)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)
+	#define napi_alloc_skb(napi, length)		netdev_alloc_skb_ip_align(netdev,length)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+	#define ether_addr_copy(dst, src)		memcpy(dst, src, ETH_ALEN)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+	#define BIT(nr)					(1UL << (nr))
+	#define BIT_ULL(nr)				(1ULL << (nr))
+	#define BITS_PER_BYTE				8
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+	#define NETIF_F_HW_VLAN_CTAG_RX			NETIF_F_HW_VLAN_RX
+	#define NETIF_F_HW_VLAN_CTAG_TX			NETIF_F_HW_VLAN_TX
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0)
+	#define USB_DEVICE_INTERFACE_CLASS(vend, prod, iclass) \
+		USB_DEVICE_AND_INTERFACE_INFO(vend, prod, iclass, 0xff, 0)
+
+	static inline __sum16 tcp_v6_check(int len,
+					   const struct in6_addr *saddr,
+					   const struct in6_addr *daddr,
+					   __wsum base)
+	{
+		return csum_ipv6_magic(saddr, daddr, len, IPPROTO_TCP, base);
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+	#define eth_random_addr(addr)			random_ether_addr(addr)
+	#define MDIO_EEE_100TX				MDIO_AN_EEE_ADV_100TX	/* 100TX EEE cap */
+	#define MDIO_EEE_1000T				MDIO_AN_EEE_ADV_1000T	/* 1000T EEE cap */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+	#define ETH_MDIO_SUPPORTS_C22			MDIO_SUPPORTS_C22
+
+	static inline void eth_hw_addr_random(struct net_device *dev)
+	{
+		random_ether_addr(dev->dev_addr);
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+	#define module_usb_driver(__driver) \
+	static int __init __driver##_init(void) \
+	{ \
+		return usb_register(&(__driver)); \
+	} \
+	module_init(__driver##_init); \
+	static void __exit __driver##_exit(void) \
+	{ \
+		usb_deregister(&(__driver)); \
+	} \
+	module_exit(__driver##_exit);
+
+	#define netdev_features_t			u32
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0)
+	#define PMSG_IS_AUTO(msg)	(((msg).event & PM_EVENT_AUTO) != 0)
+
+	static inline struct page *skb_frag_page(const skb_frag_t *frag)
+	{
+		return frag->page;
+	}
+
+	static inline void *skb_frag_address(const skb_frag_t *frag)
+	{
+		return page_address(skb_frag_page(frag)) + frag->page_offset;
+	}
+
+	static inline unsigned int skb_frag_size(const skb_frag_t *frag)
+	{
+		return frag->size;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0)
+	#define ndo_set_rx_mode				ndo_set_multicast_list
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+	#define NETIF_F_RXCSUM				(1 << 29) /* Receive checksumming offload */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38)
+	#define MDIO_AN_EEE_ADV				60	/* EEE advertisement */
+	#define MDIO_AN_EEE_ADV_100TX			0x0002	/* Advertise 100TX EEE cap */
+	#define MDIO_AN_EEE_ADV_1000T			0x0004	/* Advertise 1000T EEE cap */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)
+	#define skb_checksum_none_assert(skb_ptr)	(skb_ptr)->ip_summed = CHECKSUM_NONE
+
+	static inline __be16 vlan_get_protocol(const struct sk_buff *skb)
+	{
+	       __be16 protocol = 0;
+
+	       if (vlan_tx_tag_present(skb) ||
+	            skb->protocol != cpu_to_be16(ETH_P_8021Q))
+	               protocol = skb->protocol;
+	       else {
+	               __be16 proto, *protop;
+	               protop = skb_header_pointer(skb, offsetof(struct vlan_ethhdr,
+	                                               h_vlan_encapsulated_proto),
+	                                               sizeof(proto), &proto);
+	               if (likely(protop))
+	                       protocol = *protop;
+	       }
+
+	       return protocol;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+	#define skb_tx_timestamp(skb)
+
+	#define queue_delayed_work(long_wq, work, delay)	schedule_delayed_work(work, delay)
+
+	static inline void usleep_range(unsigned long min, unsigned long max)
+	{
+		unsigned long ms = min / 1000;
+
+		if (ms)
+			mdelay(ms);
+
+		udelay(min % 1000);
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+	static inline bool pci_dev_run_wake(struct pci_dev *dev)
+	{
+		return 1;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+	#define netdev_mc_count(netdev)			((netdev)->mc_count)
+	#define netdev_mc_empty(netdev)			(netdev_mc_count(netdev) == 0)
+
+	#define netif_printk(priv, type, level, netdev, fmt, args...)	\
+	do {								\
+		if (netif_msg_##type(priv))				\
+			printk(level "%s: " fmt,(netdev)->name , ##args); \
+	} while (0)
+
+	#define netif_emerg(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_EMERG, netdev, fmt, ##args)
+	#define netif_alert(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ALERT, netdev, fmt, ##args)
+	#define netif_crit(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_CRIT, netdev, fmt, ##args)
+	#define netif_err(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ERR, netdev, fmt, ##args)
+	#define netif_warn(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_WARNING, netdev, fmt, ##args)
+	#define netif_notice(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_NOTICE, netdev, fmt, ##args)
+	#define netif_info(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_INFO, (netdev), fmt, ##args)
+
+	static inline int usb_enable_autosuspend(struct usb_device *udev)
+	{ return 0; }
+	static inline int usb_disable_autosuspend(struct usb_device *udev)
+	{ return 0; }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	#define get_sset_count				get_stats_count
+
+	static inline
+	struct sk_buff *netdev_alloc_skb_ip_align(struct net_device *dev,
+						  unsigned int length)
+	{
+		struct sk_buff *skb = netdev_alloc_skb(dev, length + NET_IP_ALIGN);
+
+		if (NET_IP_ALIGN && skb)
+			skb_reserve(skb, NET_IP_ALIGN);
+		return skb;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+	#define pm_request_resume(para)
+	#define pm_runtime_set_suspended(para)
+	#define pm_schedule_suspend(para1, para2)
+	#define pm_runtime_get_sync(para)
+	#define pm_runtime_put_sync(para)
+	#define pm_runtime_put_noidle(para)
+	#define pm_runtime_idle(para)
+	#define pm_runtime_set_active(para)
+	#define pm_runtime_enable(para)
+	#define pm_runtime_disable(para)
+	typedef int netdev_tx_t;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+	#define USB_SPEED_SUPER				(USB_SPEED_VARIABLE + 1)
+	#define MDIO_MMD_AN				7	/* Auto-Negotiation */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	#define napi_gro_receive(napi, skb)		netif_receive_skb(skb)
+	#define vlan_gro_receive(napi, grp, vlan_tci, skb) \
+		vlan_hwaccel_receive_skb(skb, grp, vlan_tci)
+
+	static inline void usb_autopm_put_interface_async(struct usb_interface *intf)
+	{
+		struct usb_device *udev = interface_to_usbdev(intf);
+		int status = 0;
+
+		if (intf->condition == USB_INTERFACE_UNBOUND) {
+			status = -ENODEV;
+		} else {
+			udev->last_busy = jiffies;
+			--intf->pm_usage_cnt;
+			if (udev->autosuspend_disabled || udev->autosuspend_delay < 0)
+				status = -EPERM;
+		}
+	}
+
+	static inline int usb_autopm_get_interface_async(struct usb_interface *intf)
+	{
+		struct usb_device *udev = interface_to_usbdev(intf);
+		int status = 0;
+
+		if (intf->condition == USB_INTERFACE_UNBOUND)
+			status = -ENODEV;
+		else if (udev->autoresume_disabled)
+			status = -EPERM;
+		else
+			++intf->pm_usage_cnt;
+		return status;
+	}
+
+	static inline int eth_change_mtu(struct net_device *dev, int new_mtu)
+	{
+		if (new_mtu < 68 || new_mtu > ETH_DATA_LEN)
+			return -EINVAL;
+		dev->mtu = new_mtu;
+		return 0;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+	static inline void __skb_queue_splice(const struct sk_buff_head *list,
+					      struct sk_buff *prev,
+					      struct sk_buff *next)
+	{
+		struct sk_buff *first = list->next;
+		struct sk_buff *last = list->prev;
+
+		first->prev = prev;
+		prev->next = first;
+
+		last->next = next;
+		next->prev = last;
+	}
+
+	static inline void skb_queue_splice(const struct sk_buff_head *list,
+					    struct sk_buff_head *head)
+	{
+		if (!skb_queue_empty(list)) {
+			__skb_queue_splice(list, (struct sk_buff *) head, head->next);
+			head->qlen += list->qlen;
+		}
+	}
+
+	static inline void __skb_queue_head_init(struct sk_buff_head *list)
+	{
+		list->prev = list->next = (struct sk_buff *)list;
+		list->qlen = 0;
+	}
+
+	static inline void skb_queue_splice_init(struct sk_buff_head *list,
+						 struct sk_buff_head *head)
+	{
+		if (!skb_queue_empty(list)) {
+			__skb_queue_splice(list, (struct sk_buff *) head, head->next);
+			head->qlen += list->qlen;
+			__skb_queue_head_init(list);
+		}
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+	#define PM_EVENT_AUTO		0x0400
+
+	static inline void __list_splice2(const struct list_head *list,
+					  struct list_head *prev,
+					  struct list_head *next)
+	{
+		struct list_head *first = list->next;
+		struct list_head *last = list->prev;
+
+		first->prev = prev;
+		prev->next = first;
+
+		last->next = next;
+		next->prev = last;
+	}
+
+	static inline void list_splice_tail(struct list_head *list,
+					    struct list_head *head)
+	{
+		if (!list_empty(list))
+			__list_splice2(list, head->prev, head);
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+	struct napi_struct {
+		struct list_head	poll_list;
+		unsigned long		state;
+		int			weight;
+		int			(*poll)(struct napi_struct *, int);
+	#ifdef CONFIG_NETPOLL
+		spinlock_t		poll_lock;
+		int			poll_owner;
+		struct net_device	*dev;
+		struct list_head	dev_list;
+	#endif
+	};
+
+	#define napi_enable(napi_ptr)			netif_poll_enable(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_disable(napi_ptr)			netif_poll_disable(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_schedule(napi_ptr)			netif_rx_schedule(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define napi_complete(napi_ptr)			netif_rx_complete(container_of(napi_ptr, struct r8152, napi)->netdev)
+	#define netif_napi_add(ndev, napi_ptr, function, weight_t) \
+		ndev->poll = function; \
+		ndev->weight = weight_t;
+	typedef unsigned long				uintptr_t;
+	#define DMA_BIT_MASK(value) \
+		(value < 64 ? ((1ULL << value) - 1) : 0xFFFFFFFFFFFFFFFFULL)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+	#define NETIF_F_IPV6_CSUM			16
+	#define cancel_delayed_work_sync		cancel_delayed_work
+
+	static inline int skb_cow_head(struct sk_buff *skb, unsigned int headroom)
+	{
+		int delta = 0;
+
+		if (headroom > skb_headroom(skb))
+			delta = headroom - skb_headroom(skb);
+
+		if (delta || skb_header_cloned(skb))
+			return pskb_expand_head(skb, ALIGN(delta, NET_SKB_PAD),
+						0, GFP_ATOMIC);
+		return 0;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	#define ip_hdr(skb_ptr)				(skb_ptr)->nh.iph
+	#define ipv6hdr(skb_ptr)			(skb_ptr)->nh.ipv6h
+
+	static inline void skb_copy_from_linear_data(const struct sk_buff *skb,
+						     void *to,
+						     const unsigned int len)
+	{
+		memcpy(to, skb->data, len);
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+	#define vlan_group_set_device(vlgrp, vid, value) \
+		if (vlgrp) \
+			(vlgrp)->vlan_devices[vid] = value;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+	#define delayed_work				work_struct
+	#define INIT_DELAYED_WORK(a,b)			INIT_WORK(a,b,tp)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	#define CHECKSUM_PARTIAL			CHECKSUM_HW
+
+	static inline void *kmemdup(const void *src, size_t len, gfp_t gfp)
+	{
+		void *p;
+
+		p = kmalloc_track_caller(len, gfp);
+		if (p)
+			memcpy(p, src, len);
+		return p;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	#define skb_is_gso(skb_ptr)			skb_shinfo(skb_ptr)->tso_size
+	#define netdev_alloc_skb(dev, len)		dev_alloc_skb(len)
+	#define IRQF_SHARED				SA_SHIRQ
+
+	static inline struct sk_buff *skb_gso_segment(struct sk_buff *skb, int features)
+	{
+		return NULL;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	#ifndef __LINUX_MUTEX_H
+	#define mutex					semaphore
+	#define mutex_lock				down
+	#define mutex_unlock				up
+	#define mutex_trylock				down_trylock
+	#define mutex_lock_interruptible		down_interruptible
+	#define mutex_init				init_MUTEX
+	#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+	#define ADVERTISED_Pause			(1 << 13)
+	#define ADVERTISED_Asym_Pause			(1 << 14)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
+	#define skb_header_cloned(skb)			skb_cloned(skb)
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24) */
+	static inline void netif_napi_del(struct napi_struct *napi)
+	{
+	#ifdef CONFIG_NETPOLL
+	        list_del(&napi->dev_list);
+	#endif
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0) */
+
+#ifndef FALSE
+	#define TRUE	1
+	#define FALSE	0
+#endif
+
+enum rtl_cmd {
+	RTLTOOL_PLA_OCP_READ_DWORD = 0,
+	RTLTOOL_PLA_OCP_WRITE_DWORD,
+	RTLTOOL_USB_OCP_READ_DWORD,
+	RTLTOOL_USB_OCP_WRITE_DWORD,
+	RTLTOOL_PLA_OCP_READ,
+	RTLTOOL_PLA_OCP_WRITE,
+	RTLTOOL_USB_OCP_READ,
+	RTLTOOL_USB_OCP_WRITE,
+	RTLTOOL_USB_INFO,
+	RTL_ENABLE_USB_DIAG,
+	RTL_DISABLE_USB_DIAG,
+
+	RTLTOOL_INVALID
+};
+
+struct usb_device_info {
+	__u16		idVendor;
+	__u16		idProduct;
+	__u16		bcdDevice;
+	__u8		dev_addr[8];
+	char		devpath[16];
+};
+
+struct rtltool_cmd {
+	__u32	cmd;
+	__u32	offset;
+	__u32	byteen;
+	__u32	data;
+	void	*buf;
+	struct usb_device_info nic_info;
+	struct sockaddr ifru_addr;
+	struct sockaddr ifru_netmask;
+	struct sockaddr ifru_hwaddr;
+};
+
+#endif /* LINUX_COMPATIBILITY_H */
diff --no-dereference -Nru kernel-22/kernel/drivers/net/usb/Kconfig kernel-central/kernel/drivers/net/usb/Kconfig
--- kernel-22/kernel/drivers/net/usb/Kconfig	2017-01-18 12:55:13.000000000 +0200
+++ kernel-central/kernel/drivers/net/usb/Kconfig	2016-12-11 14:28:54.000000000 +0200
@@ -93,6 +93,11 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called rtl8150.
 
+config USB_RTL8152
+	tristate "USB RTL8152 based ethernet device support"
+	select MII
+	default y
+
 config USB_USBNET
 	tristate "Multi-purpose USB Networking Framework"
 	select MII
@@ -131,7 +136,7 @@
 	tristate "ASIX AX88xxx Based USB 2.0 Ethernet Adapters"
 	depends on USB_USBNET
 	select CRC32
-	default y
+	default n
 	help
 	  This option adds support for ASIX AX88xxx based USB 2.0
 	  10/100 Ethernet adapters.
@@ -154,6 +159,12 @@
 	  This driver creates an interface named "ethX", where X depends on
 	  what other networking devices you have in use.
 
+config USB_NET_AX8877X
+	tristate "ASIX AX8877x Based USB 2.0 Ethernet Adapters"
+	depends on USB_USBNET
+	select CRC32
+	default y
+
 config USB_NET_CDCETHER
 	tristate "CDC Ethernet support (smart devices such as cable modems)"
 	depends on USB_USBNET
diff --no-dereference -Nru kernel-22/kernel/drivers/net/usb/Makefile kernel-central/kernel/drivers/net/usb/Makefile
--- kernel-22/kernel/drivers/net/usb/Makefile	2017-01-18 12:55:13.000000000 +0200
+++ kernel-central/kernel/drivers/net/usb/Makefile	2016-12-11 14:24:49.000000000 +0200
@@ -6,8 +6,10 @@
 obj-$(CONFIG_USB_KAWETH)	+= kaweth.o
 obj-$(CONFIG_USB_PEGASUS)	+= pegasus.o
 obj-$(CONFIG_USB_RTL8150)	+= rtl8150.o
+obj-$(CONFIG_USB_RTL8152)	+= r8152.o
 obj-$(CONFIG_USB_HSO)		+= hso.o
 obj-$(CONFIG_USB_NET_AX8817X)	+= asix.o
+obj-$(CONFIG_USB_NET_AX8877X)	+= asix-new.o
 obj-$(CONFIG_USB_NET_CDCETHER)	+= cdc_ether.o
 obj-$(CONFIG_USB_NET_CDC_EEM)	+= cdc_eem.o
 obj-$(CONFIG_USB_NET_DM9601)	+= dm9601.o
diff --no-dereference -Nru kernel-22/kernel/drivers/net/usb/r8152.c kernel-central/kernel/drivers/net/usb/r8152.c
--- kernel-22/kernel/drivers/net/usb/r8152.c	1970-01-01 03:00:00.000000000 +0300
+++ kernel-central/kernel/drivers/net/usb/r8152.c	2016-12-11 14:31:41.000000000 +0200
@@ -0,0 +1,7242 @@
+/*
+ *  Copyright (c) 2016 Realtek Semiconductor Corp. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ */
+
+#include <linux/signal.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/usb.h>
+#include <linux/crc32.h>
+#include <linux/if_vlan.h>
+#include <linux/uaccess.h>
+#include <linux/list.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <net/ip6_checksum.h>
+#include <linux/usb/cdc.h>
+#include <linux/suspend.h>
+
+#include "compatibility.h"
+
+/* Version Information */
+#define DRIVER_VERSION "v2.07.0 (2016/06/14)"
+#define DRIVER_AUTHOR "Realtek nic sw <nic_swsd@realtek.com>"
+#define DRIVER_DESC "Realtek RTL8152/RTL8153 Based USB Ethernet Adapters"
+#define MODULENAME "r8152"
+
+#define PATENTS		"This product is covered by one or more of the " \
+			"following patents:\n" \
+			"\t\tUS6,570,884, US6,115,776, and US6,327,625.\n"
+
+#define R8152_PHY_ID		32
+
+#define PLA_IDR			0xc000
+#define PLA_RCR			0xc010
+#define PLA_RMS			0xc016
+#define PLA_RXFIFO_CTRL0	0xc0a0
+#define PLA_RXFIFO_CTRL1	0xc0a4
+#define PLA_RXFIFO_CTRL2	0xc0a8
+#define PLA_DMY_REG0		0xc0b0
+#define PLA_FMC			0xc0b4
+#define PLA_CFG_WOL		0xc0b6
+#define PLA_TEREDO_CFG		0xc0bc
+#define PLA_MAR			0xcd00
+#define PLA_BACKUP		0xd000
+#define PAL_BDC_CR		0xd1a0
+#define PLA_TEREDO_TIMER	0xd2cc
+#define PLA_REALWOW_TIMER	0xd2e8
+#define PLA_LEDSEL		0xdd90
+#define PLA_LED_FEATURE		0xdd92
+#define PLA_PHYAR		0xde00
+#define PLA_BOOT_CTRL		0xe004
+#define PLA_GPHY_INTR_IMR	0xe022
+#define PLA_EEE_CR		0xe040
+#define PLA_EEEP_CR		0xe080
+#define PLA_MAC_PWR_CTRL	0xe0c0
+#define PLA_MAC_PWR_CTRL2	0xe0ca
+#define PLA_MAC_PWR_CTRL3	0xe0cc
+#define PLA_MAC_PWR_CTRL4	0xe0ce
+#define PLA_WDT6_CTRL		0xe428
+#define PLA_TCR0		0xe610
+#define PLA_TCR1		0xe612
+#define PLA_MTPS		0xe615
+#define PLA_TXFIFO_CTRL		0xe618
+#define PLA_RSTTALLY		0xe800
+#define PLA_CR			0xe813
+#define PLA_CRWECR		0xe81c
+#define PLA_CONFIG12		0xe81e	/* CONFIG1, CONFIG2 */
+#define PLA_CONFIG34		0xe820	/* CONFIG3, CONFIG4 */
+#define PLA_CONFIG5		0xe822
+#define PLA_PHY_PWR		0xe84c
+#define PLA_OOB_CTRL		0xe84f
+#define PLA_CPCR		0xe854
+#define PLA_MISC_0		0xe858
+#define PLA_MISC_1		0xe85a
+#define PLA_OCP_GPHY_BASE	0xe86c
+#define PLA_TALLYCNT		0xe890
+#define PLA_SFF_STS_7		0xe8de
+#define PLA_PHYSTATUS		0xe908
+#define PLA_BP_BA		0xfc26
+#define PLA_BP_0		0xfc28
+#define PLA_BP_1		0xfc2a
+#define PLA_BP_2		0xfc2c
+#define PLA_BP_3		0xfc2e
+#define PLA_BP_4		0xfc30
+#define PLA_BP_5		0xfc32
+#define PLA_BP_6		0xfc34
+#define PLA_BP_7		0xfc36
+#define PLA_BP_EN		0xfc38
+
+#define USB_USB2PHY		0xb41e
+#define USB_SSPHYLINK2		0xb428
+#define USB_U2P3_CTRL		0xb460
+#define USB_CSR_DUMMY1		0xb464
+#define USB_CSR_DUMMY2		0xb466
+#define USB_DEV_STAT		0xb808
+#define USB_CONNECT_TIMER	0xcbf8
+#define USB_BURST_SIZE		0xcfc0
+#define USB_USB_CTRL		0xd406
+#define USB_PHY_CTRL		0xd408
+#define USB_TX_AGG		0xd40a
+#define USB_RX_BUF_TH		0xd40c
+#define USB_USB_TIMER		0xd428
+#define USB_RX_EARLY_TIMEOUT	0xd42c
+#define USB_RX_EARLY_SIZE	0xd42e
+#define USB_PM_CTRL_STATUS	0xd432
+#define USB_TX_DMA		0xd434
+#define USB_TOLERANCE		0xd490
+#define USB_LPM_CTRL		0xd41a
+#define USB_UPS_CTRL		0xd800
+#define USB_MISC_0		0xd81a
+#define USB_POWER_CUT		0xd80a
+#define USB_AFE_CTRL2		0xd824
+#define USB_WDT11_CTRL		0xe43c
+#define USB_BP_BA		0xfc26
+#define USB_BP_0		0xfc28
+#define USB_BP_1		0xfc2a
+#define USB_BP_2		0xfc2c
+#define USB_BP_3		0xfc2e
+#define USB_BP_4		0xfc30
+#define USB_BP_5		0xfc32
+#define USB_BP_6		0xfc34
+#define USB_BP_7		0xfc36
+#define USB_BP_EN		0xfc38
+#define USB_BP_8		0xfc38
+#define USB_BP_9		0xfc3a
+#define USB_BP_10		0xfc3c
+#define USB_BP_11		0xfc3e
+#define USB_BP_12		0xfc40
+#define USB_BP_13		0xfc42
+#define USB_BP_14		0xfc44
+#define USB_BP_15		0xfc46
+#define USB_BP2_EN		0xfc48
+
+/* OCP Registers */
+#define OCP_ALDPS_CONFIG	0x2010
+#define OCP_EEE_CONFIG1		0x2080
+#define OCP_EEE_CONFIG2		0x2092
+#define OCP_EEE_CONFIG3		0x2094
+#define OCP_BASE_MII		0xa400
+#define OCP_EEE_AR		0xa41a
+#define OCP_EEE_DATA		0xa41c
+#define OCP_PHY_STATUS		0xa420
+#define OCP_POWER_CFG		0xa430
+#define OCP_EEE_CFG		0xa432
+#define OCP_SRAM_ADDR		0xa436
+#define OCP_SRAM_DATA		0xa438
+#define OCP_DOWN_SPEED		0xa442
+#define OCP_EEE_ABLE		0xa5c4
+#define OCP_EEE_ADV		0xa5d0
+#define OCP_EEE_LPABLE		0xa5d2
+#define OCP_PHY_STATE		0xa708		/* nway state for 8153 */
+#define OCP_ADC_CFG		0xbc06
+
+/* SRAM Register */
+#define SRAM_LPF_CFG		0x8012
+#define SRAM_10M_AMP1		0x8080
+#define SRAM_10M_AMP2		0x8082
+#define SRAM_IMPEDANCE		0x8084
+
+/* PLA_RCR */
+#define RCR_AAP			0x00000001
+#define RCR_APM			0x00000002
+#define RCR_AM			0x00000004
+#define RCR_AB			0x00000008
+#define RCR_ACPT_ALL		(RCR_AAP | RCR_APM | RCR_AM | RCR_AB)
+
+/* PLA_RXFIFO_CTRL0 */
+#define RXFIFO_THR1_NORMAL	0x00080002
+#define RXFIFO_THR1_OOB		0x01800003
+
+/* PLA_RXFIFO_CTRL1 */
+#define RXFIFO_THR2_FULL	0x00000060
+#define RXFIFO_THR2_HIGH	0x00000038
+#define RXFIFO_THR2_OOB		0x0000004a
+#define RXFIFO_THR2_NORMAL	0x00a0
+
+/* PLA_RXFIFO_CTRL2 */
+#define RXFIFO_THR3_FULL	0x00000078
+#define RXFIFO_THR3_HIGH	0x00000048
+#define RXFIFO_THR3_OOB		0x0000005a
+#define RXFIFO_THR3_NORMAL	0x0110
+
+/* PLA_TXFIFO_CTRL */
+#define TXFIFO_THR_NORMAL	0x00400008
+#define TXFIFO_THR_NORMAL2	0x01000008
+
+/* PLA_DMY_REG0 */
+#define ECM_ALDPS		0x0002
+
+/* PLA_FMC */
+#define FMC_FCR_MCU_EN		0x0001
+
+/* PLA_EEEP_CR */
+#define EEEP_CR_EEEP_TX		0x0002
+
+/* PLA_WDT6_CTRL */
+#define WDT6_SET_MODE		0x0010
+
+/* PLA_TCR0 */
+#define TCR0_TX_EMPTY		0x0800
+#define TCR0_AUTO_FIFO		0x0080
+
+/* PLA_TCR1 */
+#define VERSION_MASK		0x7cf0
+
+/* PLA_MTPS */
+#define MTPS_JUMBO		(12 * 1024 / 64)
+#define MTPS_DEFAULT		(6 * 1024 / 64)
+
+/* PLA_RSTTALLY */
+#define TALLY_RESET		0x0001
+
+/* PLA_CR */
+#define CR_RST			0x10
+#define CR_RE			0x08
+#define CR_TE			0x04
+
+/* PLA_CRWECR */
+#define CRWECR_NORAML		0x00
+#define CRWECR_CONFIG		0xc0
+
+/* PLA_OOB_CTRL */
+#define NOW_IS_OOB		0x80
+#define TXFIFO_EMPTY		0x20
+#define RXFIFO_EMPTY		0x10
+#define LINK_LIST_READY		0x02
+#define DIS_MCU_CLROOB		0x01
+#define FIFO_EMPTY		(TXFIFO_EMPTY | RXFIFO_EMPTY)
+
+/* PLA_MISC_1 */
+#define RXDY_GATED_EN		0x0008
+
+/* PLA_SFF_STS_7 */
+#define RE_INIT_LL		0x8000
+#define MCU_BORW_EN		0x4000
+
+/* PLA_CPCR */
+#define CPCR_RX_VLAN		0x0040
+
+/* PLA_CFG_WOL */
+#define MAGIC_EN		0x0001
+
+/* PLA_TEREDO_CFG */
+#define TEREDO_SEL		0x8000
+#define TEREDO_WAKE_MASK	0x7f00
+#define TEREDO_RS_EVENT_MASK	0x00fe
+#define OOB_TEREDO_EN		0x0001
+
+/* PAL_BDC_CR */
+#define ALDPS_PROXY_MODE	0x0001
+
+/* PLA_CONFIG34 */
+#define LINK_ON_WAKE_EN		0x0010
+#define LINK_OFF_WAKE_EN	0x0008
+
+/* PLA_CONFIG5 */
+#define BWF_EN			0x0040
+#define MWF_EN			0x0020
+#define UWF_EN			0x0010
+#define LAN_WAKE_EN		0x0002
+
+/* PLA_LED_FEATURE */
+#define LED_MODE_MASK		0x0700
+
+/* PLA_PHY_PWR */
+#define TX_10M_IDLE_EN		0x0080
+#define PFM_PWM_SWITCH		0x0040
+
+/* PLA_MAC_PWR_CTRL */
+#define D3_CLK_GATED_EN		0x00004000
+#define MCU_CLK_RATIO		0x07010f07
+#define MCU_CLK_RATIO_MASK	0x0f0f0f0f
+#define ALDPS_SPDWN_RATIO	0x0f87
+
+/* PLA_MAC_PWR_CTRL2 */
+#define EEE_SPDWN_RATIO		0x8007
+
+/* PLA_MAC_PWR_CTRL3 */
+#define PKT_AVAIL_SPDWN_EN	0x0100
+#define SUSPEND_SPDWN_EN	0x0004
+#define U1U2_SPDWN_EN		0x0002
+#define L1_SPDWN_EN		0x0001
+
+/* PLA_MAC_PWR_CTRL4 */
+#define PWRSAVE_SPDWN_EN	0x1000
+#define RXDV_SPDWN_EN		0x0800
+#define TX10MIDLE_EN		0x0100
+#define TP100_SPDWN_EN		0x0020
+#define TP500_SPDWN_EN		0x0010
+#define TP1000_SPDWN_EN		0x0008
+#define EEE_SPDWN_EN		0x0001
+
+/* PLA_GPHY_INTR_IMR */
+#define GPHY_STS_MSK		0x0001
+#define SPEED_DOWN_MSK		0x0002
+#define SPDWN_RXDV_MSK		0x0004
+#define SPDWN_LINKCHG_MSK	0x0008
+
+/* PLA_PHYAR */
+#define PHYAR_FLAG		0x80000000
+
+/* PLA_EEE_CR */
+#define EEE_RX_EN		0x0001
+#define EEE_TX_EN		0x0002
+
+/* PLA_BOOT_CTRL */
+#define AUTOLOAD_DONE		0x0002
+
+/* USB_USB2PHY */
+#define USB2PHY_SUSPEND		0x0001
+#define USB2PHY_L1		0x0002
+
+/* USB_SSPHYLINK2 */
+#define pwd_dn_scale_mask	0x3ffe
+#define pwd_dn_scale(x)		((x) << 1)
+
+/* USB_CSR_DUMMY1 */
+#define DYNAMIC_BURST		0x0001
+
+/* USB_CSR_DUMMY2 */
+#define EP4_FULL_FC		0x0001
+
+/* USB_DEV_STAT */
+#define STAT_SPEED_MASK		0x0006
+#define STAT_SPEED_HIGH		0x0000
+#define STAT_SPEED_FULL		0x0002
+
+/* USB_TX_AGG */
+#define TX_AGG_MAX_THRESHOLD	0x03
+
+/* USB_RX_BUF_TH */
+#define RX_THR_SUPPER		0x0c350180
+#define RX_THR_HIGH		0x7a120180
+#define RX_THR_SLOW		0xffff0180
+
+/* USB_TX_DMA */
+#define TEST_MODE_DISABLE	0x00000001
+#define TX_SIZE_ADJUST1		0x00000100
+
+/* USB_UPS_CTRL */
+#define POWER_CUT		0x0100
+
+/* USB_PM_CTRL_STATUS */
+#define RESUME_INDICATE		0x0001
+
+/* USB_USB_CTRL */
+#define RX_AGG_DISABLE		0x0010
+#define RX_ZERO_EN		0x0080
+
+/* USB_U2P3_CTRL */
+#define U2P3_ENABLE		0x0001
+
+/* USB_POWER_CUT */
+#define PWR_EN			0x0001
+#define PHASE2_EN		0x0008
+
+/* USB_MISC_0 */
+#define PCUT_STATUS		0x0001
+
+/* USB_RX_EARLY_TIMEOUT */
+#define COALESCE_SUPER		 85000U
+#define COALESCE_HIGH		250000U
+#define COALESCE_SLOW		524280U
+
+/* USB_WDT11_CTRL */
+#define TIMER11_EN		0x0001
+
+/* USB_LPM_CTRL */
+/* bit 4 ~ 5: fifo empty boundary */
+#define FIFO_EMPTY_1FB		0x30	/* 0x1fb * 64 = 32448 bytes */
+/* bit 2 ~ 3: LMP timer */
+#define LPM_TIMER_MASK		0x0c
+#define LPM_TIMER_500MS		0x04	/* 500 ms */
+#define LPM_TIMER_500US		0x0c	/* 500 us */
+#define ROK_EXIT_LPM		0x02
+
+/* USB_AFE_CTRL2 */
+#define SEN_VAL_MASK		0xf800
+#define SEN_VAL_NORMAL		0xa000
+#define SEL_RXIDLE		0x0100
+
+/* OCP_ALDPS_CONFIG */
+#define ENPWRSAVE		0x8000
+#define ENPDNPS			0x0200
+#define LINKENA			0x0100
+#define DIS_SDSAVE		0x0010
+
+/* OCP_PHY_STATUS */
+#define PHY_STAT_MASK		0x0007
+#define PHY_STAT_LAN_ON		3
+#define PHY_STAT_PWRDN		5
+
+/* OCP_POWER_CFG */
+#define EEE_CLKDIV_EN		0x8000
+#define EN_ALDPS		0x0004
+#define EN_10M_PLLOFF		0x0001
+
+/* OCP_EEE_CONFIG1 */
+#define RG_TXLPI_MSK_HFDUP	0x8000
+#define RG_MATCLR_EN		0x4000
+#define EEE_10_CAP		0x2000
+#define EEE_NWAY_EN		0x1000
+#define TX_QUIET_EN		0x0200
+#define RX_QUIET_EN		0x0100
+#define sd_rise_time_mask	0x0070
+#define sd_rise_time(x)		(min(x, 7) << 4)	/* bit 4 ~ 6 */
+#define RG_RXLPI_MSK_HFDUP	0x0008
+#define SDFALLTIME		0x0007	/* bit 0 ~ 2 */
+
+/* OCP_EEE_CONFIG2 */
+#define RG_LPIHYS_NUM		0x7000	/* bit 12 ~ 15 */
+#define RG_DACQUIET_EN		0x0400
+#define RG_LDVQUIET_EN		0x0200
+#define RG_CKRSEL		0x0020
+#define RG_EEEPRG_EN		0x0010
+
+/* OCP_EEE_CONFIG3 */
+#define fast_snr_mask		0xff80
+#define fast_snr(x)		(min(x, 0x1ff) << 7)	/* bit 7 ~ 15 */
+#define RG_LFS_SEL		0x0060	/* bit 6 ~ 5 */
+#define MSK_PH			0x0006	/* bit 0 ~ 3 */
+
+/* OCP_EEE_AR */
+/* bit[15:14] function */
+#define FUN_ADDR		0x0000
+#define FUN_DATA		0x4000
+/* bit[4:0] device addr */
+
+/* OCP_EEE_CFG */
+#define CTAP_SHORT_EN		0x0040
+#define EEE10_EN		0x0010
+
+/* OCP_DOWN_SPEED */
+#define EN_10M_BGOFF		0x0080
+
+/* OCP_PHY_STATE */
+#define TXDIS_STATE		0x01
+#define ABD_STATE		0x02
+
+/* OCP_ADC_CFG */
+#define CKADSEL_L		0x0100
+#define ADC_EN			0x0080
+#define EN_EMI_L		0x0040
+
+/* SRAM_LPF_CFG */
+#define LPF_AUTO_TUNE		0x8000
+
+/* SRAM_10M_AMP1 */
+#define GDAC_IB_UPALL		0x0008
+
+/* SRAM_10M_AMP2 */
+#define AMP_DN			0x0200
+
+/* SRAM_IMPEDANCE */
+#define RX_DRIVING_MASK		0x6000
+
+enum rtl_register_content {
+	_1000bps	= 0x10,
+	_100bps		= 0x08,
+	_10bps		= 0x04,
+	LINK_STATUS	= 0x02,
+	FULL_DUP	= 0x01,
+};
+
+#define RTL8152_MAX_TX		4
+#define RTL8152_MAX_RX		10
+#define INTBUFSIZE		2
+#define CRC_SIZE		4
+#define TX_ALIGN		4
+#define RX_ALIGN		8
+
+#define INTR_LINK		0x0004
+
+#define RTL8152_REQT_READ	0xc0
+#define RTL8152_REQT_WRITE	0x40
+#define RTL8152_REQ_GET_REGS	0x05
+#define RTL8152_REQ_SET_REGS	0x05
+
+#define BYTE_EN_DWORD		0xff
+#define BYTE_EN_WORD		0x33
+#define BYTE_EN_BYTE		0x11
+#define BYTE_EN_SIX_BYTES	0x3f
+#define BYTE_EN_START_MASK	0x0f
+#define BYTE_EN_END_MASK	0xf0
+
+#define RTL8153_MAX_PACKET	9216 /* 9K */
+#define RTL8153_MAX_MTU		(RTL8153_MAX_PACKET - VLAN_ETH_HLEN - VLAN_HLEN)
+#define RTL8152_RMS		(VLAN_ETH_FRAME_LEN + VLAN_HLEN)
+#define RTL8153_RMS		RTL8153_MAX_PACKET
+#define RTL8152_TX_TIMEOUT	(5 * HZ)
+#define RTL8152_NAPI_WEIGHT	64
+
+/* rtl8152 flags */
+enum rtl8152_flags {
+	RTL8152_UNPLUG = 0,
+	RTL8152_SET_RX_MODE,
+	WORK_ENABLE,
+	RTL8152_LINK_CHG,
+	SELECTIVE_SUSPEND,
+	PHY_RESET,
+	SCHEDULE_NAPI,
+};
+
+/* Define these values to match your device */
+#define VENDOR_ID_REALTEK		0x0bda
+#define VENDOR_ID_SAMSUNG		0x04e8
+#define VENDOR_ID_LENOVO		0x17ef
+#define VENDOR_ID_TPLINK		0x2357
+#define VENDOR_ID_NVIDIA		0x0955
+
+#define MCU_TYPE_PLA			0x0100
+#define MCU_TYPE_USB			0x0000
+
+struct tally_counter {
+	__le64	tx_packets;
+	__le64	rx_packets;
+	__le64	tx_errors;
+	__le32	rx_errors;
+	__le16	rx_missed;
+	__le16	align_errors;
+	__le32	tx_one_collision;
+	__le32	tx_multi_collision;
+	__le64	rx_unicast;
+	__le64	rx_broadcast;
+	__le32	rx_multicast;
+	__le16	tx_aborted;
+	__le16	tx_underrun;
+};
+
+struct rx_desc {
+	__le32 opts1;
+#define RD_CRC				BIT(15)
+#define RX_LEN_MASK			0x7fff
+
+	__le32 opts2;
+#define RD_UDP_CS			BIT(23)
+#define RD_TCP_CS			BIT(22)
+#define RD_IPV6_CS			BIT(20)
+#define RD_IPV4_CS			BIT(19)
+
+	__le32 opts3;
+#define IPF				BIT(23) /* IP checksum fail */
+#define UDPF				BIT(22) /* UDP checksum fail */
+#define TCPF				BIT(21) /* TCP checksum fail */
+#define RX_VLAN_TAG			BIT(16)
+
+	__le32 opts4;
+	__le32 opts5;
+	__le32 opts6;
+};
+
+struct tx_desc {
+	__le32 opts1;
+#define TX_FS			BIT(31) /* First segment of a packet */
+#define TX_LS			BIT(30) /* Final segment of a packet */
+#define LGSEND			BIT(29)
+#define GTSENDV4		BIT(28)
+#define GTSENDV6		BIT(27)
+#define GTTCPHO_SHIFT		18
+#define GTTCPHO_MAX		0x7fU
+#define TX_LEN_MAX		0x3ffffU
+
+	__le32 opts2;
+#define UDP_CS			BIT(31) /* Calculate UDP/IP checksum */
+#define TCP_CS			BIT(30) /* Calculate TCP/IP checksum */
+#define IPV4_CS			BIT(29) /* Calculate IPv4 checksum */
+#define IPV6_CS			BIT(28) /* Calculate IPv6 checksum */
+#define MSS_SHIFT		17
+#define MSS_MAX			0x7ffU
+#define TCPHO_SHIFT		17
+#define TCPHO_MAX		0x7ffU
+#define TX_VLAN_TAG		BIT(16)
+};
+
+struct r8152;
+
+struct rx_agg {
+	struct list_head list;
+	struct urb *urb;
+	struct r8152 *context;
+	void *buffer;
+	void *head;
+};
+
+struct tx_agg {
+	struct list_head list;
+	struct urb *urb;
+	struct r8152 *context;
+	void *buffer;
+	void *head;
+	u32 skb_num;
+	u32 skb_len;
+};
+
+struct r8152 {
+	unsigned long flags;
+	struct usb_device *udev;
+	struct napi_struct napi;
+	struct usb_interface *intf;
+	struct net_device *netdev;
+	struct urb *intr_urb;
+	struct tx_agg tx_info[RTL8152_MAX_TX];
+	struct rx_agg rx_info[RTL8152_MAX_RX];
+	struct list_head rx_done, tx_free;
+	struct sk_buff_head tx_queue, rx_queue;
+	spinlock_t rx_lock, tx_lock;
+	struct delayed_work schedule, hw_phy_work;
+	struct mii_if_info mii;
+	struct mutex control;	/* use for hw setting */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+	struct vlan_group *vlgrp;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	struct net_device_stats stats;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
+	struct notifier_block pm_notifier;
+#endif
+
+	struct rtl_ops {
+		void (*init)(struct r8152 *);
+		int (*enable)(struct r8152 *);
+		void (*disable)(struct r8152 *);
+		void (*up)(struct r8152 *);
+		void (*down)(struct r8152 *);
+		void (*unload)(struct r8152 *);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		int (*eee_get)(struct r8152 *, struct ethtool_eee *);
+		int (*eee_set)(struct r8152 *, struct ethtool_eee *);
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		bool (*in_nway)(struct r8152 *);
+		void (*aldps_enable)(struct r8152 *tp, bool enable);
+		void (*u1u2_enable)(struct r8152 *tp, bool enable);
+		void (*hw_phy_cfg)(struct r8152 *);
+		void (*power_cut_en)(struct r8152 *tp, bool enable);
+	} rtl_ops;
+
+	int intr_interval;
+	u32 saved_wolopts;
+	u32 msg_enable;
+	u32 tx_qlen;
+	u32 coalesce;
+	u16 ocp_base;
+	u16 speed;
+	u8 *intr_buff;
+	u8 version;
+	u8 rtk_enable_diag;
+	u8 duplex;
+	u8 autoneg;
+};
+
+enum rtl_version {
+	RTL_VER_UNKNOWN = 0,
+	RTL_VER_01,
+	RTL_VER_02,
+	RTL_VER_03,
+	RTL_VER_04,
+	RTL_VER_05,
+	RTL_VER_06,
+	RTL_VER_07,
+	RTL_VER_08,
+	RTL_VER_09,
+	RTL_VER_MAX
+};
+
+enum tx_csum_stat {
+	TX_CSUM_SUCCESS = 0,
+	TX_CSUM_TSO,
+	TX_CSUM_NONE
+};
+
+/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
+ * The RTL chips use a 64 element hash table based on the Ethernet CRC.
+ */
+static const int multicast_filter_limit = 32;
+static unsigned int agg_buf_sz = 16384;
+
+#define RTL_LIMITED_TSO_SIZE	(agg_buf_sz - sizeof(struct tx_desc) - \
+				 VLAN_ETH_HLEN - VLAN_HLEN)
+
+static
+int get_registers(struct r8152 *tp, u16 value, u16 index, u16 size, void *data)
+{
+	int ret;
+	void *tmp;
+
+	tmp = kmalloc(size, GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+
+	ret = usb_control_msg(tp->udev, usb_rcvctrlpipe(tp->udev, 0),
+			      RTL8152_REQ_GET_REGS, RTL8152_REQT_READ,
+			      value, index, tmp, size, 500);
+	if (ret < 0)
+		memset(data, 0xff, size);
+	else
+		memcpy(data, tmp, size);
+
+	kfree(tmp);
+
+	return ret;
+}
+
+static
+int set_registers(struct r8152 *tp, u16 value, u16 index, u16 size, void *data)
+{
+	int ret;
+	void *tmp;
+
+	tmp = kmemdup(data, size, GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+
+	ret = usb_control_msg(tp->udev, usb_sndctrlpipe(tp->udev, 0),
+			      RTL8152_REQ_SET_REGS, RTL8152_REQT_WRITE,
+			      value, index, tmp, size, 500);
+
+	kfree(tmp);
+
+	return ret;
+}
+
+static int generic_ocp_read(struct r8152 *tp, u16 index, u16 size,
+			    void *data, u16 type)
+{
+	u16 limit = 64;
+	int ret = 0;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	/* both size and indix must be 4 bytes align */
+	if ((size & 3) || !size || (index & 3) || !data)
+		return -EPERM;
+
+	if ((u32)index + (u32)size > 0xffff)
+		return -EPERM;
+
+	while (size) {
+		if (size > limit) {
+			ret = get_registers(tp, index, type, limit, data);
+			if (ret < 0)
+				break;
+
+			index += limit;
+			data += limit;
+			size -= limit;
+		} else {
+			ret = get_registers(tp, index, type, size, data);
+			if (ret < 0)
+				break;
+
+			index += size;
+			data += size;
+			size = 0;
+			break;
+		}
+	}
+
+	if (ret == -ENODEV)
+		set_bit(RTL8152_UNPLUG, &tp->flags);
+
+	return ret;
+}
+
+static int generic_ocp_write(struct r8152 *tp, u16 index, u16 byteen,
+			     u16 size, void *data, u16 type)
+{
+	int ret;
+	u16 byteen_start, byteen_end, byen;
+	u16 limit = 512;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	/* both size and indix must be 4 bytes align */
+	if ((size & 3) || !size || (index & 3) || !data)
+		return -EPERM;
+
+	if ((u32)index + (u32)size > 0xffff)
+		return -EPERM;
+
+	byteen_start = byteen & BYTE_EN_START_MASK;
+	byteen_end = byteen & BYTE_EN_END_MASK;
+
+	byen = byteen_start | (byteen_start << 4);
+	ret = set_registers(tp, index, type | byen, 4, data);
+	if (ret < 0)
+		goto error1;
+
+	index += 4;
+	data += 4;
+	size -= 4;
+
+	if (size) {
+		size -= 4;
+
+		while (size) {
+			if (size > limit) {
+				ret = set_registers(tp, index,
+						    type | BYTE_EN_DWORD,
+						    limit, data);
+				if (ret < 0)
+					goto error1;
+
+				index += limit;
+				data += limit;
+				size -= limit;
+			} else {
+				ret = set_registers(tp, index,
+						    type | BYTE_EN_DWORD,
+						    size, data);
+				if (ret < 0)
+					goto error1;
+
+				index += size;
+				data += size;
+				size = 0;
+				break;
+			}
+		}
+
+		byen = byteen_end | (byteen_end >> 4);
+		ret = set_registers(tp, index, type | byen, 4, data);
+		if (ret < 0)
+			goto error1;
+	}
+
+error1:
+	if (ret == -ENODEV)
+		set_bit(RTL8152_UNPLUG, &tp->flags);
+
+	return ret;
+}
+
+static inline
+int pla_ocp_read(struct r8152 *tp, u16 index, u16 size, void *data)
+{
+	return generic_ocp_read(tp, index, size, data, MCU_TYPE_PLA);
+}
+
+static inline
+int pla_ocp_write(struct r8152 *tp, u16 index, u16 byteen, u16 size, void *data)
+{
+	return generic_ocp_write(tp, index, byteen, size, data, MCU_TYPE_PLA);
+}
+
+static inline
+int usb_ocp_read(struct r8152 *tp, u16 index, u16 size, void *data)
+{
+	return generic_ocp_read(tp, index, size, data, MCU_TYPE_USB);
+}
+
+static inline
+int usb_ocp_write(struct r8152 *tp, u16 index, u16 byteen, u16 size, void *data)
+{
+	return generic_ocp_write(tp, index, byteen, size, data, MCU_TYPE_USB);
+}
+
+static u32 ocp_read_dword(struct r8152 *tp, u16 type, u16 index)
+{
+	__le32 data;
+
+	generic_ocp_read(tp, index, sizeof(data), &data, type);
+
+	return __le32_to_cpu(data);
+}
+
+static void ocp_write_dword(struct r8152 *tp, u16 type, u16 index, u32 data)
+{
+	__le32 tmp = __cpu_to_le32(data);
+
+	generic_ocp_write(tp, index, BYTE_EN_DWORD, sizeof(tmp), &tmp, type);
+}
+
+static u16 ocp_read_word(struct r8152 *tp, u16 type, u16 index)
+{
+	u32 data;
+	__le32 tmp;
+	u8 shift = index & 2;
+
+	index &= ~3;
+
+	generic_ocp_read(tp, index, sizeof(tmp), &tmp, type);
+
+	data = __le32_to_cpu(tmp);
+	data >>= (shift * 8);
+	data &= 0xffff;
+
+	return (u16)data;
+}
+
+static void ocp_write_word(struct r8152 *tp, u16 type, u16 index, u32 data)
+{
+	u32 mask = 0xffff;
+	__le32 tmp;
+	u16 byen = BYTE_EN_WORD;
+	u8 shift = index & 2;
+
+	data &= mask;
+
+	if (index & 2) {
+		byen <<= shift;
+		mask <<= (shift * 8);
+		data <<= (shift * 8);
+		index &= ~3;
+	}
+
+	tmp = __cpu_to_le32(data);
+
+	generic_ocp_write(tp, index, byen, sizeof(tmp), &tmp, type);
+}
+
+static u8 ocp_read_byte(struct r8152 *tp, u16 type, u16 index)
+{
+	u32 data;
+	__le32 tmp;
+	u8 shift = index & 3;
+
+	index &= ~3;
+
+	generic_ocp_read(tp, index, sizeof(tmp), &tmp, type);
+
+	data = __le32_to_cpu(tmp);
+	data >>= (shift * 8);
+	data &= 0xff;
+
+	return (u8)data;
+}
+
+static void ocp_write_byte(struct r8152 *tp, u16 type, u16 index, u32 data)
+{
+	u32 mask = 0xff;
+	__le32 tmp;
+	u16 byen = BYTE_EN_BYTE;
+	u8 shift = index & 3;
+
+	data &= mask;
+
+	if (index & 3) {
+		byen <<= shift;
+		mask <<= (shift * 8);
+		data <<= (shift * 8);
+		index &= ~3;
+	}
+
+	tmp = __cpu_to_le32(data);
+
+	generic_ocp_write(tp, index, byen, sizeof(tmp), &tmp, type);
+}
+
+static u16 ocp_reg_read(struct r8152 *tp, u16 addr)
+{
+	u16 ocp_base, ocp_index;
+
+	ocp_base = addr & 0xf000;
+	if (ocp_base != tp->ocp_base) {
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, ocp_base);
+		tp->ocp_base = ocp_base;
+	}
+
+	ocp_index = (addr & 0x0fff) | 0xb000;
+	return ocp_read_word(tp, MCU_TYPE_PLA, ocp_index);
+}
+
+static void ocp_reg_write(struct r8152 *tp, u16 addr, u16 data)
+{
+	u16 ocp_base, ocp_index;
+
+	ocp_base = addr & 0xf000;
+	if (ocp_base != tp->ocp_base) {
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, ocp_base);
+		tp->ocp_base = ocp_base;
+	}
+
+	ocp_index = (addr & 0x0fff) | 0xb000;
+	ocp_write_word(tp, MCU_TYPE_PLA, ocp_index, data);
+}
+
+static inline void r8152_mdio_write(struct r8152 *tp, u32 reg_addr, u32 value)
+{
+	ocp_reg_write(tp, OCP_BASE_MII + reg_addr * 2, value);
+}
+
+static inline int r8152_mdio_read(struct r8152 *tp, u32 reg_addr)
+{
+	return ocp_reg_read(tp, OCP_BASE_MII + reg_addr * 2);
+}
+
+static void sram_write(struct r8152 *tp, u16 addr, u16 data)
+{
+	ocp_reg_write(tp, OCP_SRAM_ADDR, addr);
+	ocp_reg_write(tp, OCP_SRAM_DATA, data);
+}
+
+static u16 sram_read(struct r8152 *tp, u16 addr)
+{
+	ocp_reg_write(tp, OCP_SRAM_ADDR, addr);
+	return ocp_reg_read(tp, OCP_SRAM_DATA);
+}
+
+static int read_mii_word(struct net_device *netdev, int phy_id, int reg)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	if (phy_id != R8152_PHY_ID)
+		return -EINVAL;
+
+	ret = r8152_mdio_read(tp, reg);
+
+	return ret;
+}
+
+static
+void write_mii_word(struct net_device *netdev, int phy_id, int reg, int val)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (phy_id != R8152_PHY_ID)
+		return;
+
+	r8152_mdio_write(tp, reg, val);
+}
+
+static int
+r8152_submit_rx(struct r8152 *tp, struct rx_agg *agg, gfp_t mem_flags);
+
+static int rtl8152_set_mac_address(struct net_device *netdev, void *p)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	struct sockaddr *addr = p;
+	int ret = -EADDRNOTAVAIL;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		goto out1;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out1;
+
+	mutex_lock(&tp->control);
+
+	memcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);
+
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+	pla_ocp_write(tp, PLA_IDR, BYTE_EN_SIX_BYTES, 8, addr->sa_data);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+out1:
+	return ret;
+}
+
+static int set_ethernet_addr(struct r8152 *tp)
+{
+	struct net_device *dev = tp->netdev;
+	struct sockaddr sa;
+	int ret;
+
+	if (tp->version == RTL_VER_01)
+		ret = pla_ocp_read(tp, PLA_IDR, 8, sa.sa_data);
+	else
+		ret = pla_ocp_read(tp, PLA_BACKUP, 8, sa.sa_data);
+
+	if (ret < 0) {
+		netif_err(tp, probe, dev, "Get ether addr fail\n");
+	} else if (!is_valid_ether_addr(sa.sa_data)) {
+		netif_err(tp, probe, dev, "Invalid ether addr %pM\n",
+			  sa.sa_data);
+		eth_hw_addr_random(dev);
+		ether_addr_copy(sa.sa_data, dev->dev_addr);
+		ret = rtl8152_set_mac_address(dev, &sa);
+		netif_info(tp, probe, dev, "Random ether addr %pM\n",
+			   sa.sa_data);
+	} else {
+		if (tp->version == RTL_VER_01)
+			ether_addr_copy(dev->dev_addr, sa.sa_data);
+		else
+			ret = rtl8152_set_mac_address(dev, &sa);
+	}
+
+	return ret;
+}
+
+static inline struct net_device_stats *rtl8152_get_stats(struct net_device *dev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	struct rtl8152 *tp = netdev_priv(dev);
+
+	return (struct net_device_stats *)&tp->stats;
+#else
+	return &dev->stats;
+#endif
+}
+
+static void read_bulk_callback(struct urb *urb)
+{
+	struct net_device *netdev;
+	int status = urb->status;
+	struct rx_agg *agg;
+	struct r8152 *tp;
+
+	agg = urb->context;
+	if (!agg)
+		return;
+
+	tp = agg->context;
+	if (!tp)
+		return;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		return;
+
+	netdev = tp->netdev;
+
+	/* When link down, the driver would cancel all bulks. */
+	/* This avoid the re-submitting bulk */
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	usb_mark_last_busy(tp->udev);
+
+	switch (status) {
+	case 0:
+		if (urb->actual_length < ETH_ZLEN)
+			break;
+
+		spin_lock(&tp->rx_lock);
+		list_add_tail(&agg->list, &tp->rx_done);
+		spin_unlock(&tp->rx_lock);
+		napi_schedule(&tp->napi);
+		return;
+	case -ESHUTDOWN:
+		set_bit(RTL8152_UNPLUG, &tp->flags);
+		netif_device_detach(tp->netdev);
+		return;
+	case -ENOENT:
+		return;	/* the urb is in unlink state */
+	case -ETIME:
+		if (net_ratelimit())
+			netif_warn(tp, rx_err, netdev,
+				   "maybe reset is needed?\n");
+		break;
+	default:
+		if (net_ratelimit())
+			netif_warn(tp, rx_err, netdev,
+				   "Rx status %d\n", status);
+		break;
+	}
+
+	r8152_submit_rx(tp, agg, GFP_ATOMIC);
+}
+
+static void write_bulk_callback(struct urb *urb)
+{
+	struct net_device_stats *stats;
+	struct net_device *netdev;
+	struct tx_agg *agg;
+	struct r8152 *tp;
+	int status = urb->status;
+
+	agg = urb->context;
+	if (!agg)
+		return;
+
+	tp = agg->context;
+	if (!tp)
+		return;
+
+	netdev = tp->netdev;
+	stats = rtl8152_get_stats(netdev);
+	if (status) {
+		if (net_ratelimit())
+			netif_warn(tp, tx_err, netdev,
+				   "Tx status %d\n", status);
+		stats->tx_errors += agg->skb_num;
+	} else {
+		stats->tx_packets += agg->skb_num;
+		stats->tx_bytes += agg->skb_len;
+	}
+
+	spin_lock(&tp->tx_lock);
+	list_add_tail(&agg->list, &tp->tx_free);
+	spin_unlock(&tp->tx_lock);
+
+	usb_autopm_put_interface_async(tp->intf);
+
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		return;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (!skb_queue_empty(&tp->tx_queue))
+		napi_schedule(&tp->napi);
+}
+
+static void intr_callback(struct urb *urb)
+{
+	struct r8152 *tp;
+	__le16 *d;
+	int status = urb->status;
+	int res;
+
+	tp = urb->context;
+	if (!tp)
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		return;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	switch (status) {
+	case 0:			/* success */
+		break;
+	case -ECONNRESET:	/* unlink */
+	case -ESHUTDOWN:
+		netif_device_detach(tp->netdev);
+	case -ENOENT:
+	case -EPROTO:
+		netif_info(tp, intr, tp->netdev,
+			   "Stop submitting intr, status %d\n", status);
+		return;
+	case -EOVERFLOW:
+		netif_info(tp, intr, tp->netdev, "intr status -EOVERFLOW\n");
+		goto resubmit;
+	/* -EPIPE:  should clear the halt */
+	default:
+		netif_info(tp, intr, tp->netdev, "intr status %d\n", status);
+		goto resubmit;
+	}
+
+	d = urb->transfer_buffer;
+	if (INTR_LINK & __le16_to_cpu(d[0])) {
+		if (!netif_carrier_ok(tp->netdev)) {
+			set_bit(RTL8152_LINK_CHG, &tp->flags);
+			schedule_delayed_work(&tp->schedule, 0);
+		}
+	} else {
+		if (netif_carrier_ok(tp->netdev)) {
+			set_bit(RTL8152_LINK_CHG, &tp->flags);
+			schedule_delayed_work(&tp->schedule, 0);
+		}
+	}
+
+resubmit:
+	res = usb_submit_urb(urb, GFP_ATOMIC);
+	if (res == -ENODEV) {
+		set_bit(RTL8152_UNPLUG, &tp->flags);
+		netif_device_detach(tp->netdev);
+	} else if (res) {
+		netif_err(tp, intr, tp->netdev,
+			  "can't resubmit intr, status %d\n", res);
+	}
+}
+
+static inline void *rx_agg_align(void *data)
+{
+	return (void *)ALIGN((uintptr_t)data, RX_ALIGN);
+}
+
+static inline void *tx_agg_align(void *data)
+{
+	return (void *)ALIGN((uintptr_t)data, TX_ALIGN);
+}
+
+static void free_all_mem(struct r8152 *tp)
+{
+	int i;
+
+	for (i = 0; i < RTL8152_MAX_RX; i++) {
+		usb_free_urb(tp->rx_info[i].urb);
+		tp->rx_info[i].urb = NULL;
+
+		kfree(tp->rx_info[i].buffer);
+		tp->rx_info[i].buffer = NULL;
+		tp->rx_info[i].head = NULL;
+	}
+
+	for (i = 0; i < RTL8152_MAX_TX; i++) {
+		usb_free_urb(tp->tx_info[i].urb);
+		tp->tx_info[i].urb = NULL;
+
+		kfree(tp->tx_info[i].buffer);
+		tp->tx_info[i].buffer = NULL;
+		tp->tx_info[i].head = NULL;
+	}
+
+	usb_free_urb(tp->intr_urb);
+	tp->intr_urb = NULL;
+
+	kfree(tp->intr_buff);
+	tp->intr_buff = NULL;
+}
+
+static int alloc_all_mem(struct r8152 *tp)
+{
+	struct net_device *netdev = tp->netdev;
+	struct usb_interface *intf = tp->intf;
+	struct usb_host_interface *alt = intf->cur_altsetting;
+	struct usb_host_endpoint *ep_intr = alt->endpoint + 2;
+	struct urb *urb;
+	int node, i;
+	u8 *buf;
+
+	node = netdev->dev.parent ? dev_to_node(netdev->dev.parent) : -1;
+
+	spin_lock_init(&tp->rx_lock);
+	spin_lock_init(&tp->tx_lock);
+	INIT_LIST_HEAD(&tp->tx_free);
+	skb_queue_head_init(&tp->tx_queue);
+	skb_queue_head_init(&tp->rx_queue);
+
+	for (i = 0; i < RTL8152_MAX_RX; i++) {
+		buf = kmalloc_node(agg_buf_sz, GFP_KERNEL, node);
+		if (!buf)
+			goto err1;
+
+		if (buf != rx_agg_align(buf)) {
+			kfree(buf);
+			buf = kmalloc_node(agg_buf_sz + RX_ALIGN, GFP_KERNEL,
+					   node);
+			if (!buf)
+				goto err1;
+		}
+
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			kfree(buf);
+			goto err1;
+		}
+
+		INIT_LIST_HEAD(&tp->rx_info[i].list);
+		tp->rx_info[i].context = tp;
+		tp->rx_info[i].urb = urb;
+		tp->rx_info[i].buffer = buf;
+		tp->rx_info[i].head = rx_agg_align(buf);
+	}
+
+	for (i = 0; i < RTL8152_MAX_TX; i++) {
+		buf = kmalloc_node(agg_buf_sz, GFP_KERNEL, node);
+		if (!buf)
+			goto err1;
+
+		if (buf != tx_agg_align(buf)) {
+			kfree(buf);
+			buf = kmalloc_node(agg_buf_sz + TX_ALIGN, GFP_KERNEL,
+					   node);
+			if (!buf)
+				goto err1;
+		}
+
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			kfree(buf);
+			goto err1;
+		}
+
+		INIT_LIST_HEAD(&tp->tx_info[i].list);
+		tp->tx_info[i].context = tp;
+		tp->tx_info[i].urb = urb;
+		tp->tx_info[i].buffer = buf;
+		tp->tx_info[i].head = tx_agg_align(buf);
+
+		list_add_tail(&tp->tx_info[i].list, &tp->tx_free);
+	}
+
+	tp->intr_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!tp->intr_urb)
+		goto err1;
+
+	tp->intr_buff = kmalloc(INTBUFSIZE, GFP_KERNEL);
+	if (!tp->intr_buff)
+		goto err1;
+
+	tp->intr_interval = (int)ep_intr->desc.bInterval;
+	usb_fill_int_urb(tp->intr_urb, tp->udev, usb_rcvintpipe(tp->udev, 3),
+			 tp->intr_buff, INTBUFSIZE, intr_callback,
+			 tp, tp->intr_interval);
+
+	return 0;
+
+err1:
+	free_all_mem(tp);
+	return -ENOMEM;
+}
+
+static struct tx_agg *r8152_get_tx_agg(struct r8152 *tp)
+{
+	struct tx_agg *agg = NULL;
+	unsigned long flags;
+
+	if (list_empty(&tp->tx_free))
+		return NULL;
+
+	spin_lock_irqsave(&tp->tx_lock, flags);
+	if (!list_empty(&tp->tx_free)) {
+		struct list_head *cursor;
+
+		cursor = tp->tx_free.next;
+		list_del_init(cursor);
+		agg = list_entry(cursor, struct tx_agg, list);
+	}
+	spin_unlock_irqrestore(&tp->tx_lock, flags);
+
+	return agg;
+}
+
+/* r8152_csum_workaround()
+ * The hw limites the value the transport offset. When the offset is out of the
+ * range, calculate the checksum by sw.
+ */
+static void r8152_csum_workaround(struct r8152 *tp, struct sk_buff *skb,
+				  struct sk_buff_head *list)
+{
+	if (skb_shinfo(skb)->gso_size) {
+		netdev_features_t features = tp->netdev->features;
+		struct sk_buff_head seg_list;
+		struct sk_buff *segs, *nskb;
+
+		features &= ~(NETIF_F_SG | NETIF_F_IPV6_CSUM | NETIF_F_TSO6);
+		segs = skb_gso_segment(skb, features);
+		if (IS_ERR(segs) || !segs)
+			goto drop;
+
+		__skb_queue_head_init(&seg_list);
+
+		do {
+			nskb = segs;
+			segs = segs->next;
+			nskb->next = NULL;
+			__skb_queue_tail(&seg_list, nskb);
+		} while (segs);
+
+		skb_queue_splice(&seg_list, list);
+		dev_kfree_skb(skb);
+	} else if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		if (skb_checksum_help(skb) < 0)
+			goto drop;
+
+		__skb_queue_head(list, skb);
+	} else {
+		struct net_device_stats *stats;
+
+drop:
+		stats = rtl8152_get_stats(tp->netdev);
+		stats->tx_dropped++;
+		dev_kfree_skb(skb);
+	}
+}
+
+/* msdn_giant_send_check()
+ * According to the document of microsoft, the TCP Pseudo Header excludes the
+ * packet length for IPv6 TCP large packets.
+ */
+static int msdn_giant_send_check(struct sk_buff *skb)
+{
+	const struct ipv6hdr *ipv6h;
+	struct tcphdr *th;
+	int ret;
+
+	ret = skb_cow_head(skb, 0);
+	if (ret)
+		return ret;
+
+	ipv6h = ipv6_hdr(skb);
+	th = tcp_hdr(skb);
+
+	th->check = 0;
+	th->check = ~tcp_v6_check(0, &ipv6h->saddr, &ipv6h->daddr, 0);
+
+	return ret;
+}
+
+static inline void rtl_tx_vlan_tag(struct tx_desc *desc, struct sk_buff *skb)
+{
+	if (skb_vlan_tag_present(skb)) {
+		u32 opts2;
+
+		opts2 = TX_VLAN_TAG | swab16(skb_vlan_tag_get(skb));
+		desc->opts2 |= cpu_to_le32(opts2);
+	}
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+static inline bool
+rtl_rx_vlan_tag(struct r8152 *tp, struct rx_desc *desc, struct sk_buff *skb)
+{
+	u32 opts2 = le32_to_cpu(desc->opts2);
+
+	if (tp->vlgrp && (opts2 & RX_VLAN_TAG)) {
+		vlan_gro_receive(&tp->napi, tp->vlgrp, swab16(opts2 & 0xffff),
+				 skb);
+		return true;
+	}
+
+	return false;
+}
+
+static inline void
+rtl_vlan_put_tag(struct r8152 *tp, struct rx_desc *desc, struct sk_buff *skb)
+{
+	u32 opts2 = le32_to_cpu(desc->opts2);
+
+	if (tp->vlgrp && (opts2 & RX_VLAN_TAG))
+		__vlan_hwaccel_put_tag(skb, swab16(opts2 & 0xffff));
+}
+
+static inline __u16
+rtl_vlan_get_tag(struct sk_buff *skb)
+{
+	__u16 tag;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+	__vlan_hwaccel_get_tag(skb, &tag);
+#else
+	tag = skb->vlan_tci;
+#endif
+
+	return tag;
+}
+
+#else
+
+static inline void rtl_rx_vlan_tag(struct rx_desc *desc, struct sk_buff *skb)
+{
+	u32 opts2 = le32_to_cpu(desc->opts2);
+
+	if (opts2 & RX_VLAN_TAG)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+		__vlan_hwaccel_put_tag(skb, swab16(opts2 & 0xffff));
+#else
+		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
+				       swab16(opts2 & 0xffff));
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) */
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+
+static int r8152_tx_csum(struct r8152 *tp, struct tx_desc *desc,
+			 struct sk_buff *skb, u32 len, u32 transport_offset)
+{
+	u32 mss = skb_shinfo(skb)->gso_size;
+	u32 opts1, opts2 = 0;
+	int ret = TX_CSUM_SUCCESS;
+
+	WARN_ON_ONCE(len > TX_LEN_MAX);
+
+	opts1 = len | TX_FS | TX_LS;
+
+	if (mss) {
+		if (transport_offset > GTTCPHO_MAX) {
+			netif_warn(tp, tx_err, tp->netdev,
+				   "Invalid transport offset 0x%x for TSO\n",
+				   transport_offset);
+			ret = TX_CSUM_TSO;
+			goto unavailable;
+		}
+
+		switch (vlan_get_protocol(skb)) {
+		case htons(ETH_P_IP):
+			opts1 |= GTSENDV4;
+			break;
+
+		case htons(ETH_P_IPV6):
+			if (msdn_giant_send_check(skb)) {
+				ret = TX_CSUM_TSO;
+				goto unavailable;
+			}
+			opts1 |= GTSENDV6;
+			break;
+
+		default:
+			WARN_ON_ONCE(1);
+			break;
+		}
+
+		opts1 |= transport_offset << GTTCPHO_SHIFT;
+		opts2 |= min(mss, MSS_MAX) << MSS_SHIFT;
+	} else if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		u8 ip_protocol;
+
+		if (transport_offset > TCPHO_MAX) {
+			netif_warn(tp, tx_err, tp->netdev,
+				   "Invalid transport offset 0x%x\n",
+				   transport_offset);
+			ret = TX_CSUM_NONE;
+			goto unavailable;
+		}
+
+		switch (vlan_get_protocol(skb)) {
+		case htons(ETH_P_IP):
+			opts2 |= IPV4_CS;
+			ip_protocol = ip_hdr(skb)->protocol;
+			break;
+
+		case htons(ETH_P_IPV6):
+			opts2 |= IPV6_CS;
+			ip_protocol = ipv6_hdr(skb)->nexthdr;
+			break;
+
+		default:
+			ip_protocol = IPPROTO_RAW;
+			break;
+		}
+
+		if (ip_protocol == IPPROTO_TCP)
+			opts2 |= TCP_CS;
+		else if (ip_protocol == IPPROTO_UDP)
+			opts2 |= UDP_CS;
+		else
+			WARN_ON_ONCE(1);
+
+		opts2 |= transport_offset << TCPHO_SHIFT;
+	}
+
+	desc->opts2 = cpu_to_le32(opts2);
+	desc->opts1 = cpu_to_le32(opts1);
+
+unavailable:
+	return ret;
+}
+
+static int r8152_tx_agg_fill(struct r8152 *tp, struct tx_agg *agg)
+{
+	struct sk_buff_head skb_head, *tx_queue = &tp->tx_queue;
+	int remain, ret;
+	u8 *tx_data;
+
+	__skb_queue_head_init(&skb_head);
+	spin_lock(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock(&tx_queue->lock);
+
+	tx_data = agg->head;
+	agg->skb_num = 0;
+	agg->skb_len = 0;
+	remain = agg_buf_sz;
+
+	while (remain >= ETH_ZLEN + sizeof(struct tx_desc)) {
+		struct tx_desc *tx_desc;
+		struct sk_buff *skb;
+		unsigned int len;
+		u32 offset;
+
+		skb = __skb_dequeue(&skb_head);
+		if (!skb)
+			break;
+
+		len = skb->len + sizeof(*tx_desc);
+
+		if (len > remain) {
+			__skb_queue_head(&skb_head, skb);
+			break;
+		}
+
+		tx_data = tx_agg_align(tx_data);
+		tx_desc = (struct tx_desc *)tx_data;
+
+		offset = (u32)skb_transport_offset(skb);
+
+		if (r8152_tx_csum(tp, tx_desc, skb, skb->len, offset)) {
+			r8152_csum_workaround(tp, skb, &skb_head);
+			continue;
+		}
+
+		rtl_tx_vlan_tag(tx_desc, skb);
+
+		tx_data += sizeof(*tx_desc);
+
+		len = skb->len;
+		if (skb_copy_bits(skb, 0, tx_data, len) < 0) {
+			struct net_device_stats *stats = &tp->netdev->stats;
+
+			stats->tx_dropped++;
+			dev_kfree_skb_any(skb);
+			tx_data -= sizeof(*tx_desc);
+			continue;
+		}
+
+		tx_data += len;
+		agg->skb_len += len;
+		agg->skb_num++;
+
+		dev_kfree_skb_any(skb);
+
+		remain = agg_buf_sz - (int)(tx_agg_align(tx_data) - agg->head);
+	}
+
+	if (!skb_queue_empty(&skb_head)) {
+		spin_lock(&tx_queue->lock);
+		skb_queue_splice(&skb_head, tx_queue);
+		spin_unlock(&tx_queue->lock);
+	}
+
+	netif_tx_lock(tp->netdev);
+
+	if (netif_queue_stopped(tp->netdev) &&
+	    skb_queue_len(&tp->tx_queue) < tp->tx_qlen)
+		netif_wake_queue(tp->netdev);
+
+	netif_tx_unlock(tp->netdev);
+
+	ret = usb_autopm_get_interface_async(tp->intf);
+	if (ret < 0)
+		goto out_tx_fill;
+
+	usb_fill_bulk_urb(agg->urb, tp->udev, usb_sndbulkpipe(tp->udev, 2),
+			  agg->head, (int)(tx_data - (u8 *)agg->head),
+			  (usb_complete_t)write_bulk_callback, agg);
+
+	ret = usb_submit_urb(agg->urb, GFP_ATOMIC);
+	if (ret < 0)
+		usb_autopm_put_interface_async(tp->intf);
+
+out_tx_fill:
+	return ret;
+}
+
+static u8 r8152_rx_csum(struct r8152 *tp, struct rx_desc *rx_desc)
+{
+	u8 checksum = CHECKSUM_NONE;
+	u32 opts2, opts3;
+
+	if (tp->version == RTL_VER_01)
+		goto return_result;
+
+	opts2 = le32_to_cpu(rx_desc->opts2);
+	opts3 = le32_to_cpu(rx_desc->opts3);
+
+	if (opts2 & RD_IPV4_CS) {
+		if (opts3 & IPF)
+			checksum = CHECKSUM_NONE;
+		else if ((opts2 & RD_UDP_CS) && (opts3 & UDPF))
+			checksum = CHECKSUM_NONE;
+		else if ((opts2 & RD_TCP_CS) && (opts3 & TCPF))
+			checksum = CHECKSUM_NONE;
+		else
+			checksum = CHECKSUM_UNNECESSARY;
+	} else if (RD_IPV6_CS) {
+		if ((opts2 & RD_UDP_CS) && !(opts3 & UDPF))
+			checksum = CHECKSUM_UNNECESSARY;
+		else if ((opts2 & RD_TCP_CS) && !(opts3 & TCPF))
+			checksum = CHECKSUM_UNNECESSARY;
+	}
+
+return_result:
+	return checksum;
+}
+
+static int rx_bottom(struct r8152 *tp, int budget)
+{
+	unsigned long flags;
+	struct list_head *cursor, *next, rx_queue;
+	int ret = 0, work_done = 0;
+
+	if (!skb_queue_empty(&tp->rx_queue)) {
+		while (work_done < budget) {
+			struct sk_buff *skb = __skb_dequeue(&tp->rx_queue);
+			struct net_device *netdev = tp->netdev;
+			struct net_device_stats *stats;
+			unsigned int pkt_len;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+			u16 vlan_tci;
+#endif
+
+			if (!skb)
+				break;
+
+			pkt_len = skb->len;
+			stats = rtl8152_get_stats(netdev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+			vlan_tci = rtl_vlan_get_tag(skb);
+
+			if (vlan_tci)
+				vlan_gro_receive(&tp->napi, tp->vlgrp, vlan_tci,
+						 skb);
+			else
+				napi_gro_receive(&tp->napi, skb);
+#else
+			napi_gro_receive(&tp->napi, skb);
+#endif
+
+			work_done++;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+			netdev->last_rx = jiffies;
+#endif
+			stats->rx_packets++;
+			stats->rx_bytes += pkt_len;
+		}
+	}
+
+	if (list_empty(&tp->rx_done))
+		goto out1;
+
+	INIT_LIST_HEAD(&rx_queue);
+	spin_lock_irqsave(&tp->rx_lock, flags);
+	list_splice_init(&tp->rx_done, &rx_queue);
+	spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+	list_for_each_safe(cursor, next, &rx_queue) {
+		struct rx_desc *rx_desc;
+		struct rx_agg *agg;
+		int len_used = 0;
+		struct urb *urb;
+		u8 *rx_data;
+
+		list_del_init(cursor);
+
+		agg = list_entry(cursor, struct rx_agg, list);
+		urb = agg->urb;
+		if (urb->actual_length < ETH_ZLEN)
+			goto submit;
+
+		rx_desc = agg->head;
+		rx_data = agg->head;
+		len_used += sizeof(struct rx_desc);
+
+		while (urb->actual_length > len_used) {
+			struct net_device *netdev = tp->netdev;
+			struct net_device_stats *stats;
+			unsigned int pkt_len;
+			struct sk_buff *skb;
+
+			pkt_len = le32_to_cpu(rx_desc->opts1) & RX_LEN_MASK;
+			if (pkt_len < ETH_ZLEN)
+				break;
+
+			len_used += pkt_len;
+			if (urb->actual_length < len_used)
+				break;
+
+			stats = rtl8152_get_stats(netdev);
+
+			pkt_len -= CRC_SIZE;
+			rx_data += sizeof(struct rx_desc);
+
+			skb = napi_alloc_skb(&tp->napi, pkt_len);
+			if (!skb) {
+				stats->rx_dropped++;
+				goto find_next_rx;
+			}
+
+			skb->ip_summed = r8152_rx_csum(tp, rx_desc);
+			memcpy(skb->data, rx_data, pkt_len);
+			skb_put(skb, pkt_len);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+			skb->dev = netdev;
+#endif
+			skb->protocol = eth_type_trans(skb, netdev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+			if (work_done < budget) {
+				if (!rtl_rx_vlan_tag(tp, rx_desc, skb))
+					napi_gro_receive(&tp->napi, skb);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+				netdev->last_rx = jiffies;
+#endif
+				work_done++;
+				stats->rx_packets++;
+				stats->rx_bytes += pkt_len;
+			} else {
+				rtl_vlan_put_tag(tp, rx_desc, skb);
+				__skb_queue_tail(&tp->rx_queue, skb);
+			}
+#else
+			rtl_rx_vlan_tag(rx_desc, skb);
+			if (work_done < budget) {
+				napi_gro_receive(&tp->napi, skb);
+				work_done++;
+				stats->rx_packets++;
+				stats->rx_bytes += pkt_len;
+			} else {
+				__skb_queue_tail(&tp->rx_queue, skb);
+			}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+
+find_next_rx:
+			rx_data = rx_agg_align(rx_data + pkt_len + CRC_SIZE);
+			rx_desc = (struct rx_desc *)rx_data;
+			len_used = (int)(rx_data - (u8 *)agg->head);
+			len_used += sizeof(struct rx_desc);
+		}
+
+submit:
+		if (!ret) {
+			ret = r8152_submit_rx(tp, agg, GFP_ATOMIC);
+		} else {
+			urb->actual_length = 0;
+			list_add_tail(&agg->list, next);
+		}
+	}
+
+	if (!list_empty(&rx_queue)) {
+		spin_lock_irqsave(&tp->rx_lock, flags);
+		list_splice_tail(&rx_queue, &tp->rx_done);
+		spin_unlock_irqrestore(&tp->rx_lock, flags);
+	}
+
+out1:
+	return work_done;
+}
+
+static void tx_bottom(struct r8152 *tp)
+{
+	int res;
+
+	do {
+		struct tx_agg *agg;
+
+		if (skb_queue_empty(&tp->tx_queue))
+			break;
+
+		agg = r8152_get_tx_agg(tp);
+		if (!agg)
+			break;
+
+		res = r8152_tx_agg_fill(tp, agg);
+		if (res) {
+			struct net_device *netdev = tp->netdev;
+
+			if (res == -ENODEV) {
+				set_bit(RTL8152_UNPLUG, &tp->flags);
+				netif_device_detach(netdev);
+			} else {
+				struct net_device_stats *stats;
+				unsigned long flags;
+
+				stats = rtl8152_get_stats(netdev);
+				netif_warn(tp, tx_err, netdev,
+					   "failed tx_urb %d\n", res);
+				stats->tx_dropped += agg->skb_num;
+
+				spin_lock_irqsave(&tp->tx_lock, flags);
+				list_add_tail(&agg->list, &tp->tx_free);
+				spin_unlock_irqrestore(&tp->tx_lock, flags);
+			}
+		}
+	} while (res == 0);
+}
+
+static void bottom_half(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		return;
+
+	/* When link down, the driver would cancel all bulks. */
+	/* This avoid the re-submitting bulk */
+	if (!netif_carrier_ok(tp->netdev))
+		return;
+
+	clear_bit(SCHEDULE_NAPI, &tp->flags);
+
+	tx_bottom(tp);
+}
+
+static inline int __r8152_poll(struct r8152 *tp, int budget)
+{
+	struct napi_struct *napi = &tp->napi;
+	int work_done;
+
+	work_done = rx_bottom(tp, budget);
+	bottom_half(tp);
+
+	if (work_done < budget) {
+		napi_complete(napi);
+		if (!list_empty(&tp->rx_done))
+			napi_schedule(napi);
+	}
+
+	return work_done;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+
+static int r8152_poll(struct net_device *dev, int *budget)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	int quota = min(dev->quota, *budget);
+	int work_done;
+
+	work_done = __r8152_poll(tp, quota);
+
+	*budget -= work_done;
+	dev->quota -= work_done;
+
+	return (work_done >= quota);
+}
+
+#else
+
+static int r8152_poll(struct napi_struct *napi, int budget)
+{
+	struct r8152 *tp = container_of(napi, struct r8152, napi);
+
+	return __r8152_poll(tp, budget);
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24) */
+
+static
+int r8152_submit_rx(struct r8152 *tp, struct rx_agg *agg, gfp_t mem_flags)
+{
+	int ret;
+
+	/* The rx would be stopped, so skip submitting */
+	if (test_bit(RTL8152_UNPLUG, &tp->flags) ||
+	    !test_bit(WORK_ENABLE, &tp->flags) || !netif_carrier_ok(tp->netdev))
+		return 0;
+
+	usb_fill_bulk_urb(agg->urb, tp->udev, usb_rcvbulkpipe(tp->udev, 1),
+			  agg->head, agg_buf_sz,
+			  (usb_complete_t)read_bulk_callback, agg);
+
+	ret = usb_submit_urb(agg->urb, mem_flags);
+	if (ret == -ENODEV) {
+		set_bit(RTL8152_UNPLUG, &tp->flags);
+		netif_device_detach(tp->netdev);
+	} else if (ret) {
+		struct urb *urb = agg->urb;
+		unsigned long flags;
+
+		urb->actual_length = 0;
+		spin_lock_irqsave(&tp->rx_lock, flags);
+		list_add_tail(&agg->list, &tp->rx_done);
+		spin_unlock_irqrestore(&tp->rx_lock, flags);
+
+		netif_err(tp, rx_err, tp->netdev,
+			  "Couldn't submit rx[%p], ret = %d\n", agg, ret);
+
+		napi_schedule(&tp->napi);
+	}
+
+	return ret;
+}
+
+static void rtl_drop_queued_tx(struct r8152 *tp)
+{
+	struct net_device_stats *stats = rtl8152_get_stats(tp->netdev);
+	struct sk_buff_head skb_head, *tx_queue = &tp->tx_queue;
+	struct sk_buff *skb;
+
+	if (skb_queue_empty(tx_queue))
+		return;
+
+	__skb_queue_head_init(&skb_head);
+	spin_lock_bh(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock_bh(&tx_queue->lock);
+
+	while ((skb = __skb_dequeue(&skb_head))) {
+		dev_kfree_skb(skb);
+		stats->tx_dropped++;
+	}
+}
+
+static void rtl8152_tx_timeout(struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	int i;
+#endif
+
+	netif_warn(tp, tx_err, netdev, "Tx timeout\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	for (i = 0; i < RTL8152_MAX_TX; i++)
+		usb_unlink_urb(tp->tx_info[i].urb);
+#else
+	usb_queue_reset_device(tp->intf);
+#endif
+}
+
+static void rtl8152_set_rx_mode(struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u32 mc_filter[2];	/* Multicast hash filter */
+	__le32 tmp[2];
+	u32 ocp_data;
+
+	if (in_atomic()) {
+		if (netif_carrier_ok(netdev)) {
+			set_bit(RTL8152_SET_RX_MODE, &tp->flags);
+			schedule_delayed_work(&tp->schedule, 0);
+		}
+		return;
+	}
+
+	clear_bit(RTL8152_SET_RX_MODE, &tp->flags);
+
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	netif_stop_queue(netdev);
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+	ocp_data &= ~RCR_ACPT_ALL;
+	ocp_data |= RCR_AB | RCR_APM;
+
+	if (netdev->flags & IFF_PROMISC) {
+		/* Unconditionally log net taps. */
+		netif_notice(tp, link, netdev, "Promiscuous mode enabled\n");
+		ocp_data |= RCR_AM | RCR_AAP;
+		mc_filter[1] = 0xffffffff;
+		mc_filter[0] = 0xffffffff;
+	} else if ((netdev_mc_count(netdev) > multicast_filter_limit) ||
+		   (netdev->flags & IFF_ALLMULTI)) {
+		/* Too many to filter perfectly -- accept all multicasts. */
+		ocp_data |= RCR_AM;
+		mc_filter[1] = 0xffffffff;
+		mc_filter[0] = 0xffffffff;
+	} else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+		struct dev_mc_list *mclist;
+		unsigned int i;
+
+		mc_filter[1] = mc_filter[0] = 0;
+		for (i = 0, mclist = netdev->mc_list;
+		     mclist && i < netdev->mc_count;
+		     i++, mclist = mclist->next) {
+			int bit_nr;
+
+			bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+			ocp_data |= RCR_AM;
+		}
+#else
+		struct netdev_hw_addr *ha;
+
+		mc_filter[1] = 0;
+		mc_filter[0] = 0;
+		netdev_for_each_mc_addr(ha, netdev) {
+			int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
+
+			mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+			ocp_data |= RCR_AM;
+		}
+#endif
+	}
+
+	tmp[0] = __cpu_to_le32(swab32(mc_filter[1]));
+	tmp[1] = __cpu_to_le32(swab32(mc_filter[0]));
+
+	pla_ocp_write(tp, PLA_MAR, BYTE_EN_DWORD, sizeof(tmp), tmp);
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+	netif_wake_queue(netdev);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4)
+static netdev_features_t
+rtl8152_features_check(struct sk_buff *skb, struct net_device *dev,
+		       netdev_features_t features)
+{
+	u32 mss = skb_shinfo(skb)->gso_size;
+	int max_offset = mss ? GTTCPHO_MAX : TCPHO_MAX;
+	int offset = skb_transport_offset(skb);
+
+	if ((mss || skb->ip_summed == CHECKSUM_PARTIAL) && offset > max_offset)
+		features &= ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);
+	else if ((skb->len + sizeof(struct tx_desc)) > agg_buf_sz)
+		features &= ~NETIF_F_GSO_MASK;
+
+	return features;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4) */
+
+static netdev_tx_t rtl8152_start_xmit(struct sk_buff *skb,
+				      struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,18,4)
+	if (unlikely((skb->len + sizeof(struct tx_desc)) > agg_buf_sz)) {
+		netdev_features_t features = netdev->features;
+		struct sk_buff *segs, *nskb;
+
+		features &= ~(NETIF_F_TSO | NETIF_F_TSO6);
+		segs = skb_gso_segment(skb, features);
+		if (IS_ERR(segs) || !segs)
+			goto free_skb;
+
+		do {
+			nskb = segs;
+			segs = segs->next;
+			nskb->next = NULL;
+			rtl8152_start_xmit(nskb, netdev);
+		} while (segs);
+
+free_skb:
+		dev_kfree_skb_any(skb);
+
+		return NETDEV_TX_OK;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+	netdev->trans_start = jiffies
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31) */
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,18,4) */
+
+	skb_tx_timestamp(skb);
+
+	skb_queue_tail(&tp->tx_queue, skb);
+
+	if (!list_empty(&tp->tx_free)) {
+		if (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {
+			set_bit(SCHEDULE_NAPI, &tp->flags);
+			schedule_delayed_work(&tp->schedule, 0);
+		} else {
+			usb_mark_last_busy(tp->udev);
+			napi_schedule(&tp->napi);
+		}
+	} else if (skb_queue_len(&tp->tx_queue) > tp->tx_qlen) {
+		netif_stop_queue(netdev);
+	}
+
+	return NETDEV_TX_OK;
+}
+
+static void r8152b_reset_packet_filter(struct r8152 *tp)
+{
+	u32	ocp_data;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_FMC);
+	ocp_data &= ~FMC_FCR_MCU_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_FMC, ocp_data);
+	ocp_data |= FMC_FCR_MCU_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_FMC, ocp_data);
+}
+
+static void rtl8152_nic_reset(struct r8152 *tp)
+{
+	int	i;
+
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, CR_RST);
+
+	for (i = 0; i < 1000; i++) {
+		if (!(ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CR) & CR_RST))
+			break;
+		usleep_range(100, 400);
+	}
+}
+
+static void set_tx_qlen(struct r8152 *tp)
+{
+	struct net_device *netdev = tp->netdev;
+
+	tp->tx_qlen = agg_buf_sz / (netdev->mtu + VLAN_ETH_HLEN + VLAN_HLEN +
+				    sizeof(struct tx_desc));
+}
+
+static inline u8 rtl8152_get_speed(struct r8152 *tp)
+{
+	return ocp_read_byte(tp, MCU_TYPE_PLA, PLA_PHYSTATUS);
+}
+
+static void rtl_set_eee_plus(struct r8152 *tp)
+{
+	u32 ocp_data;
+	u8 speed;
+
+	speed = rtl8152_get_speed(tp);
+	if (speed & _10bps) {
+		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEEP_CR);
+		ocp_data |= EEEP_CR_EEEP_TX;
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEEP_CR, ocp_data);
+	} else {
+		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEEP_CR);
+		ocp_data &= ~EEEP_CR_EEEP_TX;
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEEP_CR, ocp_data);
+	}
+}
+
+static void rxdy_gated_en(struct r8152 *tp, bool enable)
+{
+	u32 ocp_data;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MISC_1);
+	if (enable)
+		ocp_data |= RXDY_GATED_EN;
+	else
+		ocp_data &= ~RXDY_GATED_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MISC_1, ocp_data);
+}
+
+static int rtl_s5_wol(struct r8152 *tp)
+{
+#ifdef CONFIG_PM
+	struct usb_device *udev = tp->udev;
+
+	if (!tp->saved_wolopts)
+		return 0;
+
+	/* usb_enable_remote_wakeup */
+	if (udev->speed < USB_SPEED_SUPER)
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
+				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
+				USB_CTRL_SET_TIMEOUT);
+	else
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
+				USB_INTRF_FUNC_SUSPEND,
+				USB_INTRF_FUNC_SUSPEND_RW |
+					USB_INTRF_FUNC_SUSPEND_LP,
+				NULL, 0, USB_CTRL_SET_TIMEOUT);
+#else
+	return 0;
+#endif
+}
+
+static int rtl_start_rx(struct r8152 *tp)
+{
+	int i, ret = 0;
+
+	INIT_LIST_HEAD(&tp->rx_done);
+	for (i = 0; i < RTL8152_MAX_RX; i++) {
+		INIT_LIST_HEAD(&tp->rx_info[i].list);
+		ret = r8152_submit_rx(tp, &tp->rx_info[i], GFP_KERNEL);
+		if (ret)
+			break;
+	}
+
+	if (ret && ++i < RTL8152_MAX_RX) {
+		struct list_head rx_queue;
+		unsigned long flags;
+
+		INIT_LIST_HEAD(&rx_queue);
+
+		do {
+			struct rx_agg *agg = &tp->rx_info[i++];
+			struct urb *urb = agg->urb;
+
+			urb->actual_length = 0;
+			list_add_tail(&agg->list, &rx_queue);
+		} while (i < RTL8152_MAX_RX);
+
+		spin_lock_irqsave(&tp->rx_lock, flags);
+		list_splice_tail(&rx_queue, &tp->rx_done);
+		spin_unlock_irqrestore(&tp->rx_lock, flags);
+	}
+
+	return ret;
+}
+
+static int rtl_stop_rx(struct r8152 *tp)
+{
+	int i;
+
+	for (i = 0; i < RTL8152_MAX_RX; i++)
+		usb_kill_urb(tp->rx_info[i].urb);
+
+	while (!skb_queue_empty(&tp->rx_queue))
+		dev_kfree_skb(__skb_dequeue(&tp->rx_queue));
+
+	return 0;
+}
+
+static int rtl_enable(struct r8152 *tp)
+{
+	u32 ocp_data;
+
+	r8152b_reset_packet_filter(tp);
+
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CR);
+	ocp_data |= CR_RE | CR_TE;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, ocp_data);
+
+	rxdy_gated_en(tp, false);
+
+	return 0;
+}
+
+static int rtl8152_enable(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	set_tx_qlen(tp);
+	rtl_set_eee_plus(tp);
+
+	return rtl_enable(tp);
+}
+
+static void r8153_set_rx_early_timeout(struct r8152 *tp)
+{
+	u32 ocp_data = tp->coalesce / 8;
+
+	ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_TIMEOUT, ocp_data);
+}
+
+static void r8153_set_rx_early_size(struct r8152 *tp)
+{
+	u32 mtu = tp->netdev->mtu;
+	u32 ocp_data = (agg_buf_sz - mtu - VLAN_ETH_HLEN - VLAN_HLEN) / 8;
+
+	ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_SIZE, ocp_data);
+}
+
+static int rtl8153_enable(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+//	usb_disable_lpm(tp->udev);
+	set_tx_qlen(tp);
+	rtl_set_eee_plus(tp);
+	switch (tp->version) {
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		r8153_set_rx_early_timeout(tp);
+		r8153_set_rx_early_size(tp);
+		break;
+
+	case RTL_VER_08:
+	case RTL_VER_09:
+	default:
+		ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, 0x00010001);
+		ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_EARLY_TIMEOUT,
+				0x07410010);
+		ocp_write_dword(tp, MCU_TYPE_USB, 0xd430, 0x07530000);
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xd437, 0x03);
+		break;
+	}
+
+	return rtl_enable(tp);
+}
+
+static void rtl_disable(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		return;
+	}
+
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+	ocp_data &= ~RCR_ACPT_ALL;
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+
+	rtl_drop_queued_tx(tp);
+
+	for (i = 0; i < RTL8152_MAX_TX; i++)
+		usb_kill_urb(tp->tx_info[i].urb);
+
+	rxdy_gated_en(tp, true);
+
+	for (i = 0; i < 1000; i++) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+		if ((ocp_data & FIFO_EMPTY) == FIFO_EMPTY)
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	for (i = 0; i < 1000; i++) {
+		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0) & TCR0_TX_EMPTY)
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	rtl_stop_rx(tp);
+
+	rtl8152_nic_reset(tp);
+}
+
+static void r8152_power_cut_en(struct r8152 *tp, bool enable)
+{
+	u32 ocp_data;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_UPS_CTRL);
+	if (enable)
+		ocp_data |= POWER_CUT;
+	else
+		ocp_data &= ~POWER_CUT;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_UPS_CTRL, ocp_data);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_PM_CTRL_STATUS);
+	ocp_data &= ~RESUME_INDICATE;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_PM_CTRL_STATUS, ocp_data);
+}
+
+static void rtl_rx_vlan_en(struct r8152 *tp, bool enable)
+{
+	u32 ocp_data;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CPCR);
+	if (enable)
+		ocp_data |= CPCR_RX_VLAN;
+	else
+		ocp_data &= ~CPCR_RX_VLAN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_CPCR, ocp_data);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+static void
+rtl8152_vlan_rx_register(struct net_device *dev, struct vlan_group *grp)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	if (unlikely(tp->rtk_enable_diag))
+		return;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	mutex_lock(&tp->control);
+
+	tp->vlgrp = grp;
+	if (tp->vlgrp)
+		rtl_rx_vlan_en(tp, true);
+	else
+		rtl_rx_vlan_en(tp, false);
+
+	mutex_unlock(&tp->control);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+
+static void rtl8152_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	vlan_group_set_device(tp->vlgrp, vid, NULL);
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
+
+#else
+
+static int rtl8152_set_features(struct net_device *dev,
+				netdev_features_t features)
+{
+	netdev_features_t changed = features ^ dev->features;
+	struct r8152 *tp = netdev_priv(dev);
+	int ret;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	mutex_lock(&tp->control);
+
+	if (changed & NETIF_F_HW_VLAN_CTAG_RX) {
+		if (features & NETIF_F_HW_VLAN_CTAG_RX)
+			rtl_rx_vlan_en(tp, true);
+		else
+			rtl_rx_vlan_en(tp, false);
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+
+#define WAKE_ANY (WAKE_PHY | WAKE_MAGIC | WAKE_UCAST | WAKE_BCAST | WAKE_MCAST)
+
+static u32 __rtl_get_wol(struct r8152 *tp)
+{
+	u32 ocp_data;
+	u32 wolopts = 0;
+
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_CONFIG5);
+	if (!(ocp_data & LAN_WAKE_EN))
+		return 0;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);
+	if (ocp_data & LINK_ON_WAKE_EN)
+		wolopts |= WAKE_PHY;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5);
+	if (ocp_data & UWF_EN)
+		wolopts |= WAKE_UCAST;
+	if (ocp_data & BWF_EN)
+		wolopts |= WAKE_BCAST;
+	if (ocp_data & MWF_EN)
+		wolopts |= WAKE_MCAST;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CFG_WOL);
+	if (ocp_data & MAGIC_EN)
+		wolopts |= WAKE_MAGIC;
+
+	return wolopts;
+}
+
+static void __rtl_set_wol(struct r8152 *tp, u32 wolopts)
+{
+	u32 ocp_data;
+
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);
+	ocp_data &= ~LINK_ON_WAKE_EN;
+	if (wolopts & WAKE_PHY)
+		ocp_data |= LINK_ON_WAKE_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG5);
+	ocp_data &= ~(UWF_EN | BWF_EN | MWF_EN | LAN_WAKE_EN);
+	if (wolopts & WAKE_UCAST)
+		ocp_data |= UWF_EN;
+	if (wolopts & WAKE_BCAST)
+		ocp_data |= BWF_EN;
+	if (wolopts & WAKE_MCAST)
+		ocp_data |= MWF_EN;
+	if (wolopts & WAKE_ANY)
+		ocp_data |= LAN_WAKE_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG5, ocp_data);
+
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CFG_WOL);
+	ocp_data &= ~MAGIC_EN;
+	if (wolopts & WAKE_MAGIC)
+		ocp_data |= MAGIC_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_CFG_WOL, ocp_data);
+
+	if (wolopts & WAKE_ANY)
+		device_set_wakeup_enable(&tp->udev->dev, true);
+	else
+		device_set_wakeup_enable(&tp->udev->dev, false);
+}
+
+static void r8153_u1u2en(struct r8152 *tp, bool enable)
+{
+	u8 u1u2[8];
+
+	if (enable)
+		memset(u1u2, 0xff, sizeof(u1u2));
+	else
+		memset(u1u2, 0x00, sizeof(u1u2));
+
+	usb_ocp_write(tp, USB_TOLERANCE, BYTE_EN_SIX_BYTES, sizeof(u1u2), u1u2);
+}
+
+static void r8153b_u1u2en(struct r8152 *tp, bool enable)
+{
+	u32 ocp_data;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xcfd8);
+	if (enable)
+		ocp_data |= 0x0001;
+	else
+		ocp_data &= ~0x0001;
+
+	ocp_write_word(tp, MCU_TYPE_USB, 0xcfd8, ocp_data);
+}
+
+static void r8153_u2p3en(struct r8152 *tp, bool enable)
+{
+	u32 ocp_data;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_U2P3_CTRL);
+	if (enable && tp->version != RTL_VER_03 && tp->version != RTL_VER_04)
+		ocp_data |= U2P3_ENABLE;
+	else
+		ocp_data &= ~U2P3_ENABLE;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_U2P3_CTRL, ocp_data);
+}
+
+static void r8153B_power_cut_en(struct r8152 *tp, bool enable)
+{
+	u32 ocp_data;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_POWER_CUT);
+	if (enable)
+		ocp_data |= PWR_EN | PHASE2_EN;
+	else
+		ocp_data &= ~(PWR_EN | PHASE2_EN);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);
+}
+
+static void r8153A_power_cut_en(struct r8152 *tp, bool enable)
+{
+	u32 ocp_data;
+
+	r8153B_power_cut_en(tp, enable);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);
+	ocp_data &= ~PCUT_STATUS;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);
+}
+
+static void r8153b_ups_en(struct r8152 *tp, bool enable)
+{
+	u32 ocp_data;
+
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, 0xd80a);
+	if (enable) {
+		ocp_data &= ~0x3f;
+		ocp_data |= 0x10;
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xd80a, ocp_data);
+	} else {
+		ocp_data &= ~0x30;
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xd80a, ocp_data);
+
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);
+		ocp_data &= ~PCUT_STATUS;
+		ocp_write_word(tp, MCU_TYPE_USB, USB_MISC_0, ocp_data);
+	}
+}
+
+static bool rtl_can_wakeup(struct r8152 *tp)
+{
+	struct usb_device *udev = tp->udev;
+
+	return (udev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_WAKEUP);
+}
+
+static void rtl_runtime_suspend_enable(struct r8152 *tp, bool enable)
+{
+	if (enable) {
+		u32 ocp_data;
+
+		tp->rtl_ops.u1u2_enable(tp, false);
+		r8153_u2p3en(tp, false);
+
+		__rtl_set_wol(tp, WAKE_ANY);
+
+		ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_CONFIG);
+
+		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_CONFIG34);
+		ocp_data |= LINK_OFF_WAKE_EN;
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_CONFIG34, ocp_data);
+
+		ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+
+		switch (tp->version) {
+		case RTL_VER_01:
+		case RTL_VER_02:
+		case RTL_VER_03:
+		case RTL_VER_04:
+		case RTL_VER_05:
+		case RTL_VER_06:
+		case RTL_VER_07:
+			break;
+
+		case RTL_VER_08:
+		case RTL_VER_09:
+		default:
+			r8153b_ups_en(tp, true);
+			break;
+		}
+	} else {
+		switch (tp->version) {
+		case RTL_VER_01:
+		case RTL_VER_02:
+		case RTL_VER_03:
+		case RTL_VER_04:
+		case RTL_VER_05:
+		case RTL_VER_06:
+		case RTL_VER_07:
+			break;
+
+		case RTL_VER_08:
+		case RTL_VER_09:
+		default:
+			r8153b_ups_en(tp, false);
+			break;
+		}
+
+		__rtl_set_wol(tp, tp->saved_wolopts);
+		r8153_u2p3en(tp, true);
+		tp->rtl_ops.u1u2_enable(tp, true);
+	}
+}
+
+#if !defined(CONFIG_MII) && !defined(CONFIG_MII_MODULE)
+int mii_nway_restart (struct mii_if_info *mii)
+{
+	struct r8152 *tp = netdev_priv(mii->dev);
+	int r = -EINVAL;
+	int bmcr;
+
+	/* if autoneg is off, it's an error */
+	bmcr = r8152_mdio_read(tp, MII_BMCR);
+
+	if (bmcr & BMCR_ANENABLE) {
+		bmcr |= BMCR_ANRESTART;
+		r8152_mdio_write(tp, MII_BMCR, bmcr);
+		r = 0;
+	}
+
+	return r;
+}
+#endif
+
+static void r8153_teredo_off(struct r8152 *tp)
+{
+	u32 ocp_data;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_07:
+		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG);
+		ocp_data &= ~(TEREDO_SEL | TEREDO_RS_EVENT_MASK | OOB_TEREDO_EN);
+		break;
+
+	case RTL_VER_08:
+	case RTL_VER_09:
+	default:
+		ocp_data = 0x00ff;
+		break;
+	}
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG, ocp_data);
+
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_WDT6_CTRL, WDT6_SET_MODE);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_REALWOW_TIMER, 0);
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_TEREDO_TIMER, 0);
+}
+
+static void rtl_reset_bmu(struct r8152 *tp)
+{
+	u32 ocp_data;
+
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, 0xd4b0);
+	ocp_data &= ~3;
+	ocp_write_byte(tp, MCU_TYPE_USB, 0xd4b0, ocp_data);
+	ocp_data |= 3;
+	ocp_write_byte(tp, MCU_TYPE_USB, 0xd4b0, ocp_data);
+}
+
+static void rtl_clear_bp(struct r8152 *tp)
+{
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_BP_0, 0);
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_BP_2, 0);
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_BP_4, 0);
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_BP_6, 0);
+	ocp_write_dword(tp, MCU_TYPE_USB, USB_BP_0, 0);
+	ocp_write_dword(tp, MCU_TYPE_USB, USB_BP_2, 0);
+	ocp_write_dword(tp, MCU_TYPE_USB, USB_BP_4, 0);
+	ocp_write_dword(tp, MCU_TYPE_USB, USB_BP_6, 0);
+	usleep_range(3000, 6000);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_BA, 0);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_BP_BA, 0);
+}
+
+static void r8153_clear_bp(struct r8152 *tp)
+{
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_BP_EN, 0);
+	ocp_write_byte(tp, MCU_TYPE_USB, USB_BP_EN, 0);
+	rtl_clear_bp(tp);
+}
+
+/*
+static void r8153b_clear_bp(struct r8152 *tp, u16 type)
+{
+	if (type == MCU_TYPE_PLA)
+		ocp_write_byte(tp, MCU_TYPE_PLA, PLA_BP_EN, 0);
+	else
+		ocp_write_byte(tp, MCU_TYPE_USB, USB_BP2_EN, 0);
+
+	ocp_write_word(tp, type, PLA_BP_0, 0);
+	ocp_write_word(tp, type, PLA_BP_1, 0);
+	ocp_write_word(tp, type, PLA_BP_2, 0);
+	ocp_write_word(tp, type, PLA_BP_3, 0);
+	ocp_write_word(tp, type, PLA_BP_4, 0);
+	ocp_write_word(tp, type, PLA_BP_5, 0);
+	ocp_write_word(tp, type, PLA_BP_6, 0);
+	ocp_write_word(tp, type, PLA_BP_7, 0);
+
+	if (type == MCU_TYPE_USB) {
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_8, 0);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_9, 0);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_10, 0);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_11, 0);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_12, 0);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_13, 0);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_14, 0);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_15, 0);
+	}
+	usleep_range(3000, 6000);
+	ocp_write_word(tp, type, PLA_BP_BA, 0);
+}
+*/
+
+static void patch4(struct r8152 *tp)
+{
+	u8 data;
+
+	data = ocp_read_byte(tp, MCU_TYPE_USB, 0xd429);
+	data |= 0x80;
+	ocp_write_byte(tp, MCU_TYPE_USB, 0xd429, data);
+	ocp_write_word(tp, MCU_TYPE_USB, 0xc0ce, 0x0210);
+	data = ocp_read_byte(tp, MCU_TYPE_USB, 0xd429);
+	data &= ~0x80;
+	ocp_write_byte(tp, MCU_TYPE_USB, 0xd429, data);
+}
+
+static void r8152b_firmware(struct r8152 *tp)
+{
+	if (tp->version == RTL_VER_01) {
+		int i;
+		static u8 pla_patch_a[] = {
+			0x08, 0xe0, 0x40, 0xe0,
+			0x78, 0xe0, 0x85, 0xe0,
+			0x5d, 0xe1, 0xa1, 0xe1,
+			0xa3, 0xe1, 0xab, 0xe1,
+			0x31, 0xc3, 0x60, 0x72,
+			0xa0, 0x49, 0x10, 0xf0,
+			0xa4, 0x49, 0x0e, 0xf0,
+			0x2c, 0xc3, 0x62, 0x72,
+			0x26, 0x70, 0x80, 0x49,
+			0x05, 0xf0, 0x2f, 0x48,
+			0x62, 0x9a, 0x24, 0x70,
+			0x60, 0x98, 0x24, 0xc3,
+			0x60, 0x99, 0x23, 0xc3,
+			0x00, 0xbb, 0x2c, 0x75,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x04, 0x13, 0x0a, 0xf0,
+			0x03, 0x13, 0x08, 0xf0,
+			0x02, 0x13, 0x06, 0xf0,
+			0x01, 0x13, 0x04, 0xf0,
+			0x08, 0x13, 0x02, 0xf0,
+			0x03, 0xe0, 0xd4, 0x49,
+			0x04, 0xf1, 0x14, 0xc2,
+			0x12, 0xc3, 0x00, 0xbb,
+			0x12, 0xc3, 0x60, 0x75,
+			0xd0, 0x49, 0x05, 0xf1,
+			0x50, 0x48, 0x60, 0x9d,
+			0x09, 0xc6, 0x00, 0xbe,
+			0xd0, 0x48, 0x60, 0x9d,
+			0xf3, 0xe7, 0xc2, 0xc0,
+			0x38, 0xd2, 0xc6, 0xd2,
+			0x84, 0x17, 0xa2, 0x13,
+			0x0c, 0x17, 0xbc, 0xc0,
+			0xa2, 0xd1, 0x33, 0xc5,
+			0xa0, 0x74, 0xc0, 0x49,
+			0x1f, 0xf0, 0x30, 0xc5,
+			0xa0, 0x73, 0x00, 0x13,
+			0x04, 0xf1, 0xa2, 0x73,
+			0x00, 0x13, 0x14, 0xf0,
+			0x28, 0xc5, 0xa0, 0x74,
+			0xc8, 0x49, 0x1b, 0xf1,
+			0x26, 0xc5, 0xa0, 0x76,
+			0xa2, 0x74, 0x01, 0x06,
+			0x20, 0x37, 0xa0, 0x9e,
+			0xa2, 0x9c, 0x1e, 0xc5,
+			0xa2, 0x73, 0x23, 0x40,
+			0x10, 0xf8, 0x04, 0xf3,
+			0xa0, 0x73, 0x33, 0x40,
+			0x0c, 0xf8, 0x15, 0xc5,
+			0xa0, 0x74, 0x41, 0x48,
+			0xa0, 0x9c, 0x14, 0xc5,
+			0xa0, 0x76, 0x62, 0x48,
+			0xe0, 0x48, 0xa0, 0x9e,
+			0x10, 0xc6, 0x00, 0xbe,
+			0x0a, 0xc5, 0xa0, 0x74,
+			0x48, 0x48, 0xa0, 0x9c,
+			0x0b, 0xc5, 0x20, 0x1e,
+			0xa0, 0x9e, 0xe5, 0x48,
+			0xa0, 0x9e, 0xf0, 0xe7,
+			0xbc, 0xc0, 0xc8, 0xd2,
+			0xcc, 0xd2, 0x28, 0xe4,
+			0x22, 0x02, 0xf0, 0xc0,
+			0x0b, 0xc0, 0x00, 0x71,
+			0x0a, 0xc0, 0x00, 0x72,
+			0xa0, 0x49, 0x04, 0xf0,
+			0xa4, 0x49, 0x02, 0xf0,
+			0x93, 0x48, 0x04, 0xc0,
+			0x00, 0xb8, 0x00, 0xe4,
+			0xc2, 0xc0, 0x8c, 0x09,
+			0x14, 0xc2, 0x40, 0x73,
+			0xba, 0x48, 0x40, 0x9b,
+			0x11, 0xc2, 0x40, 0x73,
+			0xb0, 0x49, 0x17, 0xf0,
+			0xbf, 0x49, 0x03, 0xf1,
+			0x09, 0xc5, 0x00, 0xbd,
+			0xb1, 0x49, 0x11, 0xf0,
+			0xb1, 0x48, 0x40, 0x9b,
+			0x02, 0xc2, 0x00, 0xba,
+			0x82, 0x18, 0x00, 0xa0,
+			0x1e, 0xfc, 0xbc, 0xc0,
+			0xf0, 0xc0, 0xde, 0xe8,
+			0x00, 0x80, 0x00, 0x60,
+			0x2c, 0x75, 0xd4, 0x49,
+			0x12, 0xf1, 0x29, 0xe0,
+			0xf8, 0xc2, 0x46, 0x71,
+			0xf7, 0xc2, 0x40, 0x73,
+			0xbe, 0x49, 0x03, 0xf1,
+			0xf5, 0xc7, 0x02, 0xe0,
+			0xf2, 0xc7, 0x4f, 0x30,
+			0x26, 0x62, 0xa1, 0x49,
+			0xf0, 0xf1, 0x22, 0x72,
+			0xa0, 0x49, 0xed, 0xf1,
+			0x25, 0x25, 0x18, 0x1f,
+			0x97, 0x30, 0x91, 0x30,
+			0x36, 0x9a, 0x2c, 0x75,
+			0x32, 0xc3, 0x60, 0x73,
+			0xb1, 0x49, 0x0d, 0xf1,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x27, 0xc6, 0xc0, 0x77,
+			0x04, 0x13, 0x18, 0xf0,
+			0x03, 0x13, 0x19, 0xf0,
+			0x02, 0x13, 0x1a, 0xf0,
+			0x01, 0x13, 0x1b, 0xf0,
+			0xd4, 0x49, 0x03, 0xf1,
+			0x1c, 0xc5, 0x00, 0xbd,
+			0xcd, 0xc6, 0xc6, 0x67,
+			0x2e, 0x75, 0xd7, 0x22,
+			0xdd, 0x26, 0x05, 0x15,
+			0x1a, 0xf0, 0x14, 0xc6,
+			0x00, 0xbe, 0x13, 0xc5,
+			0x00, 0xbd, 0x12, 0xc5,
+			0x00, 0xbd, 0xf1, 0x49,
+			0xfb, 0xf1, 0xef, 0xe7,
+			0xf4, 0x49, 0xfa, 0xf1,
+			0xec, 0xe7, 0xf3, 0x49,
+			0xf7, 0xf1, 0xe9, 0xe7,
+			0xf2, 0x49, 0xf4, 0xf1,
+			0xe6, 0xe7, 0xb6, 0xc0,
+			0x6a, 0x14, 0xac, 0x13,
+			0xd6, 0x13, 0xfa, 0x14,
+			0xa0, 0xd1, 0x00, 0x00,
+			0xc0, 0x75, 0xd0, 0x49,
+			0x46, 0xf0, 0x26, 0x72,
+			0xa7, 0x49, 0x43, 0xf0,
+			0x22, 0x72, 0x25, 0x25,
+			0x20, 0x1f, 0x97, 0x30,
+			0x91, 0x30, 0x40, 0x73,
+			0xf3, 0xc4, 0x1c, 0x40,
+			0x04, 0xf0, 0xd7, 0x49,
+			0x05, 0xf1, 0x37, 0xe0,
+			0x53, 0x48, 0xc0, 0x9d,
+			0x08, 0x02, 0x40, 0x66,
+			0x64, 0x27, 0x06, 0x16,
+			0x30, 0xf1, 0x46, 0x63,
+			0x3b, 0x13, 0x2d, 0xf1,
+			0x34, 0x9b, 0x18, 0x1b,
+			0x93, 0x30, 0x2b, 0xc3,
+			0x10, 0x1c, 0x2b, 0xe8,
+			0x01, 0x14, 0x25, 0xf1,
+			0x00, 0x1d, 0x26, 0x1a,
+			0x8a, 0x30, 0x22, 0x73,
+			0xb5, 0x25, 0x0e, 0x0b,
+			0x00, 0x1c, 0x2c, 0xe8,
+			0x1f, 0xc7, 0x27, 0x40,
+			0x1a, 0xf1, 0x38, 0xe8,
+			0x32, 0x1f, 0x8f, 0x30,
+			0x08, 0x1b, 0x24, 0xe8,
+			0x36, 0x72, 0x46, 0x77,
+			0x00, 0x17, 0x0d, 0xf0,
+			0x13, 0xc3, 0x1f, 0x40,
+			0x03, 0xf1, 0x00, 0x1f,
+			0x46, 0x9f, 0x44, 0x77,
+			0x9f, 0x44, 0x5f, 0x44,
+			0x17, 0xe8, 0x0a, 0xc7,
+			0x27, 0x40, 0x05, 0xf1,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x50, 0x1a, 0x06, 0x1a,
+			0xff, 0xc7, 0x00, 0xbf,
+			0xb8, 0xcd, 0xff, 0xff,
+			0x02, 0x0c, 0x54, 0xa5,
+			0xdc, 0xa5, 0x2f, 0x40,
+			0x05, 0xf1, 0x00, 0x14,
+			0xfa, 0xf1, 0x01, 0x1c,
+			0x02, 0xe0, 0x00, 0x1c,
+			0x80, 0xff, 0xb0, 0x49,
+			0x04, 0xf0, 0x01, 0x0b,
+			0xd3, 0xa1, 0x03, 0xe0,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x00, 0x13, 0xfb, 0xf1,
+			0x80, 0xff, 0x22, 0x73,
+			0xb5, 0x25, 0x18, 0x1e,
+			0xde, 0x30, 0xd9, 0x30,
+			0x64, 0x72, 0x11, 0x1e,
+			0x68, 0x23, 0x16, 0x31,
+			0x80, 0xff, 0xd4, 0x49,
+			0x28, 0xf0, 0x02, 0xb4,
+			0x2a, 0xc4, 0x00, 0x1d,
+			0x2e, 0xe8, 0xe0, 0x73,
+			0xb9, 0x21, 0xbd, 0x25,
+			0x04, 0x13, 0x02, 0xf0,
+			0x1a, 0xe0, 0x22, 0xc4,
+			0x23, 0xc3, 0x2f, 0xe8,
+			0x23, 0xc3, 0x2d, 0xe8,
+			0x00, 0x1d, 0x21, 0xe8,
+			0xe2, 0x73, 0xbb, 0x49,
+			0xfc, 0xf0, 0xe0, 0x73,
+			0xb7, 0x48, 0x03, 0xb4,
+			0x81, 0x1d, 0x19, 0xe8,
+			0x40, 0x1a, 0x84, 0x1d,
+			0x16, 0xe8, 0x12, 0xc3,
+			0x1e, 0xe8, 0x03, 0xb0,
+			0x81, 0x1d, 0x11, 0xe8,
+			0x0e, 0xc3, 0x19, 0xe8,
+			0x02, 0xb0, 0x06, 0xc7,
+			0x04, 0x1e, 0xe0, 0x9e,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x22, 0x02, 0x20, 0xe4,
+			0x04, 0xb8, 0x34, 0xb0,
+			0x00, 0x02, 0x00, 0x03,
+			0x00, 0x0e, 0x00, 0x0c,
+			0x09, 0xc7, 0xe0, 0x9b,
+			0xe2, 0x9a, 0xe4, 0x9c,
+			0xe6, 0x8d, 0xe6, 0x76,
+			0xef, 0x49, 0xfe, 0xf1,
+			0x80, 0xff, 0x08, 0xea,
+			0x82, 0x1d, 0xf5, 0xef,
+			0x00, 0x1a, 0x88, 0x1d,
+			0xf2, 0xef, 0xed, 0xc2,
+			0xf0, 0xef, 0x80, 0xff,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x46, 0x06, 0x08, 0xc2,
+			0x40, 0x73, 0x3a, 0x48,
+			0x40, 0x9b, 0x06, 0xff,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x86, 0x17, 0x1e, 0xfc,
+			0x36, 0xf0, 0x08, 0x1c,
+			0xea, 0x8c, 0xe3, 0x64,
+			0xc7, 0x49, 0x25, 0xf1,
+			0xe0, 0x75, 0xff, 0x1b,
+			0xeb, 0x47, 0xff, 0x1b,
+			0x6b, 0x47, 0xe0, 0x9d,
+			0x15, 0xc3, 0x60, 0x75,
+			0xd8, 0x49, 0x04, 0xf0,
+			0x81, 0x1d, 0xe2, 0x8d,
+			0x05, 0xe0, 0xe2, 0x63,
+			0x81, 0x1d, 0xdd, 0x47,
+			0xe2, 0x8b, 0x0b, 0xc3,
+			0x00, 0x1d, 0x61, 0x8d,
+			0x3c, 0x03, 0x60, 0x75,
+			0xd8, 0x49, 0x06, 0xf1,
+			0xdf, 0x48, 0x61, 0x95,
+			0x16, 0xe0, 0x4e, 0xe8,
+			0x12, 0xe8, 0x21, 0xc5,
+			0xa0, 0x73, 0xb0, 0x49,
+			0x03, 0xf0, 0x31, 0x48,
+			0xa0, 0x9b, 0x0d, 0xe0,
+			0xc0, 0x49, 0x0b, 0xf1,
+			0xe2, 0x63, 0x7e, 0x1d,
+			0xdd, 0x46, 0xe2, 0x8b,
+			0xe0, 0x75, 0x83, 0x1b,
+			0xeb, 0x46, 0xfe, 0x1b,
+			0x6b, 0x46, 0xe0, 0x9d,
+			0xe4, 0x49, 0x11, 0xf0,
+			0x10, 0x1d, 0xea, 0x8d,
+			0xe3, 0x64, 0xc6, 0x49,
+			0x09, 0xf1, 0x07, 0xc5,
+			0xa0, 0x73, 0xb1, 0x48,
+			0xa0, 0x9b, 0x02, 0xc5,
+			0x00, 0xbd, 0xe6, 0x04,
+			0xa0, 0xd1, 0x02, 0xc5,
+			0x00, 0xbd, 0xfe, 0x04,
+			0x02, 0xc5, 0x00, 0xbd,
+			0x30, 0x05, 0x00, 0x00 };
+		static u16 ram_code1[] = {
+			0x9700, 0x7fe0, 0x4c00, 0x4007,
+			0x4400, 0x4800, 0x7c1f, 0x4c00,
+			0x5310, 0x6000, 0x7c07, 0x6800,
+			0x673e, 0x0000, 0x0000, 0x571f,
+			0x5ffb, 0xaa05, 0x5b58, 0x7d80,
+			0x6100, 0x3019, 0x5b64, 0x7d80,
+			0x6080, 0xa6f8, 0xdcdb, 0x0015,
+			0xb915, 0xb511, 0xd16b, 0x000f,
+			0xb40f, 0xd06b, 0x000d, 0xb206,
+			0x7c01, 0x5800, 0x7c04, 0x5c00,
+			0x3011, 0x7c01, 0x5801, 0x7c04,
+			0x5c04, 0x3019, 0x30a5, 0x3127,
+			0x31d5, 0x7fe0, 0x4c60, 0x7c07,
+			0x6803, 0x7d00, 0x6900, 0x65a0,
+			0x0000, 0x0000, 0xaf03, 0x6015,
+			0x303e, 0x6017, 0x57e0, 0x580c,
+			0x588c, 0x7fdd, 0x5fa2, 0x4827,
+			0x7c1f, 0x4c00, 0x7c1f, 0x4c10,
+			0x8400, 0x7c30, 0x6020, 0x48bf,
+			0x7c1f, 0x4c00, 0x7c1f, 0x4c01,
+			0x7c07, 0x6803, 0xb806, 0x7c08,
+			0x6800, 0x0000, 0x0000, 0x305c,
+			0x7c08, 0x6808, 0x0000, 0x0000,
+			0xae06, 0x7c02, 0x5c02, 0x0000,
+			0x0000, 0x3067, 0x8e05, 0x7c02,
+			0x5c00, 0x0000, 0x0000, 0xad06,
+			0x7c20, 0x5c20, 0x0000, 0x0000,
+			0x3072, 0x8d05, 0x7c20, 0x5c00,
+			0x0000, 0x0000, 0xa008, 0x7c07,
+			0x6800, 0xb8db, 0x7c07, 0x6803,
+			0xd9b3, 0x00d7, 0x7fe0, 0x4c80,
+			0x7c08, 0x6800, 0x0000, 0x0000,
+			0x7c23, 0x5c23, 0x481d, 0x7c1f,
+			0x4c00, 0x7c1f, 0x4c02, 0x5310,
+			0x81ff, 0x30f5, 0x7fe0, 0x4d00,
+			0x4832, 0x7c1f, 0x4c00, 0x7c1f,
+			0x4c10, 0x7c08, 0x6000, 0xa49e,
+			0x7c07, 0x6800, 0xb89b, 0x7c07,
+			0x6803, 0xd9b3, 0x00f9, 0x7fe0,
+			0x4d20, 0x7e00, 0x6200, 0x3001,
+			0x7fe0, 0x4dc0, 0xd09d, 0x0002,
+			0xb4fe, 0x7fe0, 0x4d80, 0x7c04,
+			0x6004, 0x7c07, 0x6802, 0x6728,
+			0x0000, 0x0000, 0x7c08, 0x6000,
+			0x486c, 0x7c1f, 0x4c00, 0x7c1f,
+			0x4c01, 0x9503, 0x7e00, 0x6200,
+			0x571f, 0x5fbb, 0xaa05, 0x5b58,
+			0x7d80, 0x6100, 0x30c2, 0x5b64,
+			0x7d80, 0x6080, 0xcdab, 0x0063,
+			0xcd8d, 0x0061, 0xd96b, 0x005f,
+			0xd0a0, 0x00d7, 0xcba0, 0x0003,
+			0x80ec, 0x30cf, 0x30dc, 0x7fe0,
+			0x4ce0, 0x4832, 0x7c1f, 0x4c00,
+			0x7c1f, 0x4c08, 0x7c08, 0x6008,
+			0x8300, 0xb902, 0x30a5, 0x308a,
+			0x7fe0, 0x4da0, 0x65a8, 0x0000,
+			0x0000, 0x56a0, 0x590c, 0x7ffd,
+			0x5fa2, 0xae06, 0x7c02, 0x5c02,
+			0x0000, 0x0000, 0x30f0, 0x8e05,
+			0x7c02, 0x5c00, 0x0000, 0x0000,
+			0xcba4, 0x0004, 0xcd8d, 0x0002,
+			0x80f1, 0x7fe0, 0x4ca0, 0x7c08,
+			0x6408, 0x0000, 0x0000, 0x7d00,
+			0x6800, 0xb603, 0x7c10, 0x6010,
+			0x7d1f, 0x551f, 0x5fb3, 0xaa07,
+			0x7c80, 0x5800, 0x5b58, 0x7d80,
+			0x6100, 0x310f, 0x7c80, 0x5800,
+			0x5b64, 0x7d80, 0x6080, 0x4827,
+			0x7c1f, 0x4c00, 0x7c1f, 0x4c10,
+			0x8400, 0x7c10, 0x6000, 0x7fe0,
+			0x4cc0, 0x5fbb, 0x4824, 0x7c1f,
+			0x4c00, 0x7c1f, 0x4c04, 0x8200,
+			0x7ce0, 0x5400, 0x6728, 0x0000,
+			0x0000, 0x30cf, 0x3001, 0x7fe0,
+			0x4e00, 0x4007, 0x4400, 0x5310,
+			0x7c07, 0x6800, 0x673e, 0x0000,
+			0x0000, 0x570f, 0x5fff, 0xaa05,
+			0x585b, 0x7d80, 0x6100, 0x313b,
+			0x5867, 0x7d80, 0x6080, 0x9403,
+			0x7e00, 0x6200, 0xcda3, 0x00e7,
+			0xcd85, 0x00e5, 0xd96b, 0x00e3,
+			0x96e3, 0x7c07, 0x6800, 0x673e,
+			0x0000, 0x0000, 0x7fe0, 0x4e20,
+			0x96db, 0x8b04, 0x7c08, 0x5008,
+			0xab03, 0x7c08, 0x5000, 0x7c07,
+			0x6801, 0x677e, 0x0000, 0x0000,
+			0xdb7c, 0x00ec, 0x0000, 0x7fe1,
+			0x4f40, 0x4837, 0x4418, 0x41c7,
+			0x7fe0, 0x4e40, 0x7c40, 0x5400,
+			0x7c1f, 0x4c01, 0x7c1f, 0x4c01,
+			0x8fbf, 0xd2a0, 0x004b, 0x9204,
+			0xa042, 0x3168, 0x3127, 0x7fe1,
+			0x4f60, 0x489c, 0x4628, 0x7fe0,
+			0x4e60, 0x7e28, 0x4628, 0x7c40,
+			0x5400, 0x7c01, 0x5800, 0x7c04,
+			0x5c00, 0x41e8, 0x7c1f, 0x4c01,
+			0x7c1f, 0x4c01, 0x8fa5, 0xb241,
+			0xa02a, 0x3182, 0x7fe0, 0x4ea0,
+			0x7c02, 0x4402, 0x4448, 0x4894,
+			0x7c1f, 0x4c01, 0x7c1f, 0x4c03,
+			0x4824, 0x7c1f, 0x4c07, 0x41ef,
+			0x41ff, 0x4891, 0x7c1f, 0x4c07,
+			0x7c1f, 0x4c17, 0x8400, 0x8ef8,
+			0x41c7, 0x8f8a, 0x92d5, 0xa10f,
+			0xd480, 0x0008, 0xd580, 0x00b8,
+			0xa202, 0x319d, 0x7c04, 0x4404,
+			0x319d, 0xd484, 0x00f3, 0xd484,
+			0x00f1, 0x3127, 0x7fe0, 0x4ee0,
+			0x7c40, 0x5400, 0x4488, 0x41cf,
+			0x3127, 0x7fe0, 0x4ec0, 0x48f3,
+			0x7c1f, 0x4c01, 0x7c1f, 0x4c09,
+			0x4508, 0x41c7, 0x8fb0, 0xd218,
+			0x00ae, 0xd2a4, 0x009e, 0x31be,
+			0x7fe0, 0x4e80, 0x4832, 0x7c1f,
+			0x4c01, 0x7c1f, 0x4c11, 0x4428,
+			0x7c40, 0x5440, 0x7c01, 0x5801,
+			0x7c04, 0x5c04, 0x41e8, 0xa4b3,
+			0x31d3, 0x7fe0, 0x4f20, 0x7c07,
+			0x6800, 0x673e, 0x0000, 0x0000,
+			0x570f, 0x5fff, 0xaa04, 0x585b,
+			0x6100, 0x31e4, 0x5867, 0x6080,
+			0xbcf1, 0x3001 };
+
+		patch4(tp);
+		rtl_clear_bp(tp);
+
+		generic_ocp_write(tp, 0xf800, 0x3f, sizeof(pla_patch_a),
+				  pla_patch_a, MCU_TYPE_PLA);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x170b);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x01e1);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x0989);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x1349);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc30, 0x01b7);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc32, 0x061d);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xe422, 0x0020);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xe420, 0x0018);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc34, 0x1785);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc36, 0x047b);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, 0x2000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb092, 0x7070);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb098, 0x0600);
+		for (i = 0; i < ARRAY_SIZE(ram_code1); i++)
+			ocp_write_word(tp, MCU_TYPE_PLA, 0xb09a, ram_code1[i]);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb098, 0x0200);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb092, 0x7030);
+	} else if (tp->version == RTL_VER_02) {
+		static u8 pla_patch_a2[] = {
+			0x08, 0xe0, 0x1a, 0xe0,
+			0xf2, 0xe0, 0xfa, 0xe0,
+			0x32, 0xe1, 0x34, 0xe1,
+			0x36, 0xe1, 0x38, 0xe1,
+			0x2c, 0x75, 0xdc, 0x21,
+			0xbc, 0x25, 0x04, 0x13,
+			0x0b, 0xf0, 0x03, 0x13,
+			0x09, 0xf0, 0x02, 0x13,
+			0x07, 0xf0, 0x01, 0x13,
+			0x05, 0xf0, 0x08, 0x13,
+			0x03, 0xf0, 0x04, 0xc3,
+			0x00, 0xbb, 0x03, 0xc3,
+			0x00, 0xbb, 0xd2, 0x17,
+			0xbc, 0x17, 0x14, 0xc2,
+			0x40, 0x73, 0xba, 0x48,
+			0x40, 0x9b, 0x11, 0xc2,
+			0x40, 0x73, 0xb0, 0x49,
+			0x17, 0xf0, 0xbf, 0x49,
+			0x03, 0xf1, 0x09, 0xc5,
+			0x00, 0xbd, 0xb1, 0x49,
+			0x11, 0xf0, 0xb1, 0x48,
+			0x40, 0x9b, 0x02, 0xc2,
+			0x00, 0xba, 0x4e, 0x19,
+			0x00, 0xa0, 0x1e, 0xfc,
+			0xbc, 0xc0, 0xf0, 0xc0,
+			0xde, 0xe8, 0x00, 0x80,
+			0x00, 0x60, 0x2c, 0x75,
+			0xd4, 0x49, 0x12, 0xf1,
+			0x29, 0xe0, 0xf8, 0xc2,
+			0x46, 0x71, 0xf7, 0xc2,
+			0x40, 0x73, 0xbe, 0x49,
+			0x03, 0xf1, 0xf5, 0xc7,
+			0x02, 0xe0, 0xf2, 0xc7,
+			0x4f, 0x30, 0x26, 0x62,
+			0xa1, 0x49, 0xf0, 0xf1,
+			0x22, 0x72, 0xa0, 0x49,
+			0xed, 0xf1, 0x25, 0x25,
+			0x18, 0x1f, 0x97, 0x30,
+			0x91, 0x30, 0x36, 0x9a,
+			0x2c, 0x75, 0x32, 0xc3,
+			0x60, 0x73, 0xb1, 0x49,
+			0x0d, 0xf1, 0xdc, 0x21,
+			0xbc, 0x25, 0x27, 0xc6,
+			0xc0, 0x77, 0x04, 0x13,
+			0x18, 0xf0, 0x03, 0x13,
+			0x19, 0xf0, 0x02, 0x13,
+			0x1a, 0xf0, 0x01, 0x13,
+			0x1b, 0xf0, 0xd4, 0x49,
+			0x03, 0xf1, 0x1c, 0xc5,
+			0x00, 0xbd, 0xcd, 0xc6,
+			0xc6, 0x67, 0x2e, 0x75,
+			0xd7, 0x22, 0xdd, 0x26,
+			0x05, 0x15, 0x1a, 0xf0,
+			0x14, 0xc6, 0x00, 0xbe,
+			0x13, 0xc5, 0x00, 0xbd,
+			0x12, 0xc5, 0x00, 0xbd,
+			0xf1, 0x49, 0xfb, 0xf1,
+			0xef, 0xe7, 0xf4, 0x49,
+			0xfa, 0xf1, 0xec, 0xe7,
+			0xf3, 0x49, 0xf7, 0xf1,
+			0xe9, 0xe7, 0xf2, 0x49,
+			0xf4, 0xf1, 0xe6, 0xe7,
+			0xb6, 0xc0, 0xf6, 0x14,
+			0x36, 0x14, 0x62, 0x14,
+			0x86, 0x15, 0xa0, 0xd1,
+			0x00, 0x00, 0xc0, 0x75,
+			0xd0, 0x49, 0x46, 0xf0,
+			0x26, 0x72, 0xa7, 0x49,
+			0x43, 0xf0, 0x22, 0x72,
+			0x25, 0x25, 0x20, 0x1f,
+			0x97, 0x30, 0x91, 0x30,
+			0x40, 0x73, 0xf3, 0xc4,
+			0x1c, 0x40, 0x04, 0xf0,
+			0xd7, 0x49, 0x05, 0xf1,
+			0x37, 0xe0, 0x53, 0x48,
+			0xc0, 0x9d, 0x08, 0x02,
+			0x40, 0x66, 0x64, 0x27,
+			0x06, 0x16, 0x30, 0xf1,
+			0x46, 0x63, 0x3b, 0x13,
+			0x2d, 0xf1, 0x34, 0x9b,
+			0x18, 0x1b, 0x93, 0x30,
+			0x2b, 0xc3, 0x10, 0x1c,
+			0x2b, 0xe8, 0x01, 0x14,
+			0x25, 0xf1, 0x00, 0x1d,
+			0x26, 0x1a, 0x8a, 0x30,
+			0x22, 0x73, 0xb5, 0x25,
+			0x0e, 0x0b, 0x00, 0x1c,
+			0x2c, 0xe8, 0x1f, 0xc7,
+			0x27, 0x40, 0x1a, 0xf1,
+			0x38, 0xe8, 0x32, 0x1f,
+			0x8f, 0x30, 0x08, 0x1b,
+			0x24, 0xe8, 0x36, 0x72,
+			0x46, 0x77, 0x00, 0x17,
+			0x0d, 0xf0, 0x13, 0xc3,
+			0x1f, 0x40, 0x03, 0xf1,
+			0x00, 0x1f, 0x46, 0x9f,
+			0x44, 0x77, 0x9f, 0x44,
+			0x5f, 0x44, 0x17, 0xe8,
+			0x0a, 0xc7, 0x27, 0x40,
+			0x05, 0xf1, 0x02, 0xc3,
+			0x00, 0xbb, 0x1c, 0x1b,
+			0xd2, 0x1a, 0xff, 0xc7,
+			0x00, 0xbf, 0xb8, 0xcd,
+			0xff, 0xff, 0x02, 0x0c,
+			0x54, 0xa5, 0xdc, 0xa5,
+			0x2f, 0x40, 0x05, 0xf1,
+			0x00, 0x14, 0xfa, 0xf1,
+			0x01, 0x1c, 0x02, 0xe0,
+			0x00, 0x1c, 0x80, 0xff,
+			0xb0, 0x49, 0x04, 0xf0,
+			0x01, 0x0b, 0xd3, 0xa1,
+			0x03, 0xe0, 0x02, 0x0b,
+			0xd3, 0xa5, 0x27, 0x31,
+			0x20, 0x37, 0x02, 0x0b,
+			0xd3, 0xa5, 0x27, 0x31,
+			0x20, 0x37, 0x00, 0x13,
+			0xfb, 0xf1, 0x80, 0xff,
+			0x22, 0x73, 0xb5, 0x25,
+			0x18, 0x1e, 0xde, 0x30,
+			0xd9, 0x30, 0x64, 0x72,
+			0x11, 0x1e, 0x68, 0x23,
+			0x16, 0x31, 0x80, 0xff,
+			0x08, 0xc2, 0x40, 0x73,
+			0x3a, 0x48, 0x40, 0x9b,
+			0x06, 0xff, 0x02, 0xc6,
+			0x00, 0xbe, 0x4e, 0x18,
+			0x1e, 0xfc, 0x33, 0xc5,
+			0xa0, 0x74, 0xc0, 0x49,
+			0x1f, 0xf0, 0x30, 0xc5,
+			0xa0, 0x73, 0x00, 0x13,
+			0x04, 0xf1, 0xa2, 0x73,
+			0x00, 0x13, 0x14, 0xf0,
+			0x28, 0xc5, 0xa0, 0x74,
+			0xc8, 0x49, 0x1b, 0xf1,
+			0x26, 0xc5, 0xa0, 0x76,
+			0xa2, 0x74, 0x01, 0x06,
+			0x20, 0x37, 0xa0, 0x9e,
+			0xa2, 0x9c, 0x1e, 0xc5,
+			0xa2, 0x73, 0x23, 0x40,
+			0x10, 0xf8, 0x04, 0xf3,
+			0xa0, 0x73, 0x33, 0x40,
+			0x0c, 0xf8, 0x15, 0xc5,
+			0xa0, 0x74, 0x41, 0x48,
+			0xa0, 0x9c, 0x14, 0xc5,
+			0xa0, 0x76, 0x62, 0x48,
+			0xe0, 0x48, 0xa0, 0x9e,
+			0x10, 0xc6, 0x00, 0xbe,
+			0x0a, 0xc5, 0xa0, 0x74,
+			0x48, 0x48, 0xa0, 0x9c,
+			0x0b, 0xc5, 0x20, 0x1e,
+			0xa0, 0x9e, 0xe5, 0x48,
+			0xa0, 0x9e, 0xf0, 0xe7,
+			0xbc, 0xc0, 0xc8, 0xd2,
+			0xcc, 0xd2, 0x28, 0xe4,
+			0x22, 0x02, 0xf0, 0xc0,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00,
+			0x00, 0x00, 0x00, 0x00 };
+
+		rtl_clear_bp(tp);
+
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch_a2),
+				  pla_patch_a2, MCU_TYPE_PLA);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x17a5);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x13ad);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x184d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x01e1);
+	}
+}
+
+static void r8152_aldps_en(struct r8152 *tp, bool enable)
+{
+	if (enable) {
+		ocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPWRSAVE | ENPDNPS |
+						    LINKENA | DIS_SDSAVE);
+	} else {
+		ocp_reg_write(tp, OCP_ALDPS_CONFIG, ENPDNPS | LINKENA |
+						    DIS_SDSAVE);
+		msleep(20);
+	}
+}
+
+static void rtl8152_disable(struct r8152 *tp)
+{
+	r8152_aldps_en(tp, false);
+	rtl_disable(tp);
+	r8152_aldps_en(tp, true);
+}
+
+static void r8152b_hw_phy_cfg(struct r8152 *tp)
+{
+	u16 data;
+
+	data = r8152_mdio_read(tp, MII_BMCR);
+	if (data & BMCR_PDOWN) {
+		data &= ~BMCR_PDOWN;
+		r8152_mdio_write(tp, MII_BMCR, data);
+	}
+
+	r8152b_firmware(tp);
+
+	set_bit(PHY_RESET, &tp->flags);
+}
+
+static void r8152b_exit_oob(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i;
+
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+	ocp_data &= ~RCR_ACPT_ALL;
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+
+	rxdy_gated_en(tp, true);
+	r8153_teredo_off(tp);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CRWECR, CRWECR_NORAML);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_CR, 0x00);
+
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data &= ~NOW_IS_OOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+	ocp_data &= ~MCU_BORW_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+
+	for (i = 0; i < 1000; i++) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+		if (ocp_data & LINK_LIST_READY)
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+	ocp_data |= RE_INIT_LL;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+
+	for (i = 0; i < 1000; i++) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+		if (ocp_data & LINK_LIST_READY)
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	rtl8152_nic_reset(tp);
+
+	/* rx share fifo credit full threshold */
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_NORMAL);
+
+	if (tp->udev->speed == USB_SPEED_FULL ||
+	    tp->udev->speed == USB_SPEED_LOW) {
+		/* rx share fifo credit near full threshold */
+		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,
+				RXFIFO_THR2_FULL);
+		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,
+				RXFIFO_THR3_FULL);
+	} else {
+		/* rx share fifo credit near full threshold */
+		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1,
+				RXFIFO_THR2_HIGH);
+		ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2,
+				RXFIFO_THR3_HIGH);
+	}
+
+	/* TX share fifo free credit full threshold */
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, TXFIFO_THR_NORMAL);
+
+	ocp_write_byte(tp, MCU_TYPE_USB, USB_TX_AGG, TX_AGG_MAX_THRESHOLD);
+	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_HIGH);
+	ocp_write_dword(tp, MCU_TYPE_USB, USB_TX_DMA,
+			TEST_MODE_DISABLE | TX_SIZE_ADJUST1);
+
+	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0);
+	ocp_data |= TCR0_AUTO_FIFO;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR0, ocp_data);
+}
+
+static void r8152b_enter_oob(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i;
+
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data &= ~NOW_IS_OOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_OOB);
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_OOB);
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_OOB);
+
+	rtl_disable(tp);
+
+	for (i = 0; i < 1000; i++) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+		if (ocp_data & LINK_LIST_READY)
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+	ocp_data |= RE_INIT_LL;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+
+	for (i = 0; i < 1000; i++) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+		if (ocp_data & LINK_LIST_READY)
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, RTL8152_RMS);
+
+	rtl_rx_vlan_en(tp, true);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PAL_BDC_CR);
+	ocp_data |= ALDPS_PROXY_MODE;
+	ocp_write_word(tp, MCU_TYPE_PLA, PAL_BDC_CR, ocp_data);
+
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data |= NOW_IS_OOB | DIS_MCU_CLROOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+
+	rxdy_gated_en(tp, false);
+
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+	ocp_data |= RCR_APM | RCR_AM | RCR_AB;
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+}
+
+static int r8153_patch_request(struct r8152 *tp, bool request)
+{
+	u16 data;
+	int i;
+
+	data = ocp_reg_read(tp, 0xb820);
+	if (request)
+		data |= 0x0010;
+	else
+		data &= ~0x0010;
+	ocp_reg_write(tp, 0xb820, data);
+
+	for (i = 0; request && i < 5000; i++) {
+		usleep_range(1000, 2000);
+		if (ocp_reg_read(tp, 0xb800) & 0x0040)
+			break;
+	}
+
+	if (request && !(ocp_reg_read(tp, 0xb800) & 0x0040)) {
+		netif_err(tp, drv, tp->netdev, "patch request fail\n");
+		r8153_patch_request(tp, false);
+		return -ETIME;
+	} else {
+		return 0;
+	}
+}
+
+static int r8153_pre_ram_code(struct r8152 *tp, u16 key_addr, u16 patch_key)
+{
+	if (r8153_patch_request(tp, true))
+		return -ETIME;
+
+	sram_write(tp, key_addr, patch_key);
+	sram_write(tp, 0xb82e, 0x0001);
+
+	return 0;
+}
+
+static int r8153_post_ram_code(struct r8152 *tp, u16 key_addr)
+{
+	u16 data;
+
+	sram_write(tp, 0x0000, 0x0000);
+
+	data = ocp_reg_read(tp, 0xb82e);
+	data &= ~0x0001;
+	ocp_reg_write(tp, 0xb82e, data);
+
+	sram_write(tp, key_addr, 0x0000);
+
+	r8153_patch_request(tp, false);
+
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, tp->ocp_base);
+
+	return 0;
+}
+
+static void r8153_wdt1_end(struct r8152 *tp)
+{
+	int i;
+
+	for (i = 0; i < 104; i++) {
+		if (!(ocp_read_byte(tp, MCU_TYPE_USB, 0xe404) & 1))
+			break;
+		usleep_range(1000, 2000);
+	}
+}
+
+static void r8153_firmware(struct r8152 *tp)
+{
+	if (tp->version == RTL_VER_03) {
+		r8153_clear_bp(tp);
+
+		r8153_pre_ram_code(tp, 0x8146, 0x7000);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c18);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c45);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c45);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd501);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xe018);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x0308);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x60f2);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x607d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc117);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c16);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc116);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c16);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x607d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc117);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x0800);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd501);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x62d2);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x615d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc115);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc307);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c42);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc114);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc317);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd701);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x435d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c42);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8404);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x613d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc115);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc307);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c42);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc114);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xc317);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd701);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x40dd);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa208);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd502);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa301);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd500);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd702);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x0800);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0fff);
+		sram_write(tp, 0xa004, 0x0fff);
+		sram_write(tp, 0xa002, 0x05a3);
+		sram_write(tp, 0xa000, 0x3591);
+		sram_write(tp, 0xb820, 0x0210);
+		r8153_post_ram_code(tp, 0x8146);
+	} else if (tp->version == RTL_VER_04) {
+		static u8 usb_patch_b[] = {
+			0x08, 0xe0, 0x0f, 0xe0,
+			0x18, 0xe0, 0x24, 0xe0,
+			0x26, 0xe0, 0x3a, 0xe0,
+			0x84, 0xe0, 0x9c, 0xe0,
+			0xc2, 0x49, 0x04, 0xf0,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x14, 0x18, 0x02, 0xc0,
+			0x00, 0xb8, 0x2e, 0x18,
+			0x06, 0x89, 0x08, 0xc0,
+			0x0c, 0x61, 0x92, 0x48,
+			0x93, 0x48, 0x0c, 0x89,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x08, 0x05, 0x40, 0xb4,
+			0x16, 0x89, 0x6d, 0xc0,
+			0x00, 0x61, 0x95, 0x49,
+			0x06, 0xf0, 0xfa, 0xc0,
+			0x0c, 0x61, 0x92, 0x48,
+			0x93, 0x48, 0x0c, 0x89,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xe2, 0x04, 0x02, 0xc2,
+			0x00, 0xba, 0xec, 0x11,
+			0x60, 0x60, 0x85, 0x49,
+			0x0d, 0xf1, 0x11, 0xc6,
+			0xd2, 0x61, 0x91, 0x49,
+			0xfd, 0xf0, 0x74, 0x60,
+			0x04, 0x48, 0x74, 0x88,
+			0x08, 0xc6, 0x08, 0xc0,
+			0xc4, 0x98, 0x01, 0x18,
+			0xc0, 0x88, 0x02, 0xc0,
+			0x00, 0xb8, 0x6e, 0x12,
+			0x04, 0xe4, 0x0d, 0x00,
+			0x00, 0xd4, 0xd1, 0x49,
+			0x3c, 0xf1, 0xd2, 0x49,
+			0x16, 0xf1, 0xd3, 0x49,
+			0x18, 0xf1, 0xd4, 0x49,
+			0x19, 0xf1, 0xd5, 0x49,
+			0x1a, 0xf1, 0xd6, 0x49,
+			0x1b, 0xf1, 0xd7, 0x49,
+			0x1c, 0xf1, 0xd8, 0x49,
+			0x1d, 0xf1, 0xd9, 0x49,
+			0x20, 0xf1, 0xda, 0x49,
+			0x23, 0xf1, 0xdb, 0x49,
+			0x24, 0xf1, 0x02, 0xc4,
+			0x00, 0xbc, 0x20, 0x04,
+			0xe5, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0x14, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x16, 0x02, 0x02, 0xc4,
+			0x00, 0xbc, 0x18, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x1a, 0x02, 0x02, 0xc4,
+			0x00, 0xbc, 0x1c, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x94, 0x02, 0x10, 0xc7,
+			0xe0, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0x8a, 0x02,
+			0x0b, 0xc7, 0xe4, 0x8e,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x88, 0x02, 0x02, 0xc4,
+			0x00, 0xbc, 0x6e, 0x02,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x5a, 0x02, 0x30, 0xe4,
+			0x0c, 0xc3, 0x60, 0x64,
+			0xc5, 0x49, 0x04, 0xf1,
+			0x74, 0x64, 0xc4, 0x48,
+			0x74, 0x8c, 0x06, 0xc3,
+			0x64, 0x8e, 0x02, 0xc4,
+			0x00, 0xbc, 0x20, 0x04,
+			0x00, 0xd8, 0x00, 0xe4,
+			0xb2, 0xc0, 0x00, 0x61,
+			0x90, 0x49, 0x09, 0xf1,
+			0x8b, 0xc6, 0xca, 0x61,
+			0x94, 0x49, 0x0e, 0xf1,
+			0xf6, 0xc6, 0xda, 0x60,
+			0x81, 0x49, 0x0a, 0xf0,
+			0x65, 0x60, 0x03, 0x48,
+			0x65, 0x88, 0xef, 0xc6,
+			0xdc, 0x60, 0x80, 0x48,
+			0xdc, 0x88, 0x05, 0xc6,
+			0x00, 0xbe, 0x02, 0xc6,
+			0x00, 0xbe, 0x36, 0x13,
+			0x4c, 0x17, 0x99, 0xc4,
+			0x80, 0x65, 0xd0, 0x49,
+			0x04, 0xf1, 0xfa, 0x75,
+			0x04, 0xc4, 0x00, 0xbc,
+			0x03, 0xc4, 0x00, 0xbc,
+			0x9a, 0x00, 0xee, 0x01 };
+		static u8 pla_patch_b[] = {
+			0x08, 0xe0, 0xea, 0xe0,
+			0xf2, 0xe0, 0x04, 0xe1,
+			0x09, 0xe1, 0x0e, 0xe1,
+			0x46, 0xe1, 0xf7, 0xe1,
+			0x14, 0xc2, 0x40, 0x73,
+			0xba, 0x48, 0x40, 0x9b,
+			0x11, 0xc2, 0x40, 0x73,
+			0xb0, 0x49, 0x17, 0xf0,
+			0xbf, 0x49, 0x03, 0xf1,
+			0x09, 0xc5, 0x00, 0xbd,
+			0xb1, 0x49, 0x11, 0xf0,
+			0xb1, 0x48, 0x40, 0x9b,
+			0x02, 0xc2, 0x00, 0xba,
+			0x1a, 0x17, 0x00, 0xe0,
+			0x1e, 0xfc, 0xbc, 0xc0,
+			0xf0, 0xc0, 0xde, 0xe8,
+			0x00, 0x80, 0x00, 0x20,
+			0x2c, 0x75, 0xd4, 0x49,
+			0x12, 0xf1, 0x32, 0xe0,
+			0xf8, 0xc2, 0x46, 0x71,
+			0xf7, 0xc2, 0x40, 0x73,
+			0xbe, 0x49, 0x03, 0xf1,
+			0xf5, 0xc7, 0x02, 0xe0,
+			0xf2, 0xc7, 0x4f, 0x30,
+			0x26, 0x62, 0xa1, 0x49,
+			0xf0, 0xf1, 0x22, 0x72,
+			0xa0, 0x49, 0xed, 0xf1,
+			0x25, 0x25, 0x18, 0x1f,
+			0x97, 0x30, 0x91, 0x30,
+			0x36, 0x9a, 0x2c, 0x75,
+			0x3c, 0xc3, 0x60, 0x73,
+			0xb1, 0x49, 0x0d, 0xf1,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x30, 0xc6, 0xc0, 0x77,
+			0x04, 0x13, 0x21, 0xf0,
+			0x03, 0x13, 0x22, 0xf0,
+			0x02, 0x13, 0x23, 0xf0,
+			0x01, 0x13, 0x24, 0xf0,
+			0x08, 0x13, 0x08, 0xf1,
+			0x2e, 0x73, 0xba, 0x21,
+			0xbd, 0x25, 0x05, 0x13,
+			0x03, 0xf1, 0x24, 0xc5,
+			0x00, 0xbd, 0xd4, 0x49,
+			0x03, 0xf1, 0x1c, 0xc5,
+			0x00, 0xbd, 0xc4, 0xc6,
+			0xc6, 0x67, 0x2e, 0x75,
+			0xd7, 0x22, 0xdd, 0x26,
+			0x05, 0x15, 0x1b, 0xf0,
+			0x14, 0xc6, 0x00, 0xbe,
+			0x13, 0xc5, 0x00, 0xbd,
+			0x12, 0xc5, 0x00, 0xbd,
+			0xf1, 0x49, 0xfb, 0xf1,
+			0xef, 0xe7, 0xf4, 0x49,
+			0xfa, 0xf1, 0xec, 0xe7,
+			0xf3, 0x49, 0xf7, 0xf1,
+			0xe9, 0xe7, 0xf2, 0x49,
+			0xf4, 0xf1, 0xe6, 0xe7,
+			0xb6, 0xc0, 0x9e, 0x12,
+			0xde, 0x11, 0x0a, 0x12,
+			0x3c, 0x13, 0x00, 0xa0,
+			0xa0, 0xd1, 0x00, 0x00,
+			0xc0, 0x75, 0xd0, 0x49,
+			0x46, 0xf0, 0x26, 0x72,
+			0xa7, 0x49, 0x43, 0xf0,
+			0x22, 0x72, 0x25, 0x25,
+			0x20, 0x1f, 0x97, 0x30,
+			0x91, 0x30, 0x40, 0x73,
+			0xf3, 0xc4, 0x1c, 0x40,
+			0x04, 0xf0, 0xd7, 0x49,
+			0x05, 0xf1, 0x37, 0xe0,
+			0x53, 0x48, 0xc0, 0x9d,
+			0x08, 0x02, 0x40, 0x66,
+			0x64, 0x27, 0x06, 0x16,
+			0x30, 0xf1, 0x46, 0x63,
+			0x3b, 0x13, 0x2d, 0xf1,
+			0x34, 0x9b, 0x18, 0x1b,
+			0x93, 0x30, 0x2b, 0xc3,
+			0x10, 0x1c, 0x2b, 0xe8,
+			0x01, 0x14, 0x25, 0xf1,
+			0x00, 0x1d, 0x26, 0x1a,
+			0x8a, 0x30, 0x22, 0x73,
+			0xb5, 0x25, 0x0e, 0x0b,
+			0x00, 0x1c, 0x2c, 0xe8,
+			0x1f, 0xc7, 0x27, 0x40,
+			0x1a, 0xf1, 0x38, 0xe8,
+			0x32, 0x1f, 0x8f, 0x30,
+			0x08, 0x1b, 0x24, 0xe8,
+			0x36, 0x72, 0x46, 0x77,
+			0x00, 0x17, 0x0d, 0xf0,
+			0x13, 0xc3, 0x1f, 0x40,
+			0x03, 0xf1, 0x00, 0x1f,
+			0x46, 0x9f, 0x44, 0x77,
+			0x9f, 0x44, 0x5f, 0x44,
+			0x17, 0xe8, 0x0a, 0xc7,
+			0x27, 0x40, 0x05, 0xf1,
+			0x02, 0xc3, 0x00, 0xbb,
+			0xfa, 0x18, 0xb0, 0x18,
+			0xff, 0xc7, 0x00, 0xbf,
+			0xb8, 0xcd, 0xff, 0xff,
+			0x02, 0x0c, 0x54, 0xa5,
+			0xdc, 0xa5, 0x2f, 0x40,
+			0x05, 0xf1, 0x00, 0x14,
+			0xfa, 0xf1, 0x01, 0x1c,
+			0x02, 0xe0, 0x00, 0x1c,
+			0x80, 0xff, 0xb0, 0x49,
+			0x04, 0xf0, 0x01, 0x0b,
+			0xd3, 0xa1, 0x03, 0xe0,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x00, 0x13, 0xfb, 0xf1,
+			0x80, 0xff, 0x22, 0x73,
+			0xb5, 0x25, 0x18, 0x1e,
+			0xde, 0x30, 0xd9, 0x30,
+			0x64, 0x72, 0x11, 0x1e,
+			0x68, 0x23, 0x16, 0x31,
+			0x80, 0xff, 0x08, 0xc2,
+			0x40, 0x73, 0x3a, 0x48,
+			0x40, 0x9b, 0x06, 0xff,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x08, 0x16, 0x1e, 0xfc,
+			0x2c, 0x75, 0xdc, 0x21,
+			0xbc, 0x25, 0x04, 0x13,
+			0x0b, 0xf0, 0x03, 0x13,
+			0x09, 0xf0, 0x02, 0x13,
+			0x07, 0xf0, 0x01, 0x13,
+			0x05, 0xf0, 0x08, 0x13,
+			0x03, 0xf0, 0x04, 0xc3,
+			0x00, 0xbb, 0x03, 0xc3,
+			0x00, 0xbb, 0x8c, 0x15,
+			0x76, 0x15, 0xa0, 0x64,
+			0x40, 0x48, 0xa0, 0x8c,
+			0x02, 0xc4, 0x00, 0xbc,
+			0x82, 0x00, 0xa0, 0x62,
+			0x21, 0x48, 0xa0, 0x8a,
+			0x02, 0xc2, 0x00, 0xba,
+			0x40, 0x03, 0x33, 0xc5,
+			0xa0, 0x74, 0xc0, 0x49,
+			0x1f, 0xf0, 0x30, 0xc5,
+			0xa0, 0x73, 0x00, 0x13,
+			0x04, 0xf1, 0xa2, 0x73,
+			0x00, 0x13, 0x14, 0xf0,
+			0x28, 0xc5, 0xa0, 0x74,
+			0xc8, 0x49, 0x1b, 0xf1,
+			0x26, 0xc5, 0xa0, 0x76,
+			0xa2, 0x74, 0x01, 0x06,
+			0x20, 0x37, 0xa0, 0x9e,
+			0xa2, 0x9c, 0x1e, 0xc5,
+			0xa2, 0x73, 0x23, 0x40,
+			0x10, 0xf8, 0x04, 0xf3,
+			0xa0, 0x73, 0x33, 0x40,
+			0x0c, 0xf8, 0x15, 0xc5,
+			0xa0, 0x74, 0x41, 0x48,
+			0xa0, 0x9c, 0x14, 0xc5,
+			0xa0, 0x76, 0x62, 0x48,
+			0xe0, 0x48, 0xa0, 0x9e,
+			0x10, 0xc6, 0x00, 0xbe,
+			0x0a, 0xc5, 0xa0, 0x74,
+			0x48, 0x48, 0xa0, 0x9c,
+			0x0b, 0xc5, 0x20, 0x1e,
+			0xa0, 0x9e, 0xe5, 0x48,
+			0xa0, 0x9e, 0xf0, 0xe7,
+			0xbc, 0xc0, 0xc8, 0xd2,
+			0xcc, 0xd2, 0x28, 0xe4,
+			0xe6, 0x01, 0xf0, 0xc0,
+			0x18, 0x89, 0x00, 0x1d,
+			0x3c, 0xc3, 0x64, 0x71,
+			0x3c, 0xc0, 0x02, 0x99,
+			0x00, 0x61, 0x67, 0x11,
+			0x3c, 0xf1, 0x69, 0x33,
+			0x35, 0xc0, 0x28, 0x40,
+			0xf6, 0xf1, 0x34, 0xc0,
+			0x00, 0x19, 0x81, 0x1b,
+			0x91, 0xe8, 0x31, 0xc0,
+			0x04, 0x1a, 0x84, 0x1b,
+			0x8d, 0xe8, 0x82, 0xe8,
+			0xa3, 0x49, 0xfe, 0xf0,
+			0x2b, 0xc0, 0x7e, 0xe8,
+			0xa1, 0x48, 0x28, 0xc0,
+			0x84, 0x1b, 0x84, 0xe8,
+			0x00, 0x1d, 0x69, 0x33,
+			0x00, 0x1e, 0x01, 0x06,
+			0xff, 0x18, 0x30, 0x40,
+			0xfd, 0xf1, 0x19, 0xc0,
+			0x00, 0x76, 0x2e, 0x40,
+			0xf7, 0xf1, 0x21, 0x48,
+			0x19, 0xc0, 0x84, 0x1b,
+			0x75, 0xe8, 0x10, 0xc0,
+			0x69, 0xe8, 0xa1, 0x49,
+			0xfd, 0xf0, 0x11, 0xc0,
+			0x00, 0x1a, 0x84, 0x1b,
+			0x6d, 0xe8, 0x62, 0xe8,
+			0xa5, 0x49, 0xfe, 0xf0,
+			0x09, 0xc0, 0x01, 0x19,
+			0x81, 0x1b, 0x66, 0xe8,
+			0x54, 0xe0, 0x10, 0xd4,
+			0x88, 0xd3, 0xb8, 0x0b,
+			0x50, 0xe8, 0x20, 0xb4,
+			0x10, 0xd8, 0x84, 0xd4,
+			0xfd, 0xc0, 0x52, 0xe8,
+			0x48, 0x33, 0xf9, 0xc0,
+			0x00, 0x61, 0x9c, 0x20,
+			0x9c, 0x24, 0xd0, 0x49,
+			0x04, 0xf0, 0x04, 0x11,
+			0x02, 0xf1, 0x03, 0xe0,
+			0x00, 0x11, 0x06, 0xf1,
+			0x5c, 0xc0, 0x00, 0x61,
+			0x92, 0x48, 0x00, 0x89,
+			0x3a, 0xe0, 0x06, 0x11,
+			0x06, 0xf1, 0x55, 0xc0,
+			0x00, 0x61, 0x11, 0x48,
+			0x00, 0x89, 0x33, 0xe0,
+			0x05, 0x11, 0x08, 0xf1,
+			0x4e, 0xc0, 0x00, 0x61,
+			0x91, 0x49, 0x04, 0xf0,
+			0x91, 0x48, 0x00, 0x89,
+			0x11, 0xe0, 0xd9, 0xc0,
+			0x00, 0x61, 0x98, 0x20,
+			0x98, 0x24, 0x25, 0x11,
+			0x24, 0xf1, 0x44, 0xc0,
+			0x29, 0xe8, 0x95, 0x49,
+			0x20, 0xf0, 0xcf, 0xc0,
+			0x00, 0x61, 0x98, 0x20,
+			0x98, 0x24, 0x25, 0x11,
+			0x1a, 0xf1, 0x37, 0xc0,
+			0x00, 0x61, 0x92, 0x49,
+			0x16, 0xf1, 0x12, 0x48,
+			0x00, 0x89, 0x2f, 0xc0,
+			0x00, 0x19, 0x00, 0x89,
+			0x2d, 0xc0, 0x01, 0x89,
+			0x2d, 0xc0, 0x04, 0x19,
+			0x81, 0x1b, 0x1c, 0xe8,
+			0x2a, 0xc0, 0x14, 0x19,
+			0x81, 0x1b, 0x18, 0xe8,
+			0x21, 0xc0, 0x0c, 0xe8,
+			0x1f, 0xc0, 0x12, 0x48,
+			0x81, 0x1b, 0x12, 0xe8,
+			0xae, 0xc3, 0x66, 0x71,
+			0xae, 0xc0, 0x02, 0x99,
+			0x02, 0xc0, 0x00, 0xb8,
+			0x96, 0x07, 0x13, 0xc4,
+			0x84, 0x98, 0x00, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x80, 0x71, 0x82, 0x72,
+			0x80, 0xff, 0x09, 0xc4,
+			0x84, 0x98, 0x80, 0x99,
+			0x82, 0x9a, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x80, 0xff,
+			0x08, 0xea, 0x30, 0xd4,
+			0x10, 0xc0, 0x12, 0xe8,
+			0x8a, 0xd3, 0x28, 0xe4,
+			0x2c, 0xe4, 0x00, 0xd8,
+			0x00, 0x00, 0x00, 0x00 };
+
+		r8153_pre_ram_code(tp, 0x8146, 0x7001);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0a);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa240);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa104);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x292d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8620);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a2c);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa101);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a36);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd056);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2223);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0222);
+		sram_write(tp, 0xa004, 0x0a35);
+		sram_write(tp, 0xa002, 0x0a2b);
+		sram_write(tp, 0xa000, 0xf92c);
+		sram_write(tp, 0xb820, 0x0210);
+		r8153_post_ram_code(tp, 0x8146);
+
+		r8153_wdt1_end(tp);
+		r8153_clear_bp(tp);
+
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x0000);
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(usb_patch_b),
+				  usb_patch_b, MCU_TYPE_USB);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc26, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x180c);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2a, 0x0506);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2c, 0x04E0);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2e, 0x11E4);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x125C);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc32, 0x0232);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc34, 0x131E);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc36, 0x0098);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x00FF);
+
+		if (!(ocp_read_word(tp, MCU_TYPE_PLA, 0xd38e) & BIT(0))) {
+			ocp_write_word(tp, MCU_TYPE_PLA, 0xd38c, 0x0082);
+			ocp_write_word(tp, MCU_TYPE_PLA, 0xd38e, 0x0082);
+		}
+
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x0000);
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch_b),
+				  pla_patch_b, MCU_TYPE_PLA);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x1154);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x1606);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x155a);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x0080);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc30, 0x033c);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc32, 0x01a0);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc34, 0x0794);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc36, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x007f);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xd388, 0x08ca);
+	} else if (tp->version == RTL_VER_05) {
+		u32 ocp_data;
+		static u8 usb_patch_c[] = {
+			0x08, 0xe0, 0x0a, 0xe0,
+			0x14, 0xe0, 0x2e, 0xe0,
+			0x3a, 0xe0, 0x41, 0xe0,
+			0x70, 0xe0, 0x7b, 0xe0,
+			0x02, 0xc5, 0x00, 0xbd,
+			0x38, 0x3b, 0xdb, 0x49,
+			0x04, 0xf1, 0x06, 0xc3,
+			0x00, 0xbb, 0x5a, 0x02,
+			0x05, 0xc4, 0x03, 0xc3,
+			0x00, 0xbb, 0xa4, 0x04,
+			0x7e, 0x02, 0x30, 0xd4,
+			0x30, 0x18, 0x18, 0xc1,
+			0x0c, 0xe8, 0x17, 0xc6,
+			0xc7, 0x65, 0xd0, 0x49,
+			0x05, 0xf0, 0x32, 0x48,
+			0x02, 0xc2, 0x00, 0xba,
+			0x3e, 0x16, 0x02, 0xc2,
+			0x00, 0xba, 0x48, 0x16,
+			0x02, 0xb4, 0x09, 0xc2,
+			0x40, 0x99, 0x0e, 0x48,
+			0x42, 0x98, 0x42, 0x70,
+			0x8e, 0x49, 0xfe, 0xf1,
+			0x02, 0xb0, 0x80, 0xff,
+			0xc0, 0xd4, 0xe4, 0x40,
+			0x20, 0xd4, 0x0c, 0xc0,
+			0x00, 0x63, 0xb5, 0x49,
+			0x04, 0xf0, 0x30, 0x18,
+			0x06, 0xc1, 0xed, 0xef,
+			0xf8, 0xc7, 0x02, 0xc0,
+			0x00, 0xb8, 0xd0, 0x10,
+			0xe4, 0x4b, 0x00, 0xd8,
+			0x07, 0xc3, 0x70, 0x61,
+			0x12, 0x48, 0x70, 0x89,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x9c, 0x15, 0x20, 0xd4,
+			0x2b, 0xc5, 0xa0, 0x77,
+			0x00, 0x1c, 0xa0, 0x9c,
+			0x28, 0xc5, 0xa0, 0x64,
+			0xc0, 0x48, 0xc1, 0x48,
+			0xc2, 0x48, 0xa0, 0x8c,
+			0xb1, 0x64, 0xc0, 0x48,
+			0xb1, 0x8c, 0x20, 0xc5,
+			0xa0, 0x64, 0x40, 0x48,
+			0x41, 0x48, 0xc2, 0x48,
+			0xa0, 0x8c, 0x19, 0xc5,
+			0xa4, 0x64, 0x44, 0x48,
+			0xa4, 0x8c, 0xb1, 0x64,
+			0x40, 0x48, 0xb1, 0x8c,
+			0x14, 0xc4, 0x80, 0x73,
+			0x13, 0xc4, 0x82, 0x9b,
+			0x11, 0x1b, 0x80, 0x9b,
+			0x0c, 0xc5, 0xa0, 0x64,
+			0x40, 0x48, 0x41, 0x48,
+			0x42, 0x48, 0xa0, 0x8c,
+			0x05, 0xc5, 0xa0, 0x9f,
+			0x02, 0xc5, 0x00, 0xbd,
+			0x6c, 0x3a, 0x1e, 0xfc,
+			0x10, 0xd8, 0x86, 0xd4,
+			0xf8, 0xcb, 0x20, 0xe4,
+			0x0a, 0xc0, 0x16, 0x61,
+			0x91, 0x48, 0x16, 0x89,
+			0x07, 0xc0, 0x11, 0x19,
+			0x0c, 0x89, 0x02, 0xc1,
+			0x00, 0xb9, 0x02, 0x06,
+			0x00, 0xd4, 0x40, 0xb4,
+			0xfe, 0xc0, 0x16, 0x61,
+			0x91, 0x48, 0x16, 0x89,
+			0xfb, 0xc0, 0x11, 0x19,
+			0x0c, 0x89, 0x02, 0xc1,
+			0x00, 0xb9, 0xd2, 0x05 };
+		static u8 pla_patch_c[] = {
+			0x08, 0xe0, 0xea, 0xe0,
+			0xf2, 0xe0, 0x04, 0xe1,
+			0x06, 0xe1, 0x08, 0xe1,
+			0x40, 0xe1, 0xf4, 0xe1,
+			0x14, 0xc2, 0x40, 0x73,
+			0xba, 0x48, 0x40, 0x9b,
+			0x11, 0xc2, 0x40, 0x73,
+			0xb0, 0x49, 0x17, 0xf0,
+			0xbf, 0x49, 0x03, 0xf1,
+			0x09, 0xc5, 0x00, 0xbd,
+			0xb1, 0x49, 0x11, 0xf0,
+			0xb1, 0x48, 0x40, 0x9b,
+			0x02, 0xc2, 0x00, 0xba,
+			0xde, 0x18, 0x00, 0xe0,
+			0x1e, 0xfc, 0xbc, 0xc0,
+			0xf0, 0xc0, 0xde, 0xe8,
+			0x00, 0x80, 0x00, 0x20,
+			0x2c, 0x75, 0xd4, 0x49,
+			0x12, 0xf1, 0x32, 0xe0,
+			0xf8, 0xc2, 0x46, 0x71,
+			0xf7, 0xc2, 0x40, 0x73,
+			0xbe, 0x49, 0x03, 0xf1,
+			0xf5, 0xc7, 0x02, 0xe0,
+			0xf2, 0xc7, 0x4f, 0x30,
+			0x26, 0x62, 0xa1, 0x49,
+			0xf0, 0xf1, 0x22, 0x72,
+			0xa0, 0x49, 0xed, 0xf1,
+			0x25, 0x25, 0x18, 0x1f,
+			0x97, 0x30, 0x91, 0x30,
+			0x36, 0x9a, 0x2c, 0x75,
+			0x3c, 0xc3, 0x60, 0x73,
+			0xb1, 0x49, 0x0d, 0xf1,
+			0xdc, 0x21, 0xbc, 0x25,
+			0x30, 0xc6, 0xc0, 0x77,
+			0x04, 0x13, 0x21, 0xf0,
+			0x03, 0x13, 0x22, 0xf0,
+			0x02, 0x13, 0x23, 0xf0,
+			0x01, 0x13, 0x24, 0xf0,
+			0x08, 0x13, 0x08, 0xf1,
+			0x2e, 0x73, 0xba, 0x21,
+			0xbd, 0x25, 0x05, 0x13,
+			0x03, 0xf1, 0x24, 0xc5,
+			0x00, 0xbd, 0xd4, 0x49,
+			0x03, 0xf1, 0x1c, 0xc5,
+			0x00, 0xbd, 0xc4, 0xc6,
+			0xc6, 0x67, 0x2e, 0x75,
+			0xd7, 0x22, 0xdd, 0x26,
+			0x05, 0x15, 0x1b, 0xf0,
+			0x14, 0xc6, 0x00, 0xbe,
+			0x13, 0xc5, 0x00, 0xbd,
+			0x12, 0xc5, 0x00, 0xbd,
+			0xf1, 0x49, 0xfb, 0xf1,
+			0xef, 0xe7, 0xf4, 0x49,
+			0xfa, 0xf1, 0xec, 0xe7,
+			0xf3, 0x49, 0xf7, 0xf1,
+			0xe9, 0xe7, 0xf2, 0x49,
+			0xf4, 0xf1, 0xe6, 0xe7,
+			0xb6, 0xc0, 0x50, 0x14,
+			0x90, 0x13, 0xbc, 0x13,
+			0xf2, 0x14, 0x00, 0xa0,
+			0xa0, 0xd1, 0x00, 0x00,
+			0xc0, 0x75, 0xd0, 0x49,
+			0x46, 0xf0, 0x26, 0x72,
+			0xa7, 0x49, 0x43, 0xf0,
+			0x22, 0x72, 0x25, 0x25,
+			0x20, 0x1f, 0x97, 0x30,
+			0x91, 0x30, 0x40, 0x73,
+			0xf3, 0xc4, 0x1c, 0x40,
+			0x04, 0xf0, 0xd7, 0x49,
+			0x05, 0xf1, 0x37, 0xe0,
+			0x53, 0x48, 0xc0, 0x9d,
+			0x08, 0x02, 0x40, 0x66,
+			0x64, 0x27, 0x06, 0x16,
+			0x30, 0xf1, 0x46, 0x63,
+			0x3b, 0x13, 0x2d, 0xf1,
+			0x34, 0x9b, 0x18, 0x1b,
+			0x93, 0x30, 0x2b, 0xc3,
+			0x10, 0x1c, 0x2b, 0xe8,
+			0x01, 0x14, 0x25, 0xf1,
+			0x00, 0x1d, 0x26, 0x1a,
+			0x8a, 0x30, 0x22, 0x73,
+			0xb5, 0x25, 0x0e, 0x0b,
+			0x00, 0x1c, 0x2c, 0xe8,
+			0x1f, 0xc7, 0x27, 0x40,
+			0x1a, 0xf1, 0x38, 0xe8,
+			0x32, 0x1f, 0x8f, 0x30,
+			0x08, 0x1b, 0x24, 0xe8,
+			0x36, 0x72, 0x46, 0x77,
+			0x00, 0x17, 0x0d, 0xf0,
+			0x13, 0xc3, 0x1f, 0x40,
+			0x03, 0xf1, 0x00, 0x1f,
+			0x46, 0x9f, 0x44, 0x77,
+			0x9f, 0x44, 0x5f, 0x44,
+			0x17, 0xe8, 0x0a, 0xc7,
+			0x27, 0x40, 0x05, 0xf1,
+			0x02, 0xc3, 0x00, 0xbb,
+			0xbe, 0x1a, 0x74, 0x14,
+			0xff, 0xc7, 0x00, 0xbf,
+			0xb8, 0xcd, 0xff, 0xff,
+			0x02, 0x0c, 0x54, 0xa5,
+			0xdc, 0xa5, 0x2f, 0x40,
+			0x05, 0xf1, 0x00, 0x14,
+			0xfa, 0xf1, 0x01, 0x1c,
+			0x02, 0xe0, 0x00, 0x1c,
+			0x80, 0xff, 0xb0, 0x49,
+			0x04, 0xf0, 0x01, 0x0b,
+			0xd3, 0xa1, 0x03, 0xe0,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x02, 0x0b, 0xd3, 0xa5,
+			0x27, 0x31, 0x20, 0x37,
+			0x00, 0x13, 0xfb, 0xf1,
+			0x80, 0xff, 0x22, 0x73,
+			0xb5, 0x25, 0x18, 0x1e,
+			0xde, 0x30, 0xd9, 0x30,
+			0x64, 0x72, 0x11, 0x1e,
+			0x68, 0x23, 0x16, 0x31,
+			0x80, 0xff, 0x08, 0xc2,
+			0x40, 0x73, 0x3a, 0x48,
+			0x40, 0x9b, 0x06, 0xff,
+			0x02, 0xc6, 0x00, 0xbe,
+			0xcc, 0x17, 0x1e, 0xfc,
+			0x2c, 0x75, 0xdc, 0x21,
+			0xbc, 0x25, 0x04, 0x13,
+			0x0b, 0xf0, 0x03, 0x13,
+			0x09, 0xf0, 0x02, 0x13,
+			0x07, 0xf0, 0x01, 0x13,
+			0x05, 0xf0, 0x08, 0x13,
+			0x03, 0xf0, 0x04, 0xc3,
+			0x00, 0xbb, 0x03, 0xc3,
+			0x00, 0xbb, 0x50, 0x17,
+			0x3a, 0x17, 0x02, 0xc6,
+			0x00, 0xbe, 0x00, 0x00,
+			0x02, 0xc6, 0x00, 0xbe,
+			0x00, 0x00, 0x33, 0xc5,
+			0xa0, 0x74, 0xc0, 0x49,
+			0x1f, 0xf0, 0x30, 0xc5,
+			0xa0, 0x73, 0x00, 0x13,
+			0x04, 0xf1, 0xa2, 0x73,
+			0x00, 0x13, 0x14, 0xf0,
+			0x28, 0xc5, 0xa0, 0x74,
+			0xc8, 0x49, 0x1b, 0xf1,
+			0x26, 0xc5, 0xa0, 0x76,
+			0xa2, 0x74, 0x01, 0x06,
+			0x20, 0x37, 0xa0, 0x9e,
+			0xa2, 0x9c, 0x1e, 0xc5,
+			0xa2, 0x73, 0x23, 0x40,
+			0x10, 0xf8, 0x04, 0xf3,
+			0xa0, 0x73, 0x33, 0x40,
+			0x0c, 0xf8, 0x15, 0xc5,
+			0xa0, 0x74, 0x41, 0x48,
+			0xa0, 0x9c, 0x14, 0xc5,
+			0xa0, 0x76, 0x62, 0x48,
+			0xe0, 0x48, 0xa0, 0x9e,
+			0x10, 0xc6, 0x00, 0xbe,
+			0x0a, 0xc5, 0xa0, 0x74,
+			0x48, 0x48, 0xa0, 0x9c,
+			0x0b, 0xc5, 0x20, 0x1e,
+			0xa0, 0x9e, 0xe5, 0x48,
+			0xa0, 0x9e, 0xf0, 0xe7,
+			0xbc, 0xc0, 0xc8, 0xd2,
+			0xcc, 0xd2, 0x28, 0xe4,
+			0xfa, 0x01, 0xf0, 0xc0,
+			0x18, 0x89, 0x00, 0x1d,
+			0x4a, 0xc3, 0x66, 0x62,
+			0xa0, 0x49, 0x06, 0xf0,
+			0x40, 0xc0, 0x02, 0x71,
+			0x60, 0x99, 0x3e, 0xc1,
+			0x03, 0xe0, 0x3b, 0xc0,
+			0x3c, 0xc1, 0x02, 0x99,
+			0x00, 0x61, 0x67, 0x11,
+			0x3d, 0xf1, 0x69, 0x33,
+			0x33, 0xc0, 0x28, 0x40,
+			0xf7, 0xf1, 0x34, 0xc0,
+			0x00, 0x19, 0x81, 0x1b,
+			0x8d, 0xe8, 0x31, 0xc0,
+			0x04, 0x1a, 0x84, 0x1b,
+			0x89, 0xe8, 0x7e, 0xe8,
+			0xa3, 0x49, 0xfe, 0xf0,
+			0x2b, 0xc0, 0x7a, 0xe8,
+			0xa1, 0x48, 0x28, 0xc0,
+			0x84, 0x1b, 0x80, 0xe8,
+			0x00, 0x1d, 0x69, 0x33,
+			0x00, 0x1e, 0x01, 0x06,
+			0xff, 0x18, 0x30, 0x40,
+			0xfd, 0xf1, 0x1f, 0xc0,
+			0x00, 0x76, 0x2e, 0x40,
+			0xf7, 0xf1, 0x21, 0x48,
+			0x19, 0xc0, 0x84, 0x1b,
+			0x71, 0xe8, 0x7a, 0xc0,
+			0x65, 0xe8, 0xa1, 0x49,
+			0xfd, 0xf0, 0x11, 0xc0,
+			0x00, 0x1a, 0x84, 0x1b,
+			0x69, 0xe8, 0x5e, 0xe8,
+			0xa5, 0x49, 0xfe, 0xf0,
+			0x09, 0xc0, 0x01, 0x19,
+			0x81, 0x1b, 0x62, 0xe8,
+			0x4d, 0xe0, 0xb8, 0x0b,
+			0x50, 0xe8, 0x83, 0x00,
+			0x82, 0x00, 0x20, 0xb4,
+			0x10, 0xd8, 0x84, 0xd4,
+			0x88, 0xd3, 0xfc, 0xc0,
+			0x4d, 0xe8, 0x48, 0x33,
+			0xf6, 0xc0, 0x00, 0x61,
+			0x9c, 0x20, 0x9c, 0x24,
+			0xd0, 0x49, 0x04, 0xf0,
+			0x04, 0x11, 0x02, 0xf1,
+			0x03, 0xe0, 0x00, 0x11,
+			0x06, 0xf1, 0x58, 0xc0,
+			0x00, 0x61, 0x92, 0x48,
+			0x00, 0x89, 0x32, 0xe0,
+			0x06, 0x11, 0x06, 0xf1,
+			0x51, 0xc0, 0x00, 0x61,
+			0x11, 0x48, 0x00, 0x89,
+			0x2b, 0xe0, 0x05, 0x11,
+			0x08, 0xf1, 0x4a, 0xc0,
+			0x00, 0x61, 0x91, 0x49,
+			0x04, 0xf0, 0x91, 0x48,
+			0x00, 0x89, 0x11, 0xe0,
+			0xd6, 0xc0, 0x00, 0x61,
+			0x98, 0x20, 0x98, 0x24,
+			0x25, 0x11, 0x1c, 0xf1,
+			0x3e, 0xc0, 0x24, 0xe8,
+			0x95, 0x49, 0x18, 0xf0,
+			0xcc, 0xc0, 0x00, 0x61,
+			0x98, 0x20, 0x98, 0x24,
+			0x25, 0x11, 0x12, 0xf1,
+			0x33, 0xc0, 0x00, 0x61,
+			0x92, 0x49, 0x0e, 0xf1,
+			0x12, 0x48, 0x00, 0x89,
+			0x2b, 0xc0, 0x00, 0x19,
+			0x00, 0x89, 0x29, 0xc0,
+			0x01, 0x89, 0x25, 0xc0,
+			0x0f, 0xe8, 0x23, 0xc0,
+			0x12, 0x48, 0x81, 0x1b,
+			0x15, 0xe8, 0xbb, 0xc3,
+			0x66, 0x62, 0xa0, 0x49,
+			0x04, 0xf0, 0x64, 0x71,
+			0xb0, 0xc0, 0x02, 0x99,
+			0x02, 0xc0, 0x00, 0xb8,
+			0xd6, 0x07, 0x13, 0xc4,
+			0x84, 0x98, 0x00, 0x1b,
+			0x86, 0x8b, 0x86, 0x73,
+			0xbf, 0x49, 0xfe, 0xf1,
+			0x80, 0x71, 0x82, 0x72,
+			0x80, 0xff, 0x09, 0xc4,
+			0x84, 0x98, 0x80, 0x99,
+			0x82, 0x9a, 0x86, 0x8b,
+			0x86, 0x73, 0xbf, 0x49,
+			0xfe, 0xf1, 0x80, 0xff,
+			0x08, 0xea, 0x10, 0xd4,
+			0x30, 0xd4, 0x10, 0xc0,
+			0x12, 0xe8, 0x8a, 0xd3,
+			0x00, 0xd8, 0x02, 0xc0,
+			0x00, 0xb8, 0xe0, 0x08,
+			0x00, 0x00, 0x00, 0x00 };
+
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xcfca);
+		ocp_data &= ~0x4000;
+		ocp_write_word(tp, MCU_TYPE_USB, 0xcfca, ocp_data);
+
+		r8153_pre_ram_code(tp, 0x8146, 0x7001);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0a);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c0d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa240);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa104);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x292d);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8620);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a2c);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x8480);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa101);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2a36);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xd056);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2223);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0222);
+		sram_write(tp, 0xa004, 0x0a35);
+		sram_write(tp, 0xa002, 0x0a2b);
+		sram_write(tp, 0xa000, 0xf92c);
+		sram_write(tp, 0xb820, 0x0210);
+		r8153_post_ram_code(tp, 0x8146);
+
+		r8153_wdt1_end(tp);
+		r8153_clear_bp(tp);
+
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x0000);
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(usb_patch_c),
+				  usb_patch_c, MCU_TYPE_USB);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc26, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x3b34);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2a, 0x027c);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2c, 0x162c);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2e, 0x10ce);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc32, 0x3a28);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc34, 0x05f8);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc36, 0x05c8);
+		if (ocp_read_byte(tp, MCU_TYPE_USB, 0xcfef) & 1) {
+			ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x1578);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x00ff);
+		} else {
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x00ef);
+		}
+
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x0000);
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(pla_patch_c),
+				  pla_patch_c, MCU_TYPE_PLA);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc26, 0x8000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc28, 0x1306);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2a, 0x17ca);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2c, 0x171e);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc2e, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc30, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc32, 0x01b4);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc34, 0x07d4);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xfc36, 0x0894);
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_BP_EN, 0x00e7);
+
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xd388, 0x08ca);
+
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, 0xcfca);
+		ocp_data |= 0x4000;
+		ocp_write_word(tp, MCU_TYPE_USB, 0xcfca, ocp_data);
+	} else if (tp->version == RTL_VER_06) {
+		static u8 usb_patch_d[] = {
+			0x08, 0xe0, 0x0e, 0xe0,
+			0x11, 0xe0, 0x24, 0xe0,
+			0x30, 0xe0, 0x32, 0xe0,
+			0x34, 0xe0, 0x36, 0xe0,
+			0x1e, 0xc3, 0x70, 0x61,
+			0x12, 0x48, 0x70, 0x89,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x02, 0x17, 0x31, 0x19,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x44, 0x14, 0x30, 0x18,
+			0x11, 0xc1, 0x05, 0xe8,
+			0x10, 0xc6, 0x02, 0xc2,
+			0x00, 0xba, 0x94, 0x17,
+			0x02, 0xb4, 0x09, 0xc2,
+			0x40, 0x99, 0x0e, 0x48,
+			0x42, 0x98, 0x42, 0x70,
+			0x8e, 0x49, 0xfe, 0xf1,
+			0x02, 0xb0, 0x80, 0xff,
+			0xc0, 0xd4, 0xe4, 0x40,
+			0x20, 0xd4, 0x0c, 0xc0,
+			0x00, 0x63, 0xb5, 0x49,
+			0x04, 0xf0, 0x30, 0x18,
+			0x06, 0xc1, 0xed, 0xef,
+			0xf8, 0xc7, 0x02, 0xc0,
+			0x00, 0xb8, 0x38, 0x12,
+			0xe4, 0x4b, 0x00, 0xd8,
+			0x02, 0xc3, 0x00, 0xbb,
+			0x00, 0x00, 0x02, 0xc5,
+			0x00, 0xbd, 0x00, 0x00,
+			0x02, 0xc1, 0x00, 0xb9,
+			0x00, 0x00, 0x02, 0xc1,
+			0x00, 0xb9, 0x00, 0x00 };
+
+		r8153_pre_ram_code(tp, 0x8146, 0x7002);
+		sram_write(tp, 0xb820, 0x0290);
+		sram_write(tp, 0xa012, 0x0000);
+		sram_write(tp, 0xa014, 0x2c04);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2c07);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa240);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0xa104);
+		ocp_write_word(tp, MCU_TYPE_PLA, 0xb438, 0x2944);
+		sram_write(tp, 0xa01a, 0x0000);
+		sram_write(tp, 0xa006, 0x0fff);
+		sram_write(tp, 0xa004, 0x0fff);
+		sram_write(tp, 0xa002, 0x0fff);
+		sram_write(tp, 0xa000, 0x1943);
+		sram_write(tp, 0xb820, 0x0210);
+		r8153_post_ram_code(tp, 0x8146);
+
+		r8153_clear_bp(tp);
+
+		ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x0000);
+		generic_ocp_write(tp, 0xf800, 0xff, sizeof(usb_patch_d),
+				  usb_patch_d, MCU_TYPE_USB);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc26, 0xa000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2a, 0x1442);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2c, 0x1792);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc2e, 0x1236);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc30, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc32, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc34, 0x0000);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xfc36, 0x0000);
+		if (ocp_read_byte(tp, MCU_TYPE_USB, 0xcfef) & 1) {
+			ocp_write_word(tp, MCU_TYPE_USB, 0xfc28, 0x16de);
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x000f);
+		} else {
+			ocp_write_word(tp, MCU_TYPE_USB, USB_BP_EN, 0x000e);
+		}
+	}
+}
+
+static void r8153b_firmware(struct r8152 *tp)
+{
+/*
+	r8153b_clear_bp(tp, MCU_TYPE_PLA);
+	r8153b_clear_bp(tp, MCU_TYPE_USB);
+*/
+}
+
+static void r8153_hw_phy_cfg(struct r8152 *tp)
+{
+	u32 ocp_data;
+	u16 data;
+
+	if (tp->version == RTL_VER_03 || tp->version == RTL_VER_04 ||
+	    tp->version == RTL_VER_05)
+		ocp_reg_write(tp, OCP_ADC_CFG, CKADSEL_L | ADC_EN | EN_EMI_L);
+
+	data = r8152_mdio_read(tp, MII_BMCR);
+	if (data & BMCR_PDOWN) {
+		data &= ~BMCR_PDOWN;
+		r8152_mdio_write(tp, MII_BMCR, data);
+	}
+
+	r8153_firmware(tp);
+
+	if (tp->version == RTL_VER_03) {
+		data = ocp_reg_read(tp, OCP_EEE_CFG);
+		data &= ~CTAP_SHORT_EN;
+		ocp_reg_write(tp, OCP_EEE_CFG, data);
+	}
+
+	data = ocp_reg_read(tp, OCP_POWER_CFG);
+	data |= EEE_CLKDIV_EN;
+	ocp_reg_write(tp, OCP_POWER_CFG, data);
+
+	data = ocp_reg_read(tp, OCP_DOWN_SPEED);
+	data |= EN_10M_BGOFF;
+	ocp_reg_write(tp, OCP_DOWN_SPEED, data);
+	data = ocp_reg_read(tp, OCP_POWER_CFG);
+	data |= EN_10M_PLLOFF;
+	ocp_reg_write(tp, OCP_POWER_CFG, data);
+	sram_write(tp, SRAM_IMPEDANCE, 0x0b13);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
+	ocp_data |= PFM_PWM_SWITCH;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
+
+	/* Enable LPF corner auto tune */
+	sram_write(tp, SRAM_LPF_CFG, 0xf70f);
+
+	/* Adjust 10M Amplitude */
+	sram_write(tp, SRAM_10M_AMP1, 0x00af);
+	sram_write(tp, SRAM_10M_AMP2, 0x0208);
+
+	set_bit(PHY_RESET, &tp->flags);
+}
+
+static void r8153b_ups_flags_w0w1(struct r8152 *tp, u32 set, u32 clear)
+{
+	u32 ocp_data;
+
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_USB, 0xd848);
+	ocp_data &= ~clear;
+	ocp_data |= set;
+	ocp_write_dword(tp, MCU_TYPE_USB, 0xd848, ocp_data);
+}
+
+static void r8153b_hw_phy_cfg(struct r8152 *tp)
+{
+	u32 ocp_data, ups_flags = 0;
+	u16 data;
+
+	data = r8152_mdio_read(tp, MII_BMCR);
+	if (data & BMCR_PDOWN) {
+		data &= ~BMCR_PDOWN;
+		r8152_mdio_write(tp, MII_BMCR, data);
+	}
+
+	r8153b_firmware(tp);
+
+	data = sram_read(tp, 0x8011);
+	data |= 0x8800;
+	sram_write(tp, 0x8011, data);
+	data = ocp_reg_read(tp, 0xa42c);
+	data |= 0x0002;
+	ocp_reg_write(tp, 0xa42c, data);
+	ups_flags |= 0x04000001;
+
+	data = ocp_reg_read(tp, OCP_DOWN_SPEED);
+	data |= 0x0800;
+	ocp_reg_write(tp, OCP_DOWN_SPEED, data);
+	ups_flags |= 0x0002;
+
+	ocp_write_word(tp, MCU_TYPE_PLA, 0xdd02, 0x807d);
+	data = ocp_read_word(tp, MCU_TYPE_PLA, 0xdd02);
+	data = (data & 0x0080) << 8;
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, 0xdd00);
+	data |= (u16)((ocp_data & 0xfff0) >> 1 | (ocp_data & 0x0007));
+	if (data != 0xffff)
+		ocp_reg_write(tp, 0xbbfc, data);
+
+	ocp_data = ocp_reg_read(tp, 0xc426);
+	ocp_data &= 0x3fff;
+	if (ocp_data) {
+		ocp_data = 16000000 / ocp_data;
+		ocp_data &= 0x0fff;
+		ocp_data |= ocp_read_word(tp, MCU_TYPE_USB, 0xd842) & ~0xfff;
+		ocp_write_word(tp, MCU_TYPE_USB, 0xd842, ocp_data);
+	}
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
+	ocp_data |= PFM_PWM_SWITCH;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
+
+	/* Advnace EEE */
+	if (!r8153_patch_request(tp, true)) {
+		data = ocp_reg_read(tp, OCP_POWER_CFG);
+		data |= EEE_CLKDIV_EN;
+		ocp_reg_write(tp, OCP_POWER_CFG, data);
+
+		data = ocp_reg_read(tp, OCP_DOWN_SPEED);
+		data |= 0x7000;
+		ocp_reg_write(tp, OCP_DOWN_SPEED, data);
+
+		ocp_reg_write(tp, 0xc416, 0);
+		ocp_reg_write(tp, 0xc416, 0x0050);
+
+		ups_flags |= 0x03400004;
+
+		r8153_patch_request(tp, false);
+	}
+
+	r8153b_ups_flags_w0w1(tp, ups_flags, 0);
+
+	set_bit(PHY_RESET, &tp->flags);
+}
+
+static void r8153_first_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i;
+
+	rxdy_gated_en(tp, true);
+	r8153_teredo_off(tp);
+
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+	ocp_data &= ~RCR_ACPT_ALL;
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+
+	rtl8152_nic_reset(tp);
+	rtl_reset_bmu(tp);
+
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data &= ~NOW_IS_OOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+	ocp_data &= ~MCU_BORW_EN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+
+	for (i = 0; i < 1000; i++) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+		if (ocp_data & LINK_LIST_READY)
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+	ocp_data |= RE_INIT_LL;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+
+	for (i = 0; i < 1000; i++) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+		if (ocp_data & LINK_LIST_READY)
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
+
+	ocp_data = tp->netdev->mtu + VLAN_ETH_HLEN + VLAN_HLEN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, ocp_data);
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_MTPS, MTPS_JUMBO);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0);
+	ocp_data |= TCR0_AUTO_FIFO;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_TCR0, ocp_data);
+
+	rtl8152_nic_reset(tp);
+
+	/* rx share fifo credit full threshold */
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL0, RXFIFO_THR1_NORMAL);
+
+	/* TX share fifo free credit full threshold */
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_TXFIFO_CTRL, TXFIFO_THR_NORMAL2);
+
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL1, RXFIFO_THR2_NORMAL);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RXFIFO_CTRL2, RXFIFO_THR3_NORMAL);
+
+	/* rx aggregation */
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
+}
+
+static void r8153_enter_oob(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i;
+
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data &= ~NOW_IS_OOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+
+	rtl_disable(tp);
+	rtl_reset_bmu(tp);
+
+	for (i = 0; i < 1000; i++) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+		if (ocp_data & LINK_LIST_READY)
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7);
+	ocp_data |= RE_INIT_LL;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_SFF_STS_7, ocp_data);
+
+	for (i = 0; i < 1000; i++) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+		if (ocp_data & LINK_LIST_READY)
+			break;
+		usleep_range(1000, 2000);
+	}
+
+	ocp_data = tp->netdev->mtu + VLAN_ETH_HLEN + VLAN_HLEN;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, ocp_data);
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_07:
+		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG);
+		ocp_data &= ~TEREDO_WAKE_MASK;
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_TEREDO_CFG, ocp_data);
+		break;
+
+	case RTL_VER_08:
+	case RTL_VER_09:
+	default:
+		ocp_write_word(tp, MCU_TYPE_PLA, 0x0c04, 0x00ff);
+		break;
+	}
+
+	rtl_rx_vlan_en(tp, true);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PAL_BDC_CR);
+	ocp_data |= ALDPS_PROXY_MODE;
+	ocp_write_word(tp, MCU_TYPE_PLA, PAL_BDC_CR, ocp_data);
+
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL);
+	ocp_data |= NOW_IS_OOB | DIS_MCU_CLROOB;
+	ocp_write_byte(tp, MCU_TYPE_PLA, PLA_OOB_CTRL, ocp_data);
+
+	rxdy_gated_en(tp, false);
+
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+	ocp_data |= RCR_APM | RCR_AM | RCR_AB;
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+}
+
+static void r8153_aldps_en(struct r8152 *tp, bool enable)
+{
+	u16 data;
+
+	data = ocp_reg_read(tp, OCP_POWER_CFG);
+	if (enable) {
+		data |= EN_ALDPS;
+		ocp_reg_write(tp, OCP_POWER_CFG, data);
+	} else {
+		int i;
+
+		data &= ~EN_ALDPS;
+		ocp_reg_write(tp, OCP_POWER_CFG, data);
+		for (i = 0; i < 20; i++) {
+			usleep_range(1000, 2000);
+			if (ocp_read_word(tp, MCU_TYPE_PLA, 0xe000) & 0x0100)
+				break;
+		}
+	}
+}
+
+static void r8153b_aldps_en(struct r8152 *tp, bool enable)
+{
+	r8153_aldps_en(tp, enable);
+
+	if (enable)
+		r8153b_ups_flags_w0w1(tp, 0x0008, 0);
+	else
+		r8153b_ups_flags_w0w1(tp, 0, 0x0008);
+}
+
+static void rtl8153_disable(struct r8152 *tp)
+{
+	tp->rtl_ops.aldps_enable(tp, false);
+	rtl_disable(tp);
+	rtl_reset_bmu(tp);
+	tp->rtl_ops.aldps_enable(tp, true);
+//	usb_enable_lpm(tp->udev);
+}
+
+static int rtl8152_set_speed(struct r8152 *tp, u8 autoneg, u16 speed, u8 duplex)
+{
+	u16 bmcr, anar, gbcr;
+	u32 ups_flags = 0;
+	int ret = 0;
+
+	anar = r8152_mdio_read(tp, MII_ADVERTISE);
+	anar &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+		  ADVERTISE_100HALF | ADVERTISE_100FULL);
+	if (tp->mii.supports_gmii) {
+		gbcr = r8152_mdio_read(tp, MII_CTRL1000);
+		gbcr &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);
+	} else {
+		gbcr = 0;
+	}
+
+	if (autoneg == AUTONEG_DISABLE) {
+		if (speed == SPEED_10) {
+			bmcr = 0;
+			anar |= ADVERTISE_10HALF | ADVERTISE_10FULL;
+			ups_flags = 6;
+		} else if (speed == SPEED_100) {
+			bmcr = BMCR_SPEED100;
+			anar |= ADVERTISE_100HALF | ADVERTISE_100FULL;
+			ups_flags = 8;
+		} else if (speed == SPEED_1000 && tp->mii.supports_gmii) {
+			bmcr = BMCR_SPEED1000;
+			gbcr |= ADVERTISE_1000FULL | ADVERTISE_1000HALF;
+			ups_flags = 5;
+		} else {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		if (duplex == DUPLEX_FULL) {
+			bmcr |= BMCR_FULLDPLX;
+			if (speed != SPEED_1000)
+				ups_flags++;
+		}
+	} else {
+		if (speed == SPEED_10) {
+			if (duplex == DUPLEX_FULL) {
+				anar |= ADVERTISE_10HALF | ADVERTISE_10FULL;
+				ups_flags = 2;
+			} else {
+				anar |= ADVERTISE_10HALF;
+				ups_flags = 1;
+			}
+		} else if (speed == SPEED_100) {
+			if (duplex == DUPLEX_FULL) {
+				anar |= ADVERTISE_10HALF | ADVERTISE_10FULL;
+				anar |= ADVERTISE_100HALF | ADVERTISE_100FULL;
+				ups_flags = 4;
+			} else {
+				anar |= ADVERTISE_10HALF;
+				anar |= ADVERTISE_100HALF;
+				ups_flags = 3;
+			}
+		} else if (speed == SPEED_1000 && tp->mii.supports_gmii) {
+			if (duplex == DUPLEX_FULL) {
+				anar |= ADVERTISE_10HALF | ADVERTISE_10FULL;
+				anar |= ADVERTISE_100HALF | ADVERTISE_100FULL;
+				gbcr |= ADVERTISE_1000FULL | ADVERTISE_1000HALF;
+			} else {
+				anar |= ADVERTISE_10HALF;
+				anar |= ADVERTISE_100HALF;
+				gbcr |= ADVERTISE_1000HALF;
+			}
+			ups_flags = 5;
+		} else {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		bmcr = BMCR_ANENABLE | BMCR_ANRESTART;
+	}
+
+	if (test_and_clear_bit(PHY_RESET, &tp->flags))
+		bmcr |= BMCR_RESET;
+
+	if (tp->mii.supports_gmii)
+		r8152_mdio_write(tp, MII_CTRL1000, gbcr);
+
+	r8152_mdio_write(tp, MII_ADVERTISE, anar);
+	r8152_mdio_write(tp, MII_BMCR, bmcr);
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+	case RTL_VER_07:
+		break;
+	case RTL_VER_08:
+	case RTL_VER_09:
+	default:
+		r8153b_ups_flags_w0w1(tp, ups_flags << 16, 0x000f0000);
+		break;
+	}
+
+	if (bmcr & BMCR_RESET) {
+		int i;
+
+		for (i = 0; i < 50; i++) {
+			msleep(20);
+			if ((r8152_mdio_read(tp, MII_BMCR) & BMCR_RESET) == 0)
+				break;
+		}
+	}
+
+out:
+	return ret;
+}
+
+static void rtl8152_up(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8152_aldps_en(tp, false);
+	r8152b_exit_oob(tp);
+	r8152_aldps_en(tp, true);
+}
+
+static void rtl8152_down(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		return;
+	}
+
+	r8152_power_cut_en(tp, false);
+	r8152_aldps_en(tp, false);
+	r8152b_enter_oob(tp);
+	r8152_aldps_en(tp, true);
+	if (tp->version == RTL_VER_01)
+		rtl8152_set_speed(tp, AUTONEG_ENABLE, SPEED_10, DUPLEX_FULL);
+}
+
+static void rtl8153_up(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	tp->rtl_ops.u1u2_enable(tp, false);
+	tp->rtl_ops.aldps_enable(tp, false);
+	r8153_first_init(tp);
+	tp->rtl_ops.aldps_enable(tp, true);
+	r8153_u2p3en(tp, true);
+	tp->rtl_ops.u1u2_enable(tp, true);
+//	usb_enable_lpm(tp->udev);
+}
+
+static void rtl8153_down(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		return;
+	}
+
+	tp->rtl_ops.u1u2_enable(tp, false);
+	r8153_u2p3en(tp, false);
+	tp->rtl_ops.power_cut_en(tp, false);
+	tp->rtl_ops.aldps_enable(tp, false);
+	r8153_enter_oob(tp);
+	tp->rtl_ops.aldps_enable(tp, true);
+}
+
+static bool rtl8152_in_nway(struct r8152 *tp)
+{
+	u16 nway_state;
+
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, 0x2000);
+	tp->ocp_base = 0x2000;
+	ocp_write_byte(tp, MCU_TYPE_PLA, 0xb014, 0x4c);		/* phy state */
+	nway_state = ocp_read_word(tp, MCU_TYPE_PLA, 0xb01a);
+
+	/* bit 15: TXDIS_STATE, bit 14: ABD_STATE */
+	if (nway_state & 0xc000)
+		return false;
+	else
+		return true;
+}
+
+static bool rtl8153_in_nway(struct r8152 *tp)
+{
+	u16 phy_state = ocp_reg_read(tp, OCP_PHY_STATE) & 0xff;
+
+	if (phy_state == TXDIS_STATE || phy_state == ABD_STATE)
+		return false;
+	else
+		return true;
+}
+
+static void set_carrier(struct r8152 *tp)
+{
+	struct net_device *netdev = tp->netdev;
+	u8 speed;
+
+	speed = rtl8152_get_speed(tp);
+
+	if (speed & LINK_STATUS) {
+		if (!netif_carrier_ok(netdev)) {
+			tp->rtl_ops.enable(tp);
+			set_bit(RTL8152_SET_RX_MODE, &tp->flags);
+			napi_disable(&tp->napi);
+			netif_carrier_on(netdev);
+			rtl_start_rx(tp);
+			napi_enable(&tp->napi);
+		}
+	} else {
+		if (netif_carrier_ok(netdev)) {
+			netif_carrier_off(netdev);
+			napi_disable(&tp->napi);
+			tp->rtl_ops.disable(tp);
+			napi_enable(&tp->napi);
+		}
+	}
+}
+
+static inline void __rtl_work_func(struct r8152 *tp)
+{
+	/* If the device is unplugged or !netif_running(), the workqueue
+	 * doesn't need to wake the device, and could return directly.
+	 */
+	if (test_bit(RTL8152_UNPLUG, &tp->flags) || !netif_running(tp->netdev))
+		return;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	if (!test_bit(WORK_ENABLE, &tp->flags))
+		goto out1;
+
+	if (!mutex_trylock(&tp->control)) {
+		schedule_delayed_work(&tp->schedule, 0);
+		goto out1;
+	}
+
+	if (test_and_clear_bit(RTL8152_LINK_CHG, &tp->flags))
+		set_carrier(tp);
+
+	if (test_bit(RTL8152_SET_RX_MODE, &tp->flags))
+		rtl8152_set_rx_mode(tp->netdev);
+
+	/* don't schedule napi before linking */
+	if (test_and_clear_bit(SCHEDULE_NAPI, &tp->flags) &&
+	    netif_carrier_ok(tp->netdev))
+		napi_schedule(&tp->napi);
+
+	mutex_unlock(&tp->control);
+
+out1:
+	usb_autopm_put_interface(tp->intf);
+}
+
+static inline void __rtl_hw_phy_work_func(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	mutex_lock(&tp->control);
+
+	tp->rtl_ops.hw_phy_cfg(tp);
+
+	rtl8152_set_speed(tp, tp->autoneg, tp->speed, tp->duplex);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+
+static void rtl_work_func_t(void *data)
+{
+	struct r8152 *tp = (struct r8152 *)data;
+
+	__rtl_work_func(tp);
+}
+
+static void rtl_hw_phy_work_func_t(void *data)
+{
+	struct r8152 *tp = (struct r8152 *)data;
+
+	__rtl_hw_phy_work_func(tp);
+}
+
+#else
+
+static void rtl_work_func_t(struct work_struct *work)
+{
+	struct r8152 *tp = container_of(work, struct r8152, schedule.work);
+
+	__rtl_work_func(tp);
+}
+
+static void rtl_hw_phy_work_func_t(struct work_struct *work)
+{
+	struct r8152 *tp = container_of(work, struct r8152, hw_phy_work.work);
+
+	__rtl_hw_phy_work_func(tp);
+}
+
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
+static int rtl_notifier(struct notifier_block *nb, unsigned long action,
+			void *data)
+{
+	struct r8152 *tp = container_of(nb, struct r8152, pm_notifier);
+
+	switch (action) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		usb_autopm_get_interface(tp->intf);
+		break;
+
+	case PM_POST_HIBERNATION:
+	case PM_POST_SUSPEND:
+		usb_autopm_put_interface(tp->intf);
+		break;
+
+	case PM_POST_RESTORE:
+	case PM_RESTORE_PREPARE:
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+#endif
+
+static int rtk_disable_diag(struct r8152 *tp)
+{
+	tp->rtk_enable_diag--;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, tp->ocp_base);
+	netif_info(tp, drv, tp->netdev, "disable rtk diag %d\n",
+		   tp->rtk_enable_diag);
+	mutex_unlock(&tp->control);
+	usb_autopm_put_interface(tp->intf);
+
+	return 0;
+}
+
+static int rtl8152_open(struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int res = 0;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	res = alloc_all_mem(tp);
+	if (res)
+		goto out;
+
+	res = usb_autopm_get_interface(tp->intf);
+	if (res < 0) {
+		free_all_mem(tp);
+		goto out;
+	}
+
+	mutex_lock(&tp->control);
+
+	tp->rtl_ops.up(tp);
+
+	netif_carrier_off(netdev);
+	netif_start_queue(netdev);
+	set_bit(WORK_ENABLE, &tp->flags);
+
+	res = usb_submit_urb(tp->intr_urb, GFP_KERNEL);
+	if (res) {
+		if (res == -ENODEV)
+			netif_device_detach(tp->netdev);
+		netif_warn(tp, ifup, netdev, "intr_urb submit failed: %d\n",
+			   res);
+		free_all_mem(tp);
+	} else {
+		napi_enable(&tp->napi);
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
+	tp->pm_notifier.notifier_call = rtl_notifier;
+	register_pm_notifier(&tp->pm_notifier);
+#endif
+
+out:
+	return res;
+}
+
+static int rtl8152_close(struct net_device *netdev)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int res = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_PM_SLEEP)
+	unregister_pm_notifier(&tp->pm_notifier);
+#endif
+	napi_disable(&tp->napi);
+	clear_bit(WORK_ENABLE, &tp->flags);
+	usb_kill_urb(tp->intr_urb);
+	cancel_delayed_work_sync(&tp->schedule);
+	netif_stop_queue(netdev);
+
+	if (unlikely(tp->rtk_enable_diag)) {
+		netif_err(tp, drv, tp->netdev, "rtk diag isn't disabled\n");
+		rtk_disable_diag(tp);
+	}
+
+	res = usb_autopm_get_interface(tp->intf);
+	if (res < 0 || test_bit(RTL8152_UNPLUG, &tp->flags)) {
+		rtl_drop_queued_tx(tp);
+		rtl_stop_rx(tp);
+	} else {
+		mutex_lock(&tp->control);
+
+		tp->rtl_ops.down(tp);
+
+		res = rtl_s5_wol(tp);
+
+		mutex_unlock(&tp->control);
+
+		usb_autopm_put_interface(tp->intf);
+	}
+
+	free_all_mem(tp);
+
+	return res;
+}
+
+static inline void r8152_mmd_indirect(struct r8152 *tp, u16 dev, u16 reg)
+{
+	ocp_reg_write(tp, OCP_EEE_AR, FUN_ADDR | dev);
+	ocp_reg_write(tp, OCP_EEE_DATA, reg);
+	ocp_reg_write(tp, OCP_EEE_AR, FUN_DATA | dev);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+static u16 r8152_mmd_read(struct r8152 *tp, u16 dev, u16 reg)
+{
+	u16 data;
+
+	r8152_mmd_indirect(tp, dev, reg);
+	data = ocp_reg_read(tp, OCP_EEE_DATA);
+	ocp_reg_write(tp, OCP_EEE_AR, 0x0000);
+
+	return data;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+
+static void r8152_mmd_write(struct r8152 *tp, u16 dev, u16 reg, u16 data)
+{
+	r8152_mmd_indirect(tp, dev, reg);
+	ocp_reg_write(tp, OCP_EEE_DATA, data);
+	ocp_reg_write(tp, OCP_EEE_AR, 0x0000);
+}
+
+static void r8152_eee_en(struct r8152 *tp, bool enable)
+{
+	u16 config1, config2, config3;
+	u32 ocp_data;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
+	config1 = ocp_reg_read(tp, OCP_EEE_CONFIG1) & ~sd_rise_time_mask;
+	config2 = ocp_reg_read(tp, OCP_EEE_CONFIG2);
+	config3 = ocp_reg_read(tp, OCP_EEE_CONFIG3) & ~fast_snr_mask;
+
+	if (enable) {
+		ocp_data |= EEE_RX_EN | EEE_TX_EN;
+		config1 |= EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN | RX_QUIET_EN;
+		config1 |= sd_rise_time(1);
+		config2 |= RG_DACQUIET_EN | RG_LDVQUIET_EN;
+		config3 |= fast_snr(42);
+	} else {
+		ocp_data &= ~(EEE_RX_EN | EEE_TX_EN);
+		config1 &= ~(EEE_10_CAP | EEE_NWAY_EN | TX_QUIET_EN |
+			     RX_QUIET_EN);
+		config1 |= sd_rise_time(7);
+		config2 &= ~(RG_DACQUIET_EN | RG_LDVQUIET_EN);
+		config3 |= fast_snr(511);
+	}
+
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_CR, ocp_data);
+	ocp_reg_write(tp, OCP_EEE_CONFIG1, config1);
+	ocp_reg_write(tp, OCP_EEE_CONFIG2, config2);
+	ocp_reg_write(tp, OCP_EEE_CONFIG3, config3);
+}
+
+static void r8152b_enable_eee(struct r8152 *tp)
+{
+	r8152_eee_en(tp, true);
+	r8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, MDIO_EEE_100TX);
+}
+
+static void r8153_eee_en(struct r8152 *tp, bool enable)
+{
+	u32 ocp_data;
+	u16 config;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
+	config = ocp_reg_read(tp, OCP_EEE_CFG);
+
+	if (enable) {
+		ocp_data |= EEE_RX_EN | EEE_TX_EN;
+		config |= EEE10_EN;
+	} else {
+		ocp_data &= ~(EEE_RX_EN | EEE_TX_EN);
+		config &= ~EEE10_EN;
+	}
+
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EEE_CR, ocp_data);
+	ocp_reg_write(tp, OCP_EEE_CFG, config);
+}
+
+static void r8153b_eee_en(struct r8152 *tp, bool enable)
+{
+	r8153_eee_en(tp, enable);
+
+	if (enable) {
+		u16 config;
+
+		config = ocp_reg_read(tp, 0xa4a2);
+		config |= 0x0200;
+		ocp_reg_write(tp, 0xa4a2, config);
+
+		config = ocp_reg_read(tp, 0xa428);
+		config |= 0x0080;
+		ocp_reg_write(tp, 0xa428, config);
+
+		r8153b_ups_flags_w0w1(tp, 0x00300000, 0);
+	} else {
+		u16 config;
+
+		config = ocp_reg_read(tp, 0xa428);
+		config &= ~0x0080;
+		ocp_reg_write(tp, 0xa428, config);
+
+		config = ocp_reg_read(tp, 0xa4a2);
+		config &= ~0x0200;
+		ocp_reg_write(tp, 0xa4a2, config);
+
+		r8153b_ups_flags_w0w1(tp, 0, 0x00300000);
+	}
+}
+
+static void r8153_enable_eee(struct r8152 *tp)
+{
+	r8153_eee_en(tp, true);
+	ocp_reg_write(tp, OCP_EEE_ADV, MDIO_EEE_1000T | MDIO_EEE_100TX);
+}
+
+static void r8153b_enable_eee(struct r8152 *tp)
+{
+	r8153b_eee_en(tp, true);
+	ocp_reg_write(tp, OCP_EEE_ADV, MDIO_EEE_1000T | MDIO_EEE_100TX);
+}
+
+static void r8152b_enable_fc(struct r8152 *tp)
+{
+	u16 anar;
+
+	anar = r8152_mdio_read(tp, MII_ADVERTISE);
+	anar |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
+	r8152_mdio_write(tp, MII_ADVERTISE, anar);
+}
+
+static void r8153b_enable_fc(struct r8152 *tp)
+{
+	r8152b_enable_fc(tp);
+	r8153b_ups_flags_w0w1(tp, 0x00800000, 0);
+}
+
+static void rtl_tally_reset(struct r8152 *tp)
+{
+	u32 ocp_data;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY);
+	ocp_data |= TALLY_RESET;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY, ocp_data);
+}
+
+static void r8152b_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8152_aldps_en(tp, false);
+#if 0
+	/* Clear EP3 Fifo before using interrupt transfer */
+	if (ocp_read_byte(tp, MCU_TYPE_USB, 0xb963) & 0x80) {
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x08);
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x40);
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x00);
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xb968, 0x00);
+		ocp_write_word(tp, MCU_TYPE_USB, 0xb010, 0x00e0);
+		ocp_write_byte(tp, MCU_TYPE_USB, 0xb963, 0x04);
+	}
+#endif
+
+	if (tp->version == RTL_VER_01) {
+		ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE);
+		ocp_data &= ~LED_MODE_MASK;
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE, ocp_data);
+	}
+
+	r8152_power_cut_en(tp, false);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR);
+	ocp_data |= TX_10M_IDLE_EN | PFM_PWM_SWITCH;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
+	ocp_data = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL);
+	ocp_data &= ~MCU_CLK_RATIO_MASK;
+	ocp_data |= MCU_CLK_RATIO | D3_CLK_GATED_EN;
+	ocp_write_dword(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL, ocp_data);
+	ocp_data = GPHY_STS_MSK | SPEED_DOWN_MSK |
+		   SPDWN_RXDV_MSK | SPDWN_LINKCHG_MSK;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_GPHY_INTR_IMR, ocp_data);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_TIMER);
+	ocp_data |= BIT(15);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_TIMER, ocp_data);
+	ocp_write_word(tp, MCU_TYPE_USB, 0xcbfc, 0x03e8);
+	ocp_data &= ~BIT(15);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_TIMER, ocp_data);
+
+	r8152b_enable_eee(tp);
+	r8152_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+	rtl_tally_reset(tp);
+
+	/* enable rx aggregation */
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
+
+	queue_delayed_work(system_long_wq, &tp->hw_phy_work, 0);
+}
+
+static void r8153_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8153_aldps_en(tp, false);
+	r8153_u1u2en(tp, false);
+
+	for (i = 0; i < 500; i++) {
+		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
+		    AUTOLOAD_DONE)
+			break;
+		msleep(20);
+	}
+
+	for (i = 0; i < 500; i++) {
+		ocp_data = ocp_reg_read(tp, OCP_PHY_STATUS) & PHY_STAT_MASK;
+		if (ocp_data == PHY_STAT_LAN_ON || ocp_data == PHY_STAT_PWRDN)
+			break;
+		msleep(20);
+	}
+
+//	usb_disable_lpm(tp->udev);
+	r8153_u2p3en(tp, false);
+
+	if (tp->version == RTL_VER_04) {
+		ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2);
+		ocp_data &= ~pwd_dn_scale_mask;
+		ocp_data |= pwd_dn_scale(96);
+		ocp_write_word(tp, MCU_TYPE_USB, USB_SSPHYLINK2, ocp_data);
+
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_USB2PHY);
+		ocp_data |= USB2PHY_L1 | USB2PHY_SUSPEND;
+		ocp_write_byte(tp, MCU_TYPE_USB, USB_USB2PHY, ocp_data);
+	} else if (tp->version == RTL_VER_05) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0);
+		ocp_data &= ~ECM_ALDPS;
+		ocp_write_byte(tp, MCU_TYPE_PLA, PLA_DMY_REG0, ocp_data);
+
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);
+		if (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)
+			ocp_data &= ~DYNAMIC_BURST;
+		else
+			ocp_data |= DYNAMIC_BURST;
+		ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);
+	} else if (tp->version == RTL_VER_06) {
+		ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1);
+		if (ocp_read_word(tp, MCU_TYPE_USB, USB_BURST_SIZE) == 0)
+			ocp_data &= ~DYNAMIC_BURST;
+		else
+			ocp_data |= DYNAMIC_BURST;
+		ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY1, ocp_data);
+	}
+
+	ocp_data = ocp_read_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2);
+	ocp_data |= EP4_FULL_FC;
+	ocp_write_byte(tp, MCU_TYPE_USB, USB_CSR_DUMMY2, ocp_data);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL);
+	ocp_data &= ~TIMER11_EN;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_WDT11_CTRL, ocp_data);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE);
+	ocp_data &= ~LED_MODE_MASK;
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_LED_FEATURE, ocp_data);
+
+	ocp_data = FIFO_EMPTY_1FB | ROK_EXIT_LPM;
+	if (tp->version == RTL_VER_04 && tp->udev->speed != USB_SPEED_SUPER)
+		ocp_data |= LPM_TIMER_500MS;
+	else
+		ocp_data |= LPM_TIMER_500US;
+	ocp_write_byte(tp, MCU_TYPE_USB, USB_LPM_CTRL, ocp_data);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2);
+	ocp_data &= ~SEN_VAL_MASK;
+	ocp_data |= SEN_VAL_NORMAL | SEL_RXIDLE;
+	ocp_write_word(tp, MCU_TYPE_USB, USB_AFE_CTRL2, ocp_data);
+
+	ocp_write_word(tp, MCU_TYPE_USB, USB_CONNECT_TIMER, 0x0001);
+
+	r8153A_power_cut_en(tp, false);
+	r8153_u1u2en(tp, true);
+
+	/* MAC clock speed down */
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL, 0);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL2, 0);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3, 0);
+	ocp_write_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL4, 0);
+
+	r8153_enable_eee(tp);
+	r8153_aldps_en(tp, true);
+	r8152b_enable_fc(tp);
+	rtl_tally_reset(tp);
+	r8153_u2p3en(tp, true);
+
+	queue_delayed_work(system_long_wq, &tp->hw_phy_work, 0);
+}
+
+static void r8153b_init(struct r8152 *tp)
+{
+	u32 ocp_data;
+	int i;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	r8153b_aldps_en(tp, false);
+	r8153b_u1u2en(tp, false);
+
+	for (i = 0; i < 500; i++) {
+		if (ocp_read_word(tp, MCU_TYPE_PLA, PLA_BOOT_CTRL) &
+		    AUTOLOAD_DONE)
+			break;
+		msleep(20);
+	}
+
+	for (i = 0; i < 500; i++) {
+		ocp_data = ocp_reg_read(tp, OCP_PHY_STATUS) & PHY_STAT_MASK;
+		if (ocp_data == PHY_STAT_LAN_ON || ocp_data == PHY_STAT_PWRDN)
+			break;
+		msleep(20);
+	}
+
+	r8153_u2p3en(tp, false);
+
+	ocp_write_word(tp, MCU_TYPE_USB, 0xcbfc, 0x0fff);
+	ocp_write_word(tp, MCU_TYPE_USB, 0xd4da, 0x01f4);
+
+	r8153B_power_cut_en(tp, false);
+	r8153b_ups_en(tp, false);
+	r8153b_u1u2en(tp, true);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, 0xe0ca);
+	ocp_data |= 0x8000;
+	ocp_write_word(tp, MCU_TYPE_PLA, 0xe0ca, ocp_data);
+
+	r8153b_enable_eee(tp);
+	r8153b_aldps_en(tp, true);
+	r8153b_enable_fc(tp);
+	rtl_tally_reset(tp);
+	r8153_u2p3en(tp, true);
+
+	queue_delayed_work(system_long_wq, &tp->hw_phy_work, 0);
+}
+
+static bool rtl_vendor_mode(struct usb_interface *intf)
+{
+	struct usb_host_interface *alt = intf->cur_altsetting;
+
+	return alt->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC;
+}
+
+static int rtl8152_pre_reset(struct usb_interface *intf)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+	struct net_device *netdev;
+
+	if (!tp)
+		return 0;
+
+	netdev = tp->netdev;
+	if (!netif_running(netdev))
+		return 0;
+
+	napi_disable(&tp->napi);
+	clear_bit(WORK_ENABLE, &tp->flags);
+	usb_kill_urb(tp->intr_urb);
+	cancel_delayed_work_sync(&tp->schedule);
+	if (netif_carrier_ok(netdev)) {
+		netif_stop_queue(netdev);
+		mutex_lock(&tp->control);
+		tp->rtl_ops.disable(tp);
+		mutex_unlock(&tp->control);
+	}
+
+	return 0;
+}
+
+static int rtl8152_post_reset(struct usb_interface *intf)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+	struct net_device *netdev;
+
+	if (!tp)
+		return 0;
+
+	netdev = tp->netdev;
+	if (!netif_running(netdev))
+		return 0;
+
+	set_bit(WORK_ENABLE, &tp->flags);
+	if (netif_carrier_ok(netdev)) {
+		mutex_lock(&tp->control);
+		tp->rtl_ops.enable(tp);
+		rtl8152_set_rx_mode(netdev);
+		mutex_unlock(&tp->control);
+		netif_wake_queue(netdev);
+	}
+
+	napi_enable(&tp->napi);
+
+	return 0;
+}
+
+static bool delay_autosuspend(struct r8152 *tp)
+{
+	bool sw_linking = !!netif_carrier_ok(tp->netdev);
+	bool hw_linking = !!(rtl8152_get_speed(tp) & LINK_STATUS);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+#define work_busy(x)	0
+#endif
+	/* This means a linking change occurs and the driver doesn't detect it,
+	 * yet. If the driver has disabled tx/rx and hw is linking on, the
+	 * device wouldn't wake up by receiving any packet.
+	 */
+	if (work_busy(&tp->schedule.work) || sw_linking != hw_linking)
+		return true;
+
+	/* If the linking down is occurred by nway, the device may miss the
+	 * linking change event. And it wouldn't wake when linking on.
+	 */
+	if (!sw_linking && tp->rtl_ops.in_nway(tp))
+		return true;
+	else
+		return false;
+}
+
+static int rtl8152_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+	struct net_device *netdev = tp->netdev;
+	int ret = 0;
+
+	mutex_lock(&tp->control);
+
+	if (PMSG_IS_AUTO(message)) {
+		if (netif_running(netdev) && delay_autosuspend(tp)) {
+			ret = -EBUSY;
+			goto out1;
+		}
+
+		set_bit(SELECTIVE_SUSPEND, &tp->flags);
+	} else {
+		netif_device_detach(netdev);
+	}
+
+	if (netif_running(netdev) && test_bit(WORK_ENABLE, &tp->flags)) {
+		clear_bit(WORK_ENABLE, &tp->flags);
+		usb_kill_urb(tp->intr_urb);
+		napi_disable(&tp->napi);
+		if (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {
+			rtl_stop_rx(tp);
+			rtl_runtime_suspend_enable(tp, true);
+		} else {
+			cancel_delayed_work_sync(&tp->schedule);
+			tp->rtl_ops.down(tp);
+		}
+		napi_enable(&tp->napi);
+	}
+out1:
+	mutex_unlock(&tp->control);
+
+	return ret;
+}
+
+static int rtl8152_resume(struct usb_interface *intf)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+
+	mutex_lock(&tp->control);
+
+	if (!test_bit(SELECTIVE_SUSPEND, &tp->flags))
+		netif_device_attach(tp->netdev);
+
+	if (netif_running(tp->netdev) && tp->netdev->flags & IFF_UP) {
+		if (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {
+			rtl_runtime_suspend_enable(tp, false);
+			clear_bit(SELECTIVE_SUSPEND, &tp->flags);
+			napi_disable(&tp->napi);
+			set_bit(WORK_ENABLE, &tp->flags);
+			if (netif_carrier_ok(tp->netdev))
+				rtl_start_rx(tp);
+			napi_enable(&tp->napi);
+		} else {
+			tp->rtl_ops.up(tp);
+			netif_carrier_off(tp->netdev);
+			set_bit(WORK_ENABLE, &tp->flags);
+		}
+		usb_submit_urb(tp->intr_urb, GFP_KERNEL);
+	} else if (test_bit(SELECTIVE_SUSPEND, &tp->flags)) {
+		if (tp->netdev->flags & IFF_UP)
+			rtl_runtime_suspend_enable(tp, false);
+		clear_bit(SELECTIVE_SUSPEND, &tp->flags);
+	}
+
+	mutex_unlock(&tp->control);
+
+	return 0;
+}
+
+static int rtl8152_reset_resume(struct usb_interface *intf)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+
+	clear_bit(SELECTIVE_SUSPEND, &tp->flags);
+	mutex_lock(&tp->control);
+	tp->rtl_ops.init(tp);
+	mutex_unlock(&tp->control);
+	return rtl8152_resume(intf);
+}
+
+static void rtl8152_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	if (unlikely(tp->rtk_enable_diag))
+		return;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	if (!rtl_can_wakeup(tp)) {
+		wol->supported = 0;
+		wol->wolopts = 0;
+	} else {
+		mutex_lock(&tp->control);
+		wol->supported = WAKE_ANY;
+		wol->wolopts = __rtl_get_wol(tp);
+		mutex_unlock(&tp->control);
+	}
+
+	usb_autopm_put_interface(tp->intf);
+}
+
+static int rtl8152_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	int ret;
+
+	if (!rtl_can_wakeup(tp))
+		return -EOPNOTSUPP;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out_set_wol;
+
+	mutex_lock(&tp->control);
+
+	__rtl_set_wol(tp, wol->wolopts);
+	tp->saved_wolopts = wol->wolopts & WAKE_ANY;
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out_set_wol:
+	return ret;
+}
+
+static u32 rtl8152_get_msglevel(struct net_device *dev)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	return tp->msg_enable;
+}
+
+static void rtl8152_set_msglevel(struct net_device *dev, u32 value)
+{
+	struct r8152 *tp = netdev_priv(dev);
+
+	tp->msg_enable = value;
+}
+
+static void rtl8152_get_drvinfo(struct net_device *netdev,
+				struct ethtool_drvinfo *info)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	strlcpy(info->driver, MODULENAME, sizeof(info->driver));
+	strlcpy(info->version, DRIVER_VERSION, sizeof(info->version));
+	usb_make_path(tp->udev, info->bus_info, sizeof(info->bus_info));
+}
+
+static
+int rtl8152_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	u16 bmcr, bmsr, ctrl1000 = 0, stat1000 = 0;
+	int ret, advert;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	cmd->supported =
+	    (SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+	     SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+	     SUPPORTED_Autoneg | SUPPORTED_MII);
+	if (tp->mii.supports_gmii)
+		cmd->supported |= SUPPORTED_1000baseT_Full;
+
+	/* only supports twisted-pair */
+	cmd->port = PORT_MII;
+
+	/* only supports internal transceiver */
+	cmd->transceiver = XCVR_INTERNAL;
+	cmd->phy_address = 32;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)
+	cmd->mdio_support = ETH_MDIO_SUPPORTS_C22;
+#endif
+	cmd->advertising = ADVERTISED_MII;
+
+	mutex_lock(&tp->control);
+
+	bmcr = r8152_mdio_read(tp, MII_BMCR);
+	bmsr = r8152_mdio_read(tp, MII_BMSR);
+	if (tp->mii.supports_gmii) {
+		ctrl1000 = r8152_mdio_read(tp, MII_CTRL1000);
+		stat1000 = r8152_mdio_read(tp, MII_STAT1000);
+	}
+
+	advert = r8152_mdio_read(tp, MII_ADVERTISE);
+	if (advert & ADVERTISE_10HALF)
+		cmd->advertising |= ADVERTISED_10baseT_Half;
+	if (advert & ADVERTISE_10FULL)
+		cmd->advertising |= ADVERTISED_10baseT_Full;
+	if (advert & ADVERTISE_100HALF)
+		cmd->advertising |= ADVERTISED_100baseT_Half;
+	if (advert & ADVERTISE_100FULL)
+		cmd->advertising |= ADVERTISED_100baseT_Full;
+	if (advert & ADVERTISE_PAUSE_CAP)
+		cmd->advertising |= ADVERTISED_Pause;
+	if (advert & ADVERTISE_PAUSE_ASYM)
+		cmd->advertising |= ADVERTISED_Asym_Pause;
+	if (tp->mii.supports_gmii) {
+		if (ctrl1000 & ADVERTISE_1000HALF)
+			cmd->advertising |= ADVERTISED_1000baseT_Half;
+		if (ctrl1000 & ADVERTISE_1000FULL)
+			cmd->advertising |= ADVERTISED_1000baseT_Full;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+	if (bmsr & BMSR_ANEGCOMPLETE) {
+		advert = r8152_mdio_read(tp, MII_LPA);
+		if (advert & LPA_LPACK)
+			cmd->lp_advertising |= ADVERTISED_Autoneg;
+		if (advert & ADVERTISE_10HALF)
+			cmd->lp_advertising |=
+				ADVERTISED_10baseT_Half;
+		if (advert & ADVERTISE_10FULL)
+			cmd->lp_advertising |=
+				ADVERTISED_10baseT_Full;
+		if (advert & ADVERTISE_100HALF)
+			cmd->lp_advertising |=
+				ADVERTISED_100baseT_Half;
+		if (advert & ADVERTISE_100FULL)
+			cmd->lp_advertising |=
+				ADVERTISED_100baseT_Full;
+
+		if (tp->mii.supports_gmii) {
+			if (stat1000 & LPA_1000HALF)
+				cmd->lp_advertising |=
+					ADVERTISED_1000baseT_Half;
+			if (stat1000 & LPA_1000FULL)
+				cmd->lp_advertising |=
+					ADVERTISED_1000baseT_Full;
+		}
+	} else {
+		cmd->lp_advertising = 0;
+	}
+#endif
+
+	if (bmcr & BMCR_ANENABLE) {
+		cmd->advertising |= ADVERTISED_Autoneg;
+		cmd->autoneg = AUTONEG_ENABLE;
+	} else {
+		cmd->autoneg = AUTONEG_DISABLE;
+	}
+
+	if (netif_carrier_ok(tp->netdev)) {
+		u8 speed = rtl8152_get_speed(tp);
+
+		if (speed & _100bps)
+			cmd->speed = SPEED_100;
+		else if (speed & _10bps)
+			cmd->speed = SPEED_10;
+		else if (tp->mii.supports_gmii && (speed & _1000bps))
+			cmd->speed = SPEED_1000;
+
+		cmd->duplex = (speed & FULL_DUP) ? DUPLEX_FULL : DUPLEX_HALF;
+	} else {
+		cmd->speed = 0;
+		cmd->duplex = 255;
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+static int rtl8152_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	int ret;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	mutex_lock(&tp->control);
+
+	ret = rtl8152_set_speed(tp, cmd->autoneg, cmd->speed, cmd->duplex);
+	if (!ret) {
+		tp->autoneg = cmd->autoneg;
+		tp->speed = cmd->speed;
+		tp->duplex = cmd->duplex;
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+static const char rtl8152_gstrings[][ETH_GSTRING_LEN] = {
+	"tx_packets",
+	"rx_packets",
+	"tx_errors",
+	"rx_errors",
+	"rx_missed",
+	"align_errors",
+	"tx_single_collisions",
+	"tx_multi_collisions",
+	"rx_unicast",
+	"rx_broadcast",
+	"rx_multicast",
+	"tx_aborted",
+	"tx_underrun",
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+static int rtl8152_get_sset_count(struct net_device *dev)
+{
+	return ARRAY_SIZE(rtl8152_gstrings);
+}
+#else
+static int rtl8152_get_sset_count(struct net_device *dev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return ARRAY_SIZE(rtl8152_gstrings);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+#endif
+
+static void rtl8152_get_ethtool_stats(struct net_device *dev,
+				      struct ethtool_stats *stats, u64 *data)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	struct tally_counter tally;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return;
+
+	if (usb_autopm_get_interface(tp->intf) < 0)
+		return;
+
+	generic_ocp_read(tp, PLA_TALLYCNT, sizeof(tally), &tally, MCU_TYPE_PLA);
+
+	usb_autopm_put_interface(tp->intf);
+
+	data[0] = le64_to_cpu(tally.tx_packets);
+	data[1] = le64_to_cpu(tally.rx_packets);
+	data[2] = le64_to_cpu(tally.tx_errors);
+	data[3] = le32_to_cpu(tally.rx_errors);
+	data[4] = le16_to_cpu(tally.rx_missed);
+	data[5] = le16_to_cpu(tally.align_errors);
+	data[6] = le32_to_cpu(tally.tx_one_collision);
+	data[7] = le32_to_cpu(tally.tx_multi_collision);
+	data[8] = le64_to_cpu(tally.rx_unicast);
+	data[9] = le64_to_cpu(tally.rx_broadcast);
+	data[10] = le32_to_cpu(tally.rx_multicast);
+	data[11] = le16_to_cpu(tally.tx_aborted);
+	data[12] = le16_to_cpu(tally.tx_underrun);
+}
+
+static void rtl8152_get_strings(struct net_device *dev, u32 stringset, u8 *data)
+{
+	switch (stringset) {
+	case ETH_SS_STATS:
+		memcpy(data, *rtl8152_gstrings, sizeof(rtl8152_gstrings));
+		break;
+	}
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+static int r8152_get_eee(struct r8152 *tp, struct ethtool_eee *eee)
+{
+	u32 ocp_data, lp, adv, supported = 0;
+	u16 val;
+
+	val = r8152_mmd_read(tp, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
+	supported = mmd_eee_cap_to_ethtool_sup_t(val);
+
+	val = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
+	adv = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	val = r8152_mmd_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);
+	lp = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
+	ocp_data &= EEE_RX_EN | EEE_TX_EN;
+
+	eee->eee_enabled = !!ocp_data;
+	eee->eee_active = !!(supported & adv & lp);
+	eee->supported = supported;
+	eee->advertised = adv;
+	eee->lp_advertised = lp;
+
+	return 0;
+}
+
+static int r8152_set_eee(struct r8152 *tp, struct ethtool_eee *eee)
+{
+	u16 val = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);
+
+	r8152_eee_en(tp, eee->eee_enabled);
+
+	if (!eee->eee_enabled)
+		val = 0;
+
+	r8152_mmd_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, val);
+
+	return 0;
+}
+
+static int r8153_get_eee(struct r8152 *tp, struct ethtool_eee *eee)
+{
+	u32 ocp_data, lp, adv, supported = 0;
+	u16 val;
+
+	val = ocp_reg_read(tp, OCP_EEE_ABLE);
+	supported = mmd_eee_cap_to_ethtool_sup_t(val);
+
+	val = ocp_reg_read(tp, OCP_EEE_ADV);
+	adv = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	val = ocp_reg_read(tp, OCP_EEE_LPABLE);
+	lp = mmd_eee_adv_to_ethtool_adv_t(val);
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_EEE_CR);
+	ocp_data &= EEE_RX_EN | EEE_TX_EN;
+
+	eee->eee_enabled = !!ocp_data;
+	eee->eee_active = !!(supported & adv & lp);
+	eee->supported = supported;
+	eee->advertised = adv;
+	eee->lp_advertised = lp;
+
+	return 0;
+}
+
+static int r8153_set_eee(struct r8152 *tp, struct ethtool_eee *eee)
+{
+	u16 val = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);
+
+	r8153_eee_en(tp, eee->eee_enabled);
+
+	if (!eee->eee_enabled)
+		val = 0;
+
+	ocp_reg_write(tp, OCP_EEE_ADV, val);
+
+	return 0;
+}
+
+static int r8153b_set_eee(struct r8152 *tp, struct ethtool_eee *eee)
+{
+	u16 val = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);
+
+	r8153b_eee_en(tp, eee->eee_enabled);
+
+	if (!eee->eee_enabled)
+		val = 0;
+
+	ocp_reg_write(tp, OCP_EEE_ADV, val);
+
+	return 0;
+}
+
+static int
+rtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+	struct r8152 *tp = netdev_priv(net);
+	int ret;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	mutex_lock(&tp->control);
+
+	ret = tp->rtl_ops.eee_get(tp, edata);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+static int
+rtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+	struct r8152 *tp = netdev_priv(net);
+	int ret;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	mutex_lock(&tp->control);
+
+	ret = tp->rtl_ops.eee_set(tp, edata);
+	if (!ret)
+		ret = mii_nway_restart(&tp->mii);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+
+static int rtl8152_nway_reset(struct net_device *dev)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	int ret;
+
+	if (unlikely(tp->rtk_enable_diag))
+		return -EBUSY;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	mutex_lock(&tp->control);
+
+	ret = mii_nway_restart(&tp->mii);
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+static int rtl8152_get_coalesce(struct net_device *netdev,
+				struct ethtool_coalesce *coalesce)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		return -EOPNOTSUPP;
+	default:
+		break;
+	}
+
+	coalesce->rx_coalesce_usecs = tp->coalesce;
+
+	return 0;
+}
+
+static int rtl8152_set_coalesce(struct net_device *netdev,
+				struct ethtool_coalesce *coalesce)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	int ret;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+	case RTL_VER_08:
+	case RTL_VER_09:
+		return -EOPNOTSUPP;
+	default:
+		break;
+	}
+
+	if (coalesce->rx_coalesce_usecs > COALESCE_SLOW)
+		return -EINVAL;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&tp->control);
+
+	if (tp->coalesce != coalesce->rx_coalesce_usecs) {
+		tp->coalesce = coalesce->rx_coalesce_usecs;
+
+		if (netif_running(tp->netdev) && netif_carrier_ok(netdev))
+			r8153_set_rx_early_timeout(tp);
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+	return ret;
+}
+
+static struct ethtool_ops ops = {
+	.get_drvinfo = rtl8152_get_drvinfo,
+	.get_settings = rtl8152_get_settings,
+	.set_settings = rtl8152_set_settings,
+	.get_link = ethtool_op_get_link,
+	.nway_reset = rtl8152_nway_reset,
+	.get_msglevel = rtl8152_get_msglevel,
+	.set_msglevel = rtl8152_set_msglevel,
+	.get_wol = rtl8152_get_wol,
+	.set_wol = rtl8152_set_wol,
+	.get_strings = rtl8152_get_strings,
+	.get_sset_count = rtl8152_get_sset_count,
+	.get_ethtool_stats = rtl8152_get_ethtool_stats,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+	.get_tx_csum = ethtool_op_get_tx_csum,
+	.set_tx_csum = ethtool_op_set_tx_csum,
+	.get_sg = ethtool_op_get_sg,
+	.set_sg = ethtool_op_set_sg,
+#ifdef NETIF_F_TSO
+	.get_tso = ethtool_op_get_tso,
+	.set_tso = ethtool_op_set_tso,
+#endif
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0) */
+	.get_coalesce = rtl8152_get_coalesce,
+	.set_coalesce = rtl8152_set_coalesce,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+	.get_eee = rtl_ethtool_get_eee,
+	.set_eee = rtl_ethtool_set_eee,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+};
+
+static int rtltool_ioctl(struct r8152 *tp, struct ifreq *ifr)
+{
+	struct net_device *netdev = tp->netdev;
+	struct rtltool_cmd my_cmd, *myptr;
+	struct usb_device_info *uinfo;
+	struct usb_device *udev;
+	__le32	ocp_data;
+	void	*buffer;
+	int	ret;
+
+	myptr = (struct rtltool_cmd *)ifr->ifr_data;
+	if (copy_from_user(&my_cmd, myptr, sizeof(my_cmd)))
+		return -EFAULT;
+
+	ret = 0;
+
+	switch (my_cmd.cmd) {
+	case RTLTOOL_PLA_OCP_READ_DWORD:
+		pla_ocp_read(tp, (u16)my_cmd.offset, sizeof(ocp_data),
+			     &ocp_data);
+		my_cmd.data = __le32_to_cpu(ocp_data);
+
+		if (copy_to_user(myptr, &my_cmd, sizeof(my_cmd))) {
+			ret = -EFAULT;
+			break;
+		}
+		break;
+
+	case RTLTOOL_PLA_OCP_WRITE_DWORD:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		ocp_data = __cpu_to_le32(my_cmd.data);
+		pla_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      sizeof(ocp_data), &ocp_data);
+		break;
+
+	case RTLTOOL_USB_OCP_READ_DWORD:
+		usb_ocp_read(tp, (u16)my_cmd.offset, sizeof(ocp_data),
+			     &ocp_data);
+		my_cmd.data = __le32_to_cpu(ocp_data);
+
+		if (copy_to_user(myptr, &my_cmd, sizeof(my_cmd))) {
+			ret = -EFAULT;
+			break;
+		}
+		break;
+
+
+	case RTLTOOL_USB_OCP_WRITE_DWORD:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		ocp_data = __cpu_to_le32(my_cmd.data);
+		usb_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      sizeof(ocp_data), &ocp_data);
+		break;
+
+	case RTLTOOL_PLA_OCP_READ:
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		pla_ocp_read(tp, (u16)my_cmd.offset, my_cmd.data, buffer);
+
+		if (copy_to_user(myptr->buf, buffer, my_cmd.data))
+			ret = -EFAULT;
+
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_PLA_OCP_WRITE:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		if (copy_from_user(buffer, myptr->buf, my_cmd.data)) {
+			ret = -EFAULT;
+			kfree(buffer);
+			break;
+		}
+
+		pla_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      my_cmd.data, buffer);
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_USB_OCP_READ:
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		usb_ocp_read(tp, (u16)my_cmd.offset, my_cmd.data, buffer);
+
+		if (copy_to_user(myptr->buf, buffer, my_cmd.data))
+			ret = -EFAULT;
+
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_USB_OCP_WRITE:
+		if (!tp->rtk_enable_diag && net_ratelimit())
+			netif_warn(tp, drv, netdev,
+				   "rtk diag isn't enable\n");
+
+		buffer = kmalloc(my_cmd.data, GFP_KERNEL);
+		if (!buffer) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		if (copy_from_user(buffer, myptr->buf, my_cmd.data)) {
+			ret = -EFAULT;
+			kfree(buffer);
+			break;
+		}
+
+		usb_ocp_write(tp, (u16)my_cmd.offset, (u16)my_cmd.byteen,
+			      my_cmd.data, buffer);
+		kfree(buffer);
+		break;
+
+	case RTLTOOL_USB_INFO:
+		uinfo = (struct usb_device_info *)&my_cmd.nic_info;
+		udev = tp->udev;
+		uinfo->idVendor = __le16_to_cpu(udev->descriptor.idVendor);
+		uinfo->idProduct = __le16_to_cpu(udev->descriptor.idProduct);
+		uinfo->bcdDevice = __le16_to_cpu(udev->descriptor.bcdDevice);
+		strlcpy(uinfo->devpath, udev->devpath, sizeof(udev->devpath));
+		pla_ocp_read(tp, PLA_IDR, sizeof(uinfo->dev_addr),
+			     uinfo->dev_addr);
+
+		if (copy_to_user(myptr, &my_cmd, sizeof(my_cmd)))
+			ret = -EFAULT;
+
+		break;
+
+	case RTL_ENABLE_USB_DIAG:
+		ret = usb_autopm_get_interface(tp->intf);
+		if (ret < 0)
+			break;
+
+		mutex_lock(&tp->control);
+		tp->rtk_enable_diag++;
+		netif_info(tp, drv, netdev, "enable rtk diag %d\n",
+			   tp->rtk_enable_diag);
+		break;
+
+	case RTL_DISABLE_USB_DIAG:
+		if (!tp->rtk_enable_diag) {
+			netif_err(tp, drv, netdev,
+				  "Invalid using rtk diag\n");
+			ret = -EPERM;
+			break;
+		}
+
+		rtk_disable_diag(tp);
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
+static int rtl8152_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct r8152 *tp = netdev_priv(netdev);
+	struct mii_ioctl_data *data = if_mii(rq);
+	int ret;
+
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return -ENODEV;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		goto out;
+
+	switch (cmd) {
+	case SIOCGMIIPHY:
+		data->phy_id = R8152_PHY_ID; /* Internal PHY */
+		break;
+
+	case SIOCGMIIREG:
+		if (unlikely(tp->rtk_enable_diag)) {
+			ret = -EBUSY;
+			break;
+		}
+
+		mutex_lock(&tp->control);
+		data->val_out = r8152_mdio_read(tp, data->reg_num);
+		mutex_unlock(&tp->control);
+		break;
+
+	case SIOCSMIIREG:
+		if (!capable(CAP_NET_ADMIN)) {
+			ret = -EPERM;
+			break;
+		}
+
+		if (unlikely(tp->rtk_enable_diag)) {
+			ret = -EBUSY;
+			break;
+		}
+
+		mutex_lock(&tp->control);
+		r8152_mdio_write(tp, data->reg_num, data->val_in);
+		mutex_unlock(&tp->control);
+		break;
+
+	case SIOCDEVPRIVATE:
+		if (!capable(CAP_NET_ADMIN)) {
+			ret = -EPERM;
+			break;
+		}
+		ret = rtltool_ioctl(tp, rq);
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	usb_autopm_put_interface(tp->intf);
+
+out:
+	return ret;
+}
+
+static int rtl8152_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct r8152 *tp = netdev_priv(dev);
+	int ret;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+	case RTL_VER_08:
+		return eth_change_mtu(dev, new_mtu);
+	default:
+		break;
+	}
+
+	if (new_mtu < 68 || new_mtu > RTL8153_MAX_MTU)
+		return -EINVAL;
+
+	ret = usb_autopm_get_interface(tp->intf);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&tp->control);
+
+	dev->mtu = new_mtu;
+
+	if (netif_running(dev)) {
+		u32 rms = new_mtu + VLAN_ETH_HLEN + VLAN_HLEN;
+
+		ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, rms);
+
+		if (netif_carrier_ok(dev))
+			r8153_set_rx_early_size(tp);
+	}
+
+	mutex_unlock(&tp->control);
+
+	usb_autopm_put_interface(tp->intf);
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+static const struct net_device_ops rtl8152_netdev_ops = {
+	.ndo_open		= rtl8152_open,
+	.ndo_stop		= rtl8152_close,
+	.ndo_do_ioctl		= rtl8152_ioctl,
+	.ndo_start_xmit		= rtl8152_start_xmit,
+	.ndo_tx_timeout		= rtl8152_tx_timeout,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+	.ndo_vlan_rx_register	= rtl8152_vlan_rx_register,
+#else
+	.ndo_set_features	= rtl8152_set_features,
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) */
+	.ndo_set_rx_mode	= rtl8152_set_rx_mode,
+	.ndo_set_mac_address	= rtl8152_set_mac_address,
+	.ndo_change_mtu		= rtl8152_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4)
+	.ndo_features_check	= rtl8152_features_check,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,4) */
+};
+#endif
+
+static void r8152b_get_version(struct r8152 *tp)
+{
+	u32	ocp_data;
+	u16	version;
+
+	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR1);
+	version = (u16)(ocp_data & VERSION_MASK);
+
+	switch (version) {
+	case 0x4c00:
+		tp->version = RTL_VER_01;
+		break;
+	case 0x4c10:
+		tp->version = RTL_VER_02;
+		break;
+	case 0x5c00:
+		tp->version = RTL_VER_03;
+		tp->mii.supports_gmii = 1;
+		break;
+	case 0x5c10:
+		tp->version = RTL_VER_04;
+		tp->mii.supports_gmii = 1;
+		break;
+	case 0x5c20:
+		tp->version = RTL_VER_05;
+		tp->mii.supports_gmii = 1;
+		break;
+	case 0x5c30:
+		tp->version = RTL_VER_06;
+		tp->mii.supports_gmii = 1;
+		break;
+	case 0x4800:
+		tp->version = RTL_VER_07;
+		break;
+	case 0x6000:
+		tp->version = RTL_VER_08;
+		tp->mii.supports_gmii = 1;
+		break;
+	case 0x6010:
+		tp->version = RTL_VER_09;
+		tp->mii.supports_gmii = 1;
+		break;
+	default:
+		netif_info(tp, probe, tp->netdev,
+			   "Unknown version 0x%04x\n", version);
+		break;
+	}
+}
+
+static void rtl8152_unload(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	if (tp->version != RTL_VER_01)
+		r8152_power_cut_en(tp, true);
+}
+
+static void rtl8153_unload(struct r8152 *tp)
+{
+	if (test_bit(RTL8152_UNPLUG, &tp->flags))
+		return;
+
+	tp->rtl_ops.power_cut_en(tp, false);
+}
+
+static int rtl_ops_init(struct r8152 *tp)
+{
+	struct rtl_ops *ops = &tp->rtl_ops;
+	int ret = 0;
+
+	switch (tp->version) {
+	case RTL_VER_01:
+	case RTL_VER_02:
+	case RTL_VER_07:
+		ops->init		= r8152b_init;
+		ops->enable		= rtl8152_enable;
+		ops->disable		= rtl8152_disable;
+		ops->up			= rtl8152_up;
+		ops->down		= rtl8152_down;
+		ops->unload		= rtl8152_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8152_get_eee;
+		ops->eee_set		= r8152_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8152_in_nway;
+		ops->aldps_enable	= r8152_aldps_en;
+		ops->u1u2_enable	= r8153_u1u2en;
+		ops->hw_phy_cfg		= r8152b_hw_phy_cfg;
+		ops->power_cut_en	= r8152_power_cut_en;
+		break;
+
+	case RTL_VER_03:
+	case RTL_VER_04:
+	case RTL_VER_05:
+	case RTL_VER_06:
+		ops->init		= r8153_init;
+		ops->enable		= rtl8153_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8153_up;
+		ops->down		= rtl8153_down;
+		ops->unload		= rtl8153_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8153_get_eee;
+		ops->eee_set		= r8153_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->aldps_enable	= r8153_aldps_en;
+		ops->u1u2_enable	= r8153_u1u2en;
+		ops->hw_phy_cfg		= r8153_hw_phy_cfg;
+		ops->power_cut_en	= r8153A_power_cut_en;
+		break;
+
+	case RTL_VER_08:
+	case RTL_VER_09:
+		ops->init		= r8153b_init;
+		ops->enable		= rtl8153_enable;
+		ops->disable		= rtl8153_disable;
+		ops->up			= rtl8153_up;
+		ops->down		= rtl8153_down;
+		ops->unload		= rtl8153_unload;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+		ops->eee_get		= r8153_get_eee;
+		ops->eee_set		= r8153b_set_eee;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+		ops->in_nway		= rtl8153_in_nway;
+		ops->aldps_enable	= r8153b_aldps_en;
+		ops->u1u2_enable	= r8153b_u1u2en;
+		ops->hw_phy_cfg		= r8153b_hw_phy_cfg;
+		ops->power_cut_en	= r8153B_power_cut_en;
+		break;
+
+	default:
+		ret = -ENODEV;
+		netif_err(tp, probe, tp->netdev, "Unknown Device\n");
+		break;
+	}
+
+	return ret;
+}
+
+static int rtl8152_probe(struct usb_interface *intf,
+			 const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct r8152 *tp;
+	struct net_device *netdev;
+	int ret;
+
+	if (!rtl_vendor_mode(intf)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+		dev_err(&intf->dev, "The kernel too old to set configuration\n");
+#else
+		usb_driver_set_configuration(udev, 1);
+#endif
+		return -ENODEV;
+	}
+
+	usb_reset_device(udev);
+	netdev = alloc_etherdev(sizeof(struct r8152));
+	if (!netdev) {
+		dev_err(&intf->dev, "Out of memory\n");
+		return -ENOMEM;
+	}
+
+	SET_NETDEV_DEV(netdev, &intf->dev);
+	tp = netdev_priv(netdev);
+	tp->msg_enable = 0x7FFF;
+
+	tp->udev = udev;
+	tp->netdev = netdev;
+	tp->intf = intf;
+
+	r8152b_get_version(tp);
+	ret = rtl_ops_init(tp);
+	if (ret)
+		goto out;
+
+	mutex_init(&tp->control);
+	INIT_DELAYED_WORK(&tp->schedule, rtl_work_func_t);
+	INIT_DELAYED_WORK(&tp->hw_phy_work, rtl_hw_phy_work_func_t);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	netdev->open = rtl8152_open;
+	netdev->stop = rtl8152_close;
+	netdev->get_stats = rtl8152_get_stats;
+	netdev->hard_start_xmit = rtl8152_start_xmit;
+	netdev->tx_timeout = rtl8152_tx_timeout;
+	netdev->change_mtu = rtl8152_change_mtu;
+	netdev->set_mac_address = rtl8152_set_mac_address;
+	netdev->do_ioctl = rtl8152_ioctl;
+	netdev->set_multicast_list = rtl8152_set_rx_mode;
+	netdev->vlan_rx_register = rtl8152_vlan_rx_register;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	netdev->vlan_rx_kill_vid = rtl8152_vlan_rx_kill_vid;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) */
+#else
+	netdev->netdev_ops = &rtl8152_netdev_ops;
+#endif /* HAVE_NET_DEVICE_OPS */
+
+	netdev->watchdog_timeo = RTL8152_TX_TIMEOUT;
+
+	netdev->features |= NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |
+			    NETIF_F_TSO | NETIF_F_FRAGLIST | NETIF_F_IPV6_CSUM |
+			    NETIF_F_TSO6 | NETIF_F_HW_VLAN_CTAG_RX |
+			    NETIF_F_HW_VLAN_CTAG_TX;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,38)
+	netdev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |
+			      NETIF_F_TSO | NETIF_F_FRAGLIST |
+			      NETIF_F_IPV6_CSUM | NETIF_F_TSO6 |
+			      NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_HW_VLAN_CTAG_TX;
+	netdev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
+				NETIF_F_HIGHDMA | NETIF_F_FRAGLIST |
+				NETIF_F_IPV6_CSUM | NETIF_F_TSO6;
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2,6,38) */
+
+	netdev->ethtool_ops = &ops;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+	netif_set_gso_max_size(netdev, RTL_LIMITED_TSO_SIZE);
+#else
+	netdev->features &= ~(NETIF_F_TSO | NETIF_F_TSO6);
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2,6,25) */
+
+	tp->mii.dev = netdev;
+	tp->mii.mdio_read = read_mii_word;
+	tp->mii.mdio_write = write_mii_word;
+	tp->mii.phy_id_mask = 0x3f;
+	tp->mii.reg_num_mask = 0x1f;
+	tp->mii.phy_id = R8152_PHY_ID;
+
+	switch (udev->speed) {
+	case USB_SPEED_SUPER:
+		tp->coalesce = COALESCE_SUPER;
+		break;
+	case USB_SPEED_HIGH:
+		tp->coalesce = COALESCE_HIGH;
+		break;
+	default:
+		tp->coalesce = COALESCE_SLOW;
+		break;
+	}
+
+	tp->autoneg = AUTONEG_ENABLE;
+	tp->speed = tp->mii.supports_gmii ? SPEED_1000 : SPEED_100;
+	tp->duplex = DUPLEX_FULL;
+
+	intf->needs_remote_wakeup = 1;
+
+	tp->rtl_ops.init(tp);
+	set_ethernet_addr(tp);
+
+	usb_set_intfdata(intf, tp);
+	netif_napi_add(netdev, &tp->napi, r8152_poll, RTL8152_NAPI_WEIGHT);
+
+	ret = register_netdev(netdev);
+	if (ret != 0) {
+		netif_err(tp, probe, netdev, "couldn't register the device\n");
+		goto out1;
+	}
+
+	if (!rtl_can_wakeup(tp))
+		__rtl_set_wol(tp, 0);
+
+	tp->saved_wolopts = __rtl_get_wol(tp);
+	if (tp->saved_wolopts)
+		device_set_wakeup_enable(&udev->dev, true);
+	else
+		device_set_wakeup_enable(&udev->dev, false);
+
+	/* usb_enable_autosuspend(udev); */
+
+	netif_info(tp, probe, netdev, "%s\n", DRIVER_VERSION);
+	netif_info(tp, probe, netdev, "%s\n", PATENTS);
+
+	return 0;
+
+out1:
+	netif_napi_del(&tp->napi);
+	usb_set_intfdata(intf, NULL);
+out:
+	free_netdev(netdev);
+	return ret;
+}
+
+static void rtl8152_disconnect(struct usb_interface *intf)
+{
+	struct r8152 *tp = usb_get_intfdata(intf);
+
+	usb_set_intfdata(intf, NULL);
+	if (tp) {
+		struct usb_device *udev = tp->udev;
+
+		if (udev->state == USB_STATE_NOTATTACHED)
+			set_bit(RTL8152_UNPLUG, &tp->flags);
+
+		netif_napi_del(&tp->napi);
+		unregister_netdev(tp->netdev);
+		cancel_delayed_work_sync(&tp->hw_phy_work);
+		tp->rtl_ops.unload(tp);
+		free_netdev(tp->netdev);
+	}
+}
+
+#define REALTEK_USB_DEVICE(vend, prod)	\
+	USB_DEVICE_INTERFACE_CLASS(vend, prod, USB_CLASS_VENDOR_SPEC) \
+}, \
+{ \
+	USB_DEVICE_AND_INTERFACE_INFO(vend, prod, USB_CLASS_COMM, \
+				      USB_CDC_SUBCLASS_ETHERNET, \
+				      USB_CDC_PROTO_NONE)
+
+/* table of devices that work with this driver */
+static struct usb_device_id rtl8152_table[] = {
+	/* Realtek */
+	{REALTEK_USB_DEVICE(VENDOR_ID_REALTEK, 0x8050)},
+	{REALTEK_USB_DEVICE(VENDOR_ID_REALTEK, 0x8152)},
+	{REALTEK_USB_DEVICE(VENDOR_ID_REALTEK, 0x8153)},
+
+	/* Samsung */
+	{REALTEK_USB_DEVICE(VENDOR_ID_SAMSUNG, 0xa101)},
+
+	/* Lenovo */
+	{REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x304f)},
+	{REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3052)},
+	{REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3054)},
+	{REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x3057)},
+	{REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x7205)},
+	{REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x720a)},
+	{REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x720b)},
+	{REALTEK_USB_DEVICE(VENDOR_ID_LENOVO, 0x720c)},
+
+	/* TP-LINK */
+	{REALTEK_USB_DEVICE(VENDOR_ID_TPLINK, 0x0601)},
+
+	/* Nvidia */
+	{REALTEK_USB_DEVICE(VENDOR_ID_NVIDIA,  0x09ff)},
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, rtl8152_table);
+
+static struct usb_driver rtl8152_driver = {
+	.name =		MODULENAME,
+	.id_table =	rtl8152_table,
+	.probe =	rtl8152_probe,
+	.disconnect =	rtl8152_disconnect,
+	.suspend =	rtl8152_suspend,
+	.resume =	rtl8152_resume,
+	.reset_resume =	rtl8152_reset_resume,
+	.pre_reset =	rtl8152_pre_reset,
+	.post_reset =	rtl8152_post_reset,
+	.supports_autosuspend = 1,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+	.disable_hub_initiated_lpm = 1,
+#endif
+};
+
+module_usb_driver(rtl8152_driver);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff --no-dereference -Nru kernel-22/kernel/include/config/auto.conf kernel-central/kernel/include/config/auto.conf
--- kernel-22/kernel/include/config/auto.conf	2017-01-18 13:07:12.000000000 +0200
+++ kernel-central/kernel/include/config/auto.conf	2017-02-12 12:16:30.616028808 +0200
@@ -5,7 +5,6 @@
 CONFIG_SCSI_DMA=y
 CONFIG_KERNEL_GZIP=y
 CONFIG_CRC32=y
-CONFIG_I2C_BOARDINFO=y
 CONFIG_HAVE_AOUT=y
 CONFIG_HIGH_RES_TIMERS=y
 CONFIG_FLATMEM_MANUAL=y
@@ -27,13 +26,10 @@
 CONFIG_IP_NF_QUEUE=y
 CONFIG_DYNAMIC_DEBUG=y
 CONFIG_DEFAULT_SECURITY_DAC=y
-CONFIG_NETDEV_1000=y
 CONFIG_SQUASHFS_XATTR=y
-CONFIG_IPV6=y
 CONFIG_DEFAULT_TCP_CONG="cubic"
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_USB_DEVICEFS=y
-CONFIG_WLAN=y
 CONFIG_NAMESPACES=y
 CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
 CONFIG_BLK_DEV_BSG=y
@@ -41,11 +37,7 @@
 CONFIG_CRYPTO_RNG2=y
 CONFIG_NETFILTER_NETLINK_QUEUE=y
 CONFIG_MSDOS_FS=y
-CONFIG_I2S_DLNA_DAC_INTRA=y
-CONFIG_TUN=y
-CONFIG_CFG80211=y
 CONFIG_LZO_DECOMPRESS=y
-CONFIG_WIRELESS_EXT_SYSFS=y
 CONFIG_USB=y
 CONFIG_JFFS2_LZO=y
 CONFIG_SND_HRTIMER=y
@@ -64,18 +56,15 @@
 CONFIG_SND_SUV_SOC_PCM=y
 CONFIG_SILAN_DSP_SUBSYSTEM=y
 CONFIG_CEPH_LIB=y
-CONFIG_SND_MIXER_OSS=y
 CONFIG_SUNRPC_GSS=y
 CONFIG_RTC_INTF_SYSFS=y
 CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_SND_OSSEMUL=y
 CONFIG_ZLIB_INFLATE=y
 CONFIG_CRC_T10DIF=y
 CONFIG_IP_PNP=y
 CONFIG_RTC_INTF_PROC=y
 CONFIG_USB_DEVICE_CLASS=y
 CONFIG_LOCKD=y
-CONFIG_SOUND_OSS_CORE=y
 CONFIG_JFFS2_FS=y
 CONFIG_BSD_PROCESS_ACCT=y
 CONFIG_USB_STORAGE=y
@@ -86,27 +75,23 @@
 CONFIG_GENERIC_GPIO=y
 CONFIG_ROOT_NFS=y
 CONFIG_USER_NS=y
+CONFIG_SND_PCM_XRUN_DEBUG=y
 CONFIG_BUG=y
-CONFIG_MAC80211_HAS_RC=y
 CONFIG_PM=y
 CONFIG_SPI=y
 CONFIG_DEVKMEM=y
 CONFIG_SILAN_DRM=y
 CONFIG_SPLIT_PTLOCK_CPUS=4
-CONFIG_WEXT_CORE=y
 CONFIG_NLS=y
+CONFIG_SND_VERBOSE_PRINTK=y
 CONFIG_SPI_SPIDEV=y
-CONFIG_I2C_GPIO=y
 CONFIG_SPI_BITBANG=y
 CONFIG_SYSFS_DEPRECATED=y
 CONFIG_CRYPTO_WORKQUEUE=y
-CONFIG_SND_PCM_OSS=y
 CONFIG_NETDEVICES=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_EVENTFD=y
 CONFIG_FS_POSIX_ACL=y
-CONFIG_IPV6_SIT=y
-CONFIG_XFRM=y
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 CONFIG_IP_NF_TARGET_MASQUERADE=y
 CONFIG_CPU_CSKYV1=y
@@ -118,12 +103,9 @@
 CONFIG_NETFILTER_ADVANCED=y
 CONFIG_JFFS2_FS_DEBUG=0
 CONFIG_NETFILTER_NETLINK_LOG=y
-CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
 CONFIG_DEFAULT_CFQ=y
-CONFIG_INET6_XFRM_MODE_TUNNEL=y
 CONFIG_IP_NF_FILTER=y
 CONFIG_FAT_FS=y
-CONFIG_INET_TUNNEL=y
 CONFIG_MMC_BLOCK_BOUNCE=y
 CONFIG_GENERIC_CLOCKEVENTS=y
 CONFIG_IOSCHED_CFQ=y
@@ -134,6 +116,7 @@
 CONFIG_CRYPTO_RNG=m
 CONFIG_LBDAF=y
 CONFIG_SILAN_PADMUX=y
+CONFIG_SND_DEBUG_VERBOSE=y
 CONFIG_HAVE_GENERIC_HARDIRQS=y
 CONFIG_BINFMT_ELF=y
 CONFIG_SCSI_PROC_FS=y
@@ -143,7 +126,6 @@
 CONFIG_NETFILTER_XTABLES=y
 CONFIG_SLABINFO=y
 CONFIG_CRYPTO_HW=y
-CONFIG_MAC80211_RC_MINSTREL_HT=y
 CONFIG_JFFS2_FS_WRITEBUFFER=y
 CONFIG_SPI_MASTER=y
 CONFIG_XZ_DEC_X86=y
@@ -160,7 +142,6 @@
 CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_DMADEVICES=y
 CONFIG_NF_CONNTRACK_EVENTS=y
-CONFIG_IPV6_NDISC_NODETYPE=y
 CONFIG_SYSVIPC=y
 CONFIG_CRYPTO_PCOMP2=y
 CONFIG_USB_DWC_HCD=y
@@ -180,7 +161,6 @@
 CONFIG_NFS_COMMON=y
 CONFIG_CRYPTO_HASH=y
 CONFIG_LOG_BUF_SHIFT=17
-CONFIG_SOUND_OSS_CORE_PRECLAIM=y
 CONFIG_EXTRA_FIRMWARE=""
 CONFIG_VIRT_TO_BUS=y
 CONFIG_VFAT_FS=y
@@ -197,7 +177,6 @@
 CONFIG_CRYPTO_MANAGER2=y
 CONFIG_XZ_DEC_BCJ=y
 CONFIG_PM_SLEEP=y
-CONFIG_I2C=y
 CONFIG_JFFS2_ZLIB=y
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_CRYPTO_ECB=y
@@ -225,6 +204,7 @@
 CONFIG_INPUT_EVDEV=y
 CONFIG_SND_JACK=y
 CONFIG_DLNA_GPIO=y
+CONFIG_USB_NET_CDCETHER=y
 CONFIG_PACKET=y
 CONFIG_NFS_V3=y
 CONFIG_INET=y
@@ -234,32 +214,28 @@
 CONFIG_FREEZER=y
 CONFIG_CSKY_INSTRUCTION_CACHE=y
 CONFIG_CPU_CLOCK_FREQ=300000000
-CONFIG_SILAN_INNER_CODEC_LINEOUT=y
 CONFIG_RTC_LIB=y
-CONFIG_NETFILTER_XT_MATCH_POLICY=m
 CONFIG_HAVE_KPROBES=y
 CONFIG_CRYPTO_AES=y
 CONFIG_GPIOLIB=y
 CONFIG_NF_CONNTRACK_MARK=y
 CONFIG_NETFILTER=y
+CONFIG_USB_NET_AX8877X=y
 CONFIG_SQUASHFS_EMBEDDED=y
 CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_APB_FREQ=150000000
 CONFIG_TIME_LOW_RES=y
 CONFIG_IP_MROUTE=y
+CONFIG_RTC_DRV_SILAN=y
 CONFIG_NF_NAT_NEEDED=y
-CONFIG_SND_DRIVERS=y
 CONFIG_NO_HZ=y
 CONFIG_POSIX_MQUEUE=y
-CONFIG_RTL8188EU=y
 CONFIG_SERIAL_DMA_SILAN=y
 CONFIG_MTD_BLKDEVS=y
-CONFIG_SND_PCM_OSS_PLUGINS=y
 CONFIG_SYSCTL_SYSCALL=y
 CONFIG_JFFS2_CMODE_PRIORITY=y
 CONFIG_ANDROID_PARANOID_NETWORK=y
 CONFIG_PANIC_TIMEOUT=0
-CONFIG_CFG80211_DEFAULT_PS=y
 CONFIG_PREEMPT_NONE=y
 CONFIG_CSKY_USER_SEGMENT_CACHE=y
 CONFIG_HAVE_KERNEL_GZIP=y
@@ -274,7 +250,7 @@
 CONFIG_LEDS_GPIO_PLATFORM=y
 CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
 CONFIG_IP_NF_IPTABLES=y
-CONFIG_CMDLINE="root=/dev/mtdblock2 rootfstype=squashfs rw console=ttyAMA0,115200 rdinit=/sbin/init mem=28M"
+CONFIG_CMDLINE="console=ttyAMA0,115200 console=tty0 ip=dhcp root=/dev/nfs rw init=/sbin/init mem=28M"
 CONFIG_HAVE_DMA_API_DEBUG=y
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_GENERIC_IRQ_SHOW=y
@@ -286,13 +262,11 @@
 CONFIG_HAVE_KRETPROBES=y
 CONFIG_NFS_V4=y
 CONFIG_INLINE_READ_UNLOCK=y
-CONFIG_SOUND_PRIME=y
 CONFIG_HAS_DMA=y
 CONFIG_SCSI=y
 CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
 CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 CONFIG_SILAN_UART_PORT2=y
-CONFIG_PHYLIB=y
 CONFIG_JFFS2_RTIME=y
 CONFIG_IPC_NS=y
 CONFIG_MISC_FILESYSTEMS=y
@@ -301,18 +275,13 @@
 CONFIG_SND_VERBOSE_PROCFS=y
 CONFIG_INPUT_FF_MEMLESS=y
 CONFIG_CHR_DEV_SG=y
-CONFIG_INET6_XFRM_MODE_TRANSPORT=y
 CONFIG_CRYPTO_ARC4=y
-CONFIG_SILAN_TESTIO=y
 CONFIG_SCSI_TGT=y
 CONFIG_CRYPTO_MANAGER=y
 CONFIG_RT_MUTEXES=y
 CONFIG_CSKY=y
-CONFIG_I2C_ALGOBIT=y
 CONFIG_MMC_BLOCK=y
 CONFIG_EXPERT=y
-CONFIG_WIRELESS=y
-CONFIG_WEXT_PROC=y
 CONFIG_SQUASHFS=y
 CONFIG_NET_SCH_TBF=y
 CONFIG_PERF_USE_VMALLOC=y
@@ -320,27 +289,25 @@
 CONFIG_ARCH_POPULATES_NODE_MAP=y
 CONFIG_FRAME_WARN=1024
 CONFIG_GENERIC_HWEIGHT=y
-CONFIG_SILAN_LCD=y
 CONFIG_MMC=y
 CONFIG_LZO_COMPRESS=y
 CONFIG_TTY_PRINTK=y
 CONFIG_RAM_BASE=0x0000000
 CONFIG_INLINE_SPIN_UNLOCK=y
+CONFIG_SND_DEBUG=y
 CONFIG_HZ=100
-CONFIG_I2C_HELPER_AUTO=y
+CONFIG_USB_RTL8152=y
 CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
 CONFIG_DEFAULT_IOSCHED="cfq"
 CONFIG_NLATTR=y
 CONFIG_TCP_CONG_CUBIC=y
 CONFIG_SUSPEND_FREEZER=y
-CONFIG_SND_SUPPORT_OLD_API=y
 CONFIG_NETFILTER_XT_CONNMARK=y
 CONFIG_FIRMWARE_IN_KERNEL=y
 CONFIG_SYSFS=y
 CONFIG_NETFILTER_XT_MATCH_LIMIT=y
 CONFIG_XZ_DEC_ARM=y
 CONFIG_SERIAL_SILAN_CONSOLE=y
-CONFIG_I2C_COMPAT=y
 CONFIG_MSDOS_PARTITION=y
 CONFIG_HAVE_OPROFILE=y
 CONFIG_HAVE_GENERIC_DMA_COHERENT=y
@@ -358,7 +325,6 @@
 CONFIG_DEFAULT_SECURITY=""
 CONFIG_TICK_ONESHOT=y
 CONFIG_GPIO_SILAN=y
-CONFIG_WIRELESS_EXT=y
 CONFIG_SOFT_HANDMISSALIGN=y
 CONFIG_TINY_RCU=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
@@ -379,41 +345,36 @@
 CONFIG_HAVE_C_RECORDMCOUNT=y
 CONFIG_HAVE_PERF_EVENTS=y
 CONFIG_SLAB=y
-CONFIG_STMMAC_ETH=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
 CONFIG_SND_TIMER=y
 CONFIG_FAT_DEFAULT_CODEPAGE=936
 CONFIG_BLK_DEV=y
-CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
 CONFIG_NFS_ACL_SUPPORT=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
 CONFIG_CRYPTO_ANSI_CPRNG=m
 CONFIG_NET_SCHED=y
 CONFIG_HAVE_KERNEL_LZO=y
-CONFIG_MAC80211_RC_MINSTREL=y
 CONFIG_ELF_CORE=y
 CONFIG_USB_SUPPORT=y
 CONFIG_MTD_CHAR=y
 CONFIG_FLAT_NODE_MEM_MAP=y
 CONFIG_LEDS_GPIO=y
-CONFIG_CFG80211_WEXT=y
 CONFIG_BLK_DEV_RAM=y
 CONFIG_SND_SUV_SOC_I2S_DLNA=y
-CONFIG_INET6_XFRM_MODE_BEET=y
 CONFIG_POSIX_MQUEUE_SYSCTL=y
 CONFIG_SND_SOC_SILAN_CODEC=y
 CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
 CONFIG_CSKY_DATA_CACHE=y
 CONFIG_SYSVIPC_SYSCTL=y
-CONFIG_I2C_CHARDEV=y
 CONFIG_CROSS_COMPILE="csky-linux-"
+CONFIG_I2S_DLNA_DAC_MASTER=y
 CONFIG_XZ_DEC_ARMTHUMB=y
 CONFIG_SERIAL_SILAN=y
+CONFIG_USB_USBNET=y
 CONFIG_SCSI_MULTI_LUN=y
 CONFIG_NEW_LEDS=y
 CONFIG_SWAP=y
-CONFIG_MAC80211=y
 CONFIG_BLK_DEV_SD=y
 CONFIG_NETFILTER_NETLINK=y
 CONFIG_MODULE_UNLOAD=y
@@ -431,6 +392,7 @@
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_RTC_INTF_DEV=y
 CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_I2S_DLNA_DAC_EXTRA=y
 CONFIG_USB_DWC_HCD_OLD=y
 CONFIG_NET_ACTIVITY_STATS=y
 CONFIG_NLS_DEFAULT="iso8859-1"
diff --no-dereference -Nru kernel-22/kernel/include/config/kernel.release kernel-central/kernel/include/config/kernel.release
--- kernel-22/kernel/include/config/kernel.release	2017-01-18 13:07:12.000000000 +0200
+++ kernel-central/kernel/include/config/kernel.release	2017-02-12 13:16:13.215832071 +0200
@@ -1 +1 @@
-3.0.8+
+3.0.8
diff --no-dereference -Nru kernel-22/kernel/include/config/tristate.conf kernel-central/kernel/include/config/tristate.conf
--- kernel-22/kernel/include/config/tristate.conf	2017-01-18 13:07:12.000000000 +0200
+++ kernel-central/kernel/include/config/tristate.conf	2017-02-12 12:16:30.616028808 +0200
@@ -5,13 +5,10 @@
 CONFIG_LEDS_TRIGGER_HEARTBEAT=Y
 CONFIG_SCSI_DH=Y
 CONFIG_IP_NF_QUEUE=Y
-CONFIG_IPV6=Y
 CONFIG_NETFILTER_XT_TARGET_RATEEST=Y
 CONFIG_CRYPTO_RNG2=Y
 CONFIG_NETFILTER_NETLINK_QUEUE=Y
 CONFIG_MSDOS_FS=Y
-CONFIG_TUN=Y
-CONFIG_CFG80211=Y
 CONFIG_LZO_DECOMPRESS=Y
 CONFIG_USB=Y
 CONFIG_SND_HRTIMER=Y
@@ -21,7 +18,6 @@
 CONFIG_SND_SUV_SOC_PCM=Y
 CONFIG_SILAN_DSP_SUBSYSTEM=Y
 CONFIG_CEPH_LIB=Y
-CONFIG_SND_MIXER_OSS=Y
 CONFIG_SUNRPC_GSS=Y
 CONFIG_LEDS_TRIGGER_TIMER=Y
 CONFIG_ZLIB_INFLATE=Y
@@ -32,20 +28,15 @@
 CONFIG_SILAN_DRM=Y
 CONFIG_NLS=Y
 CONFIG_SPI_SPIDEV=Y
-CONFIG_I2C_GPIO=Y
 CONFIG_SPI_BITBANG=Y
 CONFIG_CRYPTO_WORKQUEUE=Y
-CONFIG_SND_PCM_OSS=Y
 CONFIG_IOSCHED_DEADLINE=Y
-CONFIG_IPV6_SIT=Y
 CONFIG_IP_NF_TARGET_MASQUERADE=Y
 CONFIG_SCSI_WAIT_SCAN=M
 CONFIG_NF_DEFRAG_IPV4=Y
 CONFIG_NETFILTER_NETLINK_LOG=Y
-CONFIG_INET6_XFRM_MODE_TUNNEL=Y
 CONFIG_IP_NF_FILTER=Y
 CONFIG_FAT_FS=Y
-CONFIG_INET_TUNNEL=Y
 CONFIG_IOSCHED_CFQ=Y
 CONFIG_LEDS_TRIGGER_BACKLIGHT=Y
 CONFIG_CRYPTO_RNG=M
@@ -70,7 +61,6 @@
 CONFIG_CRYPTO_CBC=Y
 CONFIG_SILAN_WDT=Y
 CONFIG_CRYPTO_MANAGER2=Y
-CONFIG_I2C=Y
 CONFIG_CRYPTO_ECB=Y
 CONFIG_ZLIB_DEFLATE=Y
 CONFIG_SUNRPC=Y
@@ -81,10 +71,11 @@
 CONFIG_SND_PCM=Y
 CONFIG_INPUT_EVDEV=Y
 CONFIG_DLNA_GPIO=Y
+CONFIG_USB_NET_CDCETHER=Y
 CONFIG_PACKET=Y
-CONFIG_NETFILTER_XT_MATCH_POLICY=M
 CONFIG_CRYPTO_AES=Y
-CONFIG_RTL8188EU=Y
+CONFIG_USB_NET_AX8877X=Y
+CONFIG_RTC_DRV_SILAN=Y
 CONFIG_MTD_BLKDEVS=Y
 CONFIG_LIBCRC32C=Y
 CONFIG_CRYPTO=Y
@@ -92,24 +83,19 @@
 CONFIG_SCSI_MOD=Y
 CONFIG_CRYPTO_CRC32C=Y
 CONFIG_SERIAL_CORE=Y
-CONFIG_SOUND_PRIME=Y
 CONFIG_SCSI=Y
 CONFIG_LEDS_TRIGGER_DEFAULT_ON=Y
-CONFIG_PHYLIB=Y
 CONFIG_INPUT_FF_MEMLESS=Y
 CONFIG_CHR_DEV_SG=Y
-CONFIG_INET6_XFRM_MODE_TRANSPORT=Y
 CONFIG_CRYPTO_ARC4=Y
-CONFIG_SILAN_TESTIO=Y
 CONFIG_SCSI_TGT=Y
 CONFIG_CRYPTO_MANAGER=Y
-CONFIG_I2C_ALGOBIT=Y
 CONFIG_MMC_BLOCK=Y
 CONFIG_SQUASHFS=Y
 CONFIG_NET_SCH_TBF=Y
-CONFIG_SILAN_LCD=Y
 CONFIG_MMC=Y
 CONFIG_LZO_COMPRESS=Y
+CONFIG_USB_RTL8152=Y
 CONFIG_TCP_CONG_CUBIC=Y
 CONFIG_NETFILTER_XT_CONNMARK=Y
 CONFIG_NETFILTER_XT_MATCH_LIMIT=Y
@@ -123,7 +109,6 @@
 CONFIG_SND=Y
 CONFIG_IKCONFIG=Y
 CONFIG_MTD_BLOCK2MTD=Y
-CONFIG_STMMAC_ETH=Y
 CONFIG_SND_TIMER=Y
 CONFIG_NFS_ACL_SUPPORT=Y
 CONFIG_CRYPTO_MICHAEL_MIC=Y
@@ -132,10 +117,8 @@
 CONFIG_LEDS_GPIO=Y
 CONFIG_BLK_DEV_RAM=Y
 CONFIG_SND_SUV_SOC_I2S_DLNA=Y
-CONFIG_INET6_XFRM_MODE_BEET=Y
 CONFIG_SND_SOC_SILAN_CODEC=Y
-CONFIG_I2C_CHARDEV=Y
-CONFIG_MAC80211=Y
+CONFIG_USB_USBNET=Y
 CONFIG_BLK_DEV_SD=Y
 CONFIG_NETFILTER_NETLINK=Y
 CONFIG_BITREVERSE=Y
diff --no-dereference -Nru kernel-22/kernel/include/generated/autoconf.h kernel-central/kernel/include/generated/autoconf.h
--- kernel-22/kernel/include/generated/autoconf.h	2017-01-18 13:07:12.000000000 +0200
+++ kernel-central/kernel/include/generated/autoconf.h	2017-02-12 12:16:30.617028884 +0200
@@ -5,7 +5,6 @@
 #define CONFIG_SCSI_DMA 1
 #define CONFIG_KERNEL_GZIP 1
 #define CONFIG_CRC32 1
-#define CONFIG_I2C_BOARDINFO 1
 #define CONFIG_HAVE_AOUT 1
 #define CONFIG_HIGH_RES_TIMERS 1
 #define CONFIG_FLATMEM_MANUAL 1
@@ -27,13 +26,10 @@
 #define CONFIG_IP_NF_QUEUE 1
 #define CONFIG_DYNAMIC_DEBUG 1
 #define CONFIG_DEFAULT_SECURITY_DAC 1
-#define CONFIG_NETDEV_1000 1
 #define CONFIG_SQUASHFS_XATTR 1
-#define CONFIG_IPV6 1
 #define CONFIG_DEFAULT_TCP_CONG "cubic"
 #define CONFIG_UEVENT_HELPER_PATH "/sbin/hotplug"
 #define CONFIG_USB_DEVICEFS 1
-#define CONFIG_WLAN 1
 #define CONFIG_NAMESPACES 1
 #define CONFIG_DEFAULT_MESSAGE_LOGLEVEL 4
 #define CONFIG_BLK_DEV_BSG 1
@@ -41,11 +37,7 @@
 #define CONFIG_CRYPTO_RNG2 1
 #define CONFIG_NETFILTER_NETLINK_QUEUE 1
 #define CONFIG_MSDOS_FS 1
-#define CONFIG_I2S_DLNA_DAC_INTRA 1
-#define CONFIG_TUN 1
-#define CONFIG_CFG80211 1
 #define CONFIG_LZO_DECOMPRESS 1
-#define CONFIG_WIRELESS_EXT_SYSFS 1
 #define CONFIG_USB 1
 #define CONFIG_JFFS2_LZO 1
 #define CONFIG_SND_HRTIMER 1
@@ -64,18 +56,15 @@
 #define CONFIG_SND_SUV_SOC_PCM 1
 #define CONFIG_SILAN_DSP_SUBSYSTEM 1
 #define CONFIG_CEPH_LIB 1
-#define CONFIG_SND_MIXER_OSS 1
 #define CONFIG_SUNRPC_GSS 1
 #define CONFIG_RTC_INTF_SYSFS 1
 #define CONFIG_LEDS_TRIGGER_TIMER 1
-#define CONFIG_SND_OSSEMUL 1
 #define CONFIG_ZLIB_INFLATE 1
 #define CONFIG_CRC_T10DIF 1
 #define CONFIG_IP_PNP 1
 #define CONFIG_RTC_INTF_PROC 1
 #define CONFIG_USB_DEVICE_CLASS 1
 #define CONFIG_LOCKD 1
-#define CONFIG_SOUND_OSS_CORE 1
 #define CONFIG_JFFS2_FS 1
 #define CONFIG_BSD_PROCESS_ACCT 1
 #define CONFIG_USB_STORAGE 1
@@ -86,27 +75,23 @@
 #define CONFIG_GENERIC_GPIO 1
 #define CONFIG_ROOT_NFS 1
 #define CONFIG_USER_NS 1
+#define CONFIG_SND_PCM_XRUN_DEBUG 1
 #define CONFIG_BUG 1
-#define CONFIG_MAC80211_HAS_RC 1
 #define CONFIG_PM 1
 #define CONFIG_SPI 1
 #define CONFIG_DEVKMEM 1
 #define CONFIG_SILAN_DRM 1
 #define CONFIG_SPLIT_PTLOCK_CPUS 4
-#define CONFIG_WEXT_CORE 1
 #define CONFIG_NLS 1
+#define CONFIG_SND_VERBOSE_PRINTK 1
 #define CONFIG_SPI_SPIDEV 1
-#define CONFIG_I2C_GPIO 1
 #define CONFIG_SPI_BITBANG 1
 #define CONFIG_SYSFS_DEPRECATED 1
 #define CONFIG_CRYPTO_WORKQUEUE 1
-#define CONFIG_SND_PCM_OSS 1
 #define CONFIG_NETDEVICES 1
 #define CONFIG_IOSCHED_DEADLINE 1
 #define CONFIG_EVENTFD 1
 #define CONFIG_FS_POSIX_ACL 1
-#define CONFIG_IPV6_SIT 1
-#define CONFIG_XFRM 1
 #define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
 #define CONFIG_IP_NF_TARGET_MASQUERADE 1
 #define CONFIG_CPU_CSKYV1 1
@@ -118,12 +103,9 @@
 #define CONFIG_NETFILTER_ADVANCED 1
 #define CONFIG_JFFS2_FS_DEBUG 0
 #define CONFIG_NETFILTER_NETLINK_LOG 1
-#define CONFIG_MAC80211_RC_DEFAULT_MINSTREL 1
 #define CONFIG_DEFAULT_CFQ 1
-#define CONFIG_INET6_XFRM_MODE_TUNNEL 1
 #define CONFIG_IP_NF_FILTER 1
 #define CONFIG_FAT_FS 1
-#define CONFIG_INET_TUNNEL 1
 #define CONFIG_MMC_BLOCK_BOUNCE 1
 #define CONFIG_GENERIC_CLOCKEVENTS 1
 #define CONFIG_IOSCHED_CFQ 1
@@ -134,6 +116,7 @@
 #define CONFIG_CRYPTO_RNG_MODULE 1
 #define CONFIG_LBDAF 1
 #define CONFIG_SILAN_PADMUX 1
+#define CONFIG_SND_DEBUG_VERBOSE 1
 #define CONFIG_HAVE_GENERIC_HARDIRQS 1
 #define CONFIG_BINFMT_ELF 1
 #define CONFIG_SCSI_PROC_FS 1
@@ -143,7 +126,6 @@
 #define CONFIG_NETFILTER_XTABLES 1
 #define CONFIG_SLABINFO 1
 #define CONFIG_CRYPTO_HW 1
-#define CONFIG_MAC80211_RC_MINSTREL_HT 1
 #define CONFIG_JFFS2_FS_WRITEBUFFER 1
 #define CONFIG_SPI_MASTER 1
 #define CONFIG_XZ_DEC_X86 1
@@ -160,7 +142,6 @@
 #define CONFIG_SERIAL_CORE_CONSOLE 1
 #define CONFIG_DMADEVICES 1
 #define CONFIG_NF_CONNTRACK_EVENTS 1
-#define CONFIG_IPV6_NDISC_NODETYPE 1
 #define CONFIG_SYSVIPC 1
 #define CONFIG_CRYPTO_PCOMP2 1
 #define CONFIG_USB_DWC_HCD 1
@@ -180,7 +161,6 @@
 #define CONFIG_NFS_COMMON 1
 #define CONFIG_CRYPTO_HASH 1
 #define CONFIG_LOG_BUF_SHIFT 17
-#define CONFIG_SOUND_OSS_CORE_PRECLAIM 1
 #define CONFIG_EXTRA_FIRMWARE ""
 #define CONFIG_VIRT_TO_BUS 1
 #define CONFIG_VFAT_FS 1
@@ -197,7 +177,6 @@
 #define CONFIG_CRYPTO_MANAGER2 1
 #define CONFIG_XZ_DEC_BCJ 1
 #define CONFIG_PM_SLEEP 1
-#define CONFIG_I2C 1
 #define CONFIG_JFFS2_ZLIB 1
 #define CONFIG_VM_EVENT_COUNTERS 1
 #define CONFIG_CRYPTO_ECB 1
@@ -225,6 +204,7 @@
 #define CONFIG_INPUT_EVDEV 1
 #define CONFIG_SND_JACK 1
 #define CONFIG_DLNA_GPIO 1
+#define CONFIG_USB_NET_CDCETHER 1
 #define CONFIG_PACKET 1
 #define CONFIG_NFS_V3 1
 #define CONFIG_INET 1
@@ -234,32 +214,28 @@
 #define CONFIG_FREEZER 1
 #define CONFIG_CSKY_INSTRUCTION_CACHE 1
 #define CONFIG_CPU_CLOCK_FREQ 300000000
-#define CONFIG_SILAN_INNER_CODEC_LINEOUT 1
 #define CONFIG_RTC_LIB 1
-#define CONFIG_NETFILTER_XT_MATCH_POLICY_MODULE 1
 #define CONFIG_HAVE_KPROBES 1
 #define CONFIG_CRYPTO_AES 1
 #define CONFIG_GPIOLIB 1
 #define CONFIG_NF_CONNTRACK_MARK 1
 #define CONFIG_NETFILTER 1
+#define CONFIG_USB_NET_AX8877X 1
 #define CONFIG_SQUASHFS_EMBEDDED 1
 #define CONFIG_BLK_DEV_RAM_COUNT 16
 #define CONFIG_APB_FREQ 150000000
 #define CONFIG_TIME_LOW_RES 1
 #define CONFIG_IP_MROUTE 1
+#define CONFIG_RTC_DRV_SILAN 1
 #define CONFIG_NF_NAT_NEEDED 1
-#define CONFIG_SND_DRIVERS 1
 #define CONFIG_NO_HZ 1
 #define CONFIG_POSIX_MQUEUE 1
-#define CONFIG_RTL8188EU 1
 #define CONFIG_SERIAL_DMA_SILAN 1
 #define CONFIG_MTD_BLKDEVS 1
-#define CONFIG_SND_PCM_OSS_PLUGINS 1
 #define CONFIG_SYSCTL_SYSCALL 1
 #define CONFIG_JFFS2_CMODE_PRIORITY 1
 #define CONFIG_ANDROID_PARANOID_NETWORK 1
 #define CONFIG_PANIC_TIMEOUT 0
-#define CONFIG_CFG80211_DEFAULT_PS 1
 #define CONFIG_PREEMPT_NONE 1
 #define CONFIG_CSKY_USER_SEGMENT_CACHE 1
 #define CONFIG_HAVE_KERNEL_GZIP 1
@@ -274,7 +250,7 @@
 #define CONFIG_LEDS_GPIO_PLATFORM 1
 #define CONFIG_DEFAULT_MMAP_MIN_ADDR 4096
 #define CONFIG_IP_NF_IPTABLES 1
-#define CONFIG_CMDLINE "root=/dev/mtdblock2 rootfstype=squashfs rw console=ttyAMA0,115200 rdinit=/sbin/init mem=28M"
+#define CONFIG_CMDLINE "console=ttyAMA0,115200 console=tty0 ip=dhcp root=/dev/nfs rw init=/sbin/init mem=28M"
 #define CONFIG_HAVE_DMA_API_DEBUG 1
 #define CONFIG_USB_ARCH_HAS_HCD 1
 #define CONFIG_GENERIC_IRQ_SHOW 1
@@ -286,13 +262,11 @@
 #define CONFIG_HAVE_KRETPROBES 1
 #define CONFIG_NFS_V4 1
 #define CONFIG_INLINE_READ_UNLOCK 1
-#define CONFIG_SOUND_PRIME 1
 #define CONFIG_HAS_DMA 1
 #define CONFIG_SCSI 1
 #define CONFIG_LEDS_TRIGGER_DEFAULT_ON 1
 #define CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE 3
 #define CONFIG_SILAN_UART_PORT2 1
-#define CONFIG_PHYLIB 1
 #define CONFIG_JFFS2_RTIME 1
 #define CONFIG_IPC_NS 1
 #define CONFIG_MISC_FILESYSTEMS 1
@@ -301,18 +275,13 @@
 #define CONFIG_SND_VERBOSE_PROCFS 1
 #define CONFIG_INPUT_FF_MEMLESS 1
 #define CONFIG_CHR_DEV_SG 1
-#define CONFIG_INET6_XFRM_MODE_TRANSPORT 1
 #define CONFIG_CRYPTO_ARC4 1
-#define CONFIG_SILAN_TESTIO 1
 #define CONFIG_SCSI_TGT 1
 #define CONFIG_CRYPTO_MANAGER 1
 #define CONFIG_RT_MUTEXES 1
 #define CONFIG_CSKY 1
-#define CONFIG_I2C_ALGOBIT 1
 #define CONFIG_MMC_BLOCK 1
 #define CONFIG_EXPERT 1
-#define CONFIG_WIRELESS 1
-#define CONFIG_WEXT_PROC 1
 #define CONFIG_SQUASHFS 1
 #define CONFIG_NET_SCH_TBF 1
 #define CONFIG_PERF_USE_VMALLOC 1
@@ -320,27 +289,25 @@
 #define CONFIG_ARCH_POPULATES_NODE_MAP 1
 #define CONFIG_FRAME_WARN 1024
 #define CONFIG_GENERIC_HWEIGHT 1
-#define CONFIG_SILAN_LCD 1
 #define CONFIG_MMC 1
 #define CONFIG_LZO_COMPRESS 1
 #define CONFIG_TTY_PRINTK 1
 #define CONFIG_RAM_BASE 0x0000000
 #define CONFIG_INLINE_SPIN_UNLOCK 1
+#define CONFIG_SND_DEBUG 1
 #define CONFIG_HZ 100
-#define CONFIG_I2C_HELPER_AUTO 1
+#define CONFIG_USB_RTL8152 1
 #define CONFIG_INLINE_SPIN_UNLOCK_IRQ 1
 #define CONFIG_DEFAULT_IOSCHED "cfq"
 #define CONFIG_NLATTR 1
 #define CONFIG_TCP_CONG_CUBIC 1
 #define CONFIG_SUSPEND_FREEZER 1
-#define CONFIG_SND_SUPPORT_OLD_API 1
 #define CONFIG_NETFILTER_XT_CONNMARK 1
 #define CONFIG_FIRMWARE_IN_KERNEL 1
 #define CONFIG_SYSFS 1
 #define CONFIG_NETFILTER_XT_MATCH_LIMIT 1
 #define CONFIG_XZ_DEC_ARM 1
 #define CONFIG_SERIAL_SILAN_CONSOLE 1
-#define CONFIG_I2C_COMPAT 1
 #define CONFIG_MSDOS_PARTITION 1
 #define CONFIG_HAVE_OPROFILE 1
 #define CONFIG_HAVE_GENERIC_DMA_COHERENT 1
@@ -358,7 +325,6 @@
 #define CONFIG_DEFAULT_SECURITY ""
 #define CONFIG_TICK_ONESHOT 1
 #define CONFIG_GPIO_SILAN 1
-#define CONFIG_WIRELESS_EXT 1
 #define CONFIG_SOFT_HANDMISSALIGN 1
 #define CONFIG_TINY_RCU 1
 #define CONFIG_RWSEM_GENERIC_SPINLOCK 1
@@ -379,41 +345,36 @@
 #define CONFIG_HAVE_C_RECORDMCOUNT 1
 #define CONFIG_HAVE_PERF_EVENTS 1
 #define CONFIG_SLAB 1
-#define CONFIG_STMMAC_ETH 1
 #define CONFIG_SYS_SUPPORTS_APM_EMULATION 1
 #define CONFIG_SND_TIMER 1
 #define CONFIG_FAT_DEFAULT_CODEPAGE 936
 #define CONFIG_BLK_DEV 1
-#define CONFIG_MAC80211_RC_DEFAULT "minstrel_ht"
 #define CONFIG_NFS_ACL_SUPPORT 1
 #define CONFIG_UNIX98_PTYS 1
 #define CONFIG_CRYPTO_MICHAEL_MIC 1
 #define CONFIG_CRYPTO_ANSI_CPRNG_MODULE 1
 #define CONFIG_NET_SCHED 1
 #define CONFIG_HAVE_KERNEL_LZO 1
-#define CONFIG_MAC80211_RC_MINSTREL 1
 #define CONFIG_ELF_CORE 1
 #define CONFIG_USB_SUPPORT 1
 #define CONFIG_MTD_CHAR 1
 #define CONFIG_FLAT_NODE_MEM_MAP 1
 #define CONFIG_LEDS_GPIO 1
-#define CONFIG_CFG80211_WEXT 1
 #define CONFIG_BLK_DEV_RAM 1
 #define CONFIG_SND_SUV_SOC_I2S_DLNA 1
-#define CONFIG_INET6_XFRM_MODE_BEET 1
 #define CONFIG_POSIX_MQUEUE_SYSCTL 1
 #define CONFIG_SND_SOC_SILAN_CODEC 1
 #define CONFIG_GENERIC_CLOCKEVENTS_BUILD 1
 #define CONFIG_CSKY_DATA_CACHE 1
 #define CONFIG_SYSVIPC_SYSCTL 1
-#define CONFIG_I2C_CHARDEV 1
 #define CONFIG_CROSS_COMPILE "csky-linux-"
+#define CONFIG_I2S_DLNA_DAC_MASTER 1
 #define CONFIG_XZ_DEC_ARMTHUMB 1
 #define CONFIG_SERIAL_SILAN 1
+#define CONFIG_USB_USBNET 1
 #define CONFIG_SCSI_MULTI_LUN 1
 #define CONFIG_NEW_LEDS 1
 #define CONFIG_SWAP 1
-#define CONFIG_MAC80211 1
 #define CONFIG_BLK_DEV_SD 1
 #define CONFIG_NETFILTER_NETLINK 1
 #define CONFIG_MODULE_UNLOAD 1
@@ -431,6 +392,7 @@
 #define CONFIG_GENERIC_HARDIRQS 1
 #define CONFIG_RTC_INTF_DEV 1
 #define CONFIG_MTD_MAP_BANK_WIDTH_4 1
+#define CONFIG_I2S_DLNA_DAC_EXTRA 1
 #define CONFIG_USB_DWC_HCD_OLD 1
 #define CONFIG_NET_ACTIVITY_STATS 1
 #define CONFIG_NLS_DEFAULT "iso8859-1"
diff --no-dereference -Nru kernel-22/kernel/include/generated/compile.h kernel-central/kernel/include/generated/compile.h
--- kernel-22/kernel/include/generated/compile.h	2017-01-18 13:08:23.000000000 +0200
+++ kernel-central/kernel/include/generated/compile.h	2017-02-12 13:13:57.205586922 +0200
@@ -1,6 +1,6 @@
-/* This file is auto generated, version 1 */
+/* This file is auto generated, version 36 */
 #define UTS_MACHINE "csky"
-#define UTS_VERSION "#1 Wed Jan 18 19:08:23 CST 2017"
-#define LINUX_COMPILE_BY "n35"
-#define LINUX_COMPILE_HOST "n35-ubuntu"
+#define UTS_VERSION "#36 Sun Feb 12 13:13:57 EET 2017"
+#define LINUX_COMPILE_BY "root"
+#define LINUX_COMPILE_HOST "x2"
 #define LINUX_COMPILER "gcc version 4.5.1 (CSKY TOOLCHAINS V2.5.01, ABI Version 1, Build on 20131226) "
diff --no-dereference -Nru kernel-22/kernel/include/generated/utsrelease.h kernel-central/kernel/include/generated/utsrelease.h
--- kernel-22/kernel/include/generated/utsrelease.h	2017-01-18 13:07:13.000000000 +0200
+++ kernel-central/kernel/include/generated/utsrelease.h	2016-12-26 15:49:46.459780382 +0200
@@ -1 +1 @@
-#define UTS_RELEASE "3.0.8+"
+#define UTS_RELEASE "3.0.8"
diff --no-dereference -Nru kernel-22/kernel/include/linux/usb/ch9.h kernel-central/kernel/include/linux/usb/ch9.h
--- kernel-22/kernel/include/linux/usb/ch9.h	2017-01-18 12:55:15.000000000 +0200
+++ kernel-central/kernel/include/linux/usb/ch9.h	2016-12-26 15:49:27.057299022 +0200
@@ -144,6 +144,18 @@
 
 #define USB_INTR_FUNC_SUSPEND_OPT_MASK	0xFF00
 
+/*
+ * Suspend Options, Table 9-8 USB 3.0 spec
+ */
+#define USB_INTRF_FUNC_SUSPEND_LP	(1 << (8 + 0))
+#define USB_INTRF_FUNC_SUSPEND_RW	(1 << (8 + 1))
+
+/*
+ * Interface status, Figure 9-5 USB 3.0 spec
+ */
+#define USB_INTRF_STAT_FUNC_RW_CAP	1
+#define USB_INTRF_STAT_FUNC_RW		2
+
 #define USB_ENDPOINT_HALT		0	/* IN/OUT will STALL */
 
 /* Bit array elements as returned by the USB_REQ_GET_STATUS request. */
diff --no-dereference -Nru kernel-22/kernel/kernel/timeconst.pl kernel-central/kernel/kernel/timeconst.pl
--- kernel-22/kernel/kernel/timeconst.pl	2017-01-18 12:55:16.000000000 +0200
+++ kernel-central/kernel/kernel/timeconst.pl	2016-12-26 15:49:27.061299327 +0200
@@ -370,7 +370,7 @@
 	}
 
 	@val = @{$canned_values{$hz}};
-	if (!defined(@val)) {
+	if (!@val) {
 		@val = compute_values($hz);
 	}
 	output($hz, @val);
diff --no-dereference -Nru kernel-22/kernel/Module.symvers kernel-central/kernel/Module.symvers
--- kernel-22/kernel/Module.symvers	2017-01-18 13:08:28.000000000 +0200
+++ kernel-central/kernel/Module.symvers	2017-02-12 13:14:06.397279298 +0200
@@ -1,11 +1,8 @@
-0x00000000	cfg80211_send_rx_assoc	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_file_splice_write	vmlinux	EXPORT_SYMBOL
 0x00000000	set_anon_super	vmlinux	EXPORT_SYMBOL
 0x00000000	kmem_cache_alloc	vmlinux	EXPORT_SYMBOL
 0x00000000	replace_page_cache_page	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__cond_resched_softirq	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_wake_queues	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_put_adapter	vmlinux	EXPORT_SYMBOL
 0x00000000	rtc_class_open	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_sense_key_string	vmlinux	EXPORT_SYMBOL
 0x00000000	request_firmware	vmlinux	EXPORT_SYMBOL
@@ -14,9 +11,6 @@
 0x00000000	dev_uc_sync	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_mc_sync	vmlinux	EXPORT_SYMBOL
 0x00000000	console_lock	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_queue_stopped	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wext_siwscan	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwscan	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__kfifo_alloc	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_pagelist_truncate	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_log_register	vmlinux	EXPORT_SYMBOL
@@ -28,7 +22,6 @@
 0x00000000	device_del	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_hash_walk_done	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	init_uts_ns	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	__inet6_hash	vmlinux	EXPORT_SYMBOL
 0x00000000	dst_release	vmlinux	EXPORT_SYMBOL
 0x00000000	sock_no_mmap	vmlinux	EXPORT_SYMBOL
 0x00000000	led_trigger_store	vmlinux	EXPORT_SYMBOL_GPL
@@ -86,20 +79,18 @@
 0x00000000	generic_file_direct_write	vmlinux	EXPORT_SYMBOL
 0x00000000	call_rcu_sched	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	skb_recv_datagram	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_cdc_unbind	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	d_alloc_pseudo	vmlinux	EXPORT_SYMBOL
 0x00000000	fiemap_check_flags	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_file_readonly_mmap	vmlinux	EXPORT_SYMBOL
 0x00000000	raw_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__ipv6_addr_type	vmlinux	EXPORT_SYMBOL
 0x00000000	unregister_qdisc	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_device_register	vmlinux	EXPORT_SYMBOL
 0x00000000	crypto_shash_final	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_shash_finup	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_ahash_final	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scatterwalk_copychunks	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_siwfreq	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwfreq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rpc_free	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	vm_insert_page	vmlinux	EXPORT_SYMBOL
 0x00000000	register_console	vmlinux	EXPORT_SYMBOL
@@ -112,7 +103,6 @@
 0x00000000	nfs_retry_commit	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ip_fast_csum	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_tso_segment	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_lock_adapter	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	platform_device_put	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	platform_device_del	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__fat_fs_error	vmlinux	EXPORT_SYMBOL_GPL
@@ -132,8 +122,6 @@
 0x00000000	sg_miter_start	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_queue_unprep_rq	vmlinux	EXPORT_SYMBOL
 0x00000000	lock_may_read	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wext_siwap	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwap	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_card_free	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_MSLEEP	vmlinux	EXPORT_SYMBOL
 0x00000000	tty_mode_ioctl	vmlinux	EXPORT_SYMBOL_GPL
@@ -146,7 +134,6 @@
 0x00000000	add_timer_on	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	klist_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ceph_osdc_alloc_request	vmlinux	EXPORT_SYMBOL
-0x00000000	ip6_local_out	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	power_group_name	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bitrev16	vmlinux	EXPORT_SYMBOL
 0x00000000	kstrtoull_from_user	vmlinux	EXPORT_SYMBOL
@@ -155,7 +142,6 @@
 0x00000000	xdr_init_decode	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	device_unregister	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_aead_type	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_state_add	vmlinux	EXPORT_SYMBOL
 0x00000000	mmc_cleanup_queue	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ct_l3proto_put	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsicam_bios_param	vmlinux	EXPORT_SYMBOL
@@ -166,7 +152,6 @@
 0x00000000	gpio_set_value_cansleep	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	seq_release_net	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_csk_route_child_sock	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	phy_stop_interrupts	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_path_lookup	vmlinux	EXPORT_SYMBOL
 0x00000000	find_or_create_page	vmlinux	EXPORT_SYMBOL
 0x00000000	schedule_hrtimeout_range	vmlinux	EXPORT_SYMBOL_GPL
@@ -184,11 +169,10 @@
 0x00000000	kobject_uevent	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xdr_buf_from_iov	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	wakeup_source_add	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	__snd_printk	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_hung_up_p	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_cleanup_queue	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_setlease	vmlinux	EXPORT_SYMBOL
-0x00000000	wiphy_to_ieee80211_hw	vmlinux	EXPORT_SYMBOL
-0x00000000	ipv6_getsockopt	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_dev_info_list_add_keyed	vmlinux	EXPORT_SYMBOL
 0x00000000	syscore_suspend	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	timerqueue_del	vmlinux	EXPORT_SYMBOL_GPL
@@ -197,7 +181,6 @@
 0x00000000	write_one_page	vmlinux	EXPORT_SYMBOL
 0x00000000	ktime_get_boottime	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	async_synchronize_cookie	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_notify_new_peer_candidate	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_add_protocol	vmlinux	EXPORT_SYMBOL
 0x00000000	n_tty_ioctl_helper	vmlinux	EXPORT_SYMBOL
 0x00000000	nlmsvc_ops	vmlinux	EXPORT_SYMBOL_GPL
@@ -212,7 +195,6 @@
 0x00000000	disk_part_iter_init	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	freeze_bdev	vmlinux	EXPORT_SYMBOL
 0x00000000	srcu_batches_completed	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ip_xfrm_me_harder	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_kill_datagram	vmlinux	EXPORT_SYMBOL
 0x00000000	kfree_skb	vmlinux	EXPORT_SYMBOL
 0x00000000	kernel_kobj	vmlinux	EXPORT_SYMBOL_GPL
@@ -253,9 +235,7 @@
 0x00000000	do_mmap_pgoff	vmlinux	EXPORT_SYMBOL
 0x00000000	sysctl_tcp_rmem	vmlinux	EXPORT_SYMBOL
 0x00000000	sock_no_sendmsg	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_master_recv	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_unlink	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_stop_tx_ba_cb_irqsafe	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_WAITQ_ALLOC	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_tgt_it_nexus_create	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	key_revoke	vmlinux	EXPORT_SYMBOL
@@ -267,7 +247,6 @@
 0x00000000	put_tty_driver	vmlinux	EXPORT_SYMBOL
 0x00000000	queue_work_on	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ioport_resource	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_sched_scan_stopped	vmlinux	EXPORT_SYMBOL
 0x00000000	rtnl_lock	vmlinux	EXPORT_SYMBOL
 0x00000000	debugfs_create_bool	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	generic_file_splice_read	vmlinux	EXPORT_SYMBOL
@@ -296,8 +275,6 @@
 0x00000000	dwc_wusb_fill_ccm_nonce	vmlinux	EXPORT_SYMBOL
 0x00000000	kref_put	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_run_queue	vmlinux	EXPORT_SYMBOL
-0x00000000	__secpath_destroy	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_smbus_write_i2c_block_data	vmlinux	EXPORT_SYMBOL
 0x00000000	zlib_deflate	vmlinux	EXPORT_SYMBOL
 0x00000000	wake_bit_function	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_csk_route_req	vmlinux	EXPORT_SYMBOL_GPL
@@ -305,17 +282,14 @@
 0x00000000	bus_remove_file	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	locks_release_private	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mempool_resize	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_unregister_km	vmlinux	EXPORT_SYMBOL
 0x00000000	in_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
 0x00000000	sg_next	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_map_user	vmlinux	EXPORT_SYMBOL
 0x00000000	unshare_fs_struct	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	system_nrt_wq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__tasklet_hi_schedule_first	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wext_siwrts	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwrts	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__nf_conntrack_confirm	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	mdiobus_scan	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_suspend	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dmam_alloc_coherent	vmlinux	EXPORT_SYMBOL
 0x00000000	tty_port_carrier_raised	vmlinux	EXPORT_SYMBOL
 0x00000000	__brelse	vmlinux	EXPORT_SYMBOL
@@ -327,7 +301,6 @@
 0x00000000	eventfd_ctx_put	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mark_buffer_async_write	vmlinux	EXPORT_SYMBOL
 0x00000000	wait_for_completion_interruptible_timeout	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_probe_algs	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ip_route_me_harder	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_sock_destruct	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_reinject	vmlinux	EXPORT_SYMBOL
@@ -343,15 +316,15 @@
 0x00000000	__scsi_device_lookup_by_target	vmlinux	EXPORT_SYMBOL
 0x00000000	malloc_sizes	vmlinux	EXPORT_SYMBOL
 0x00000000	ethtool_invalid_flags	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_msglevel	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_set_msglevel	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	pm_generic_suspend	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	radix_tree_gang_lookup	vmlinux	EXPORT_SYMBOL
 0x00000000	register_nls	vmlinux	EXPORT_SYMBOL
 0x00000000	locks_alloc_lock	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	alloc_pages_exact_nid	vmlinux	EXPORT_SYMBOL
 0x00000000	svc_prepare_thread	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_state_lookup	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_parse_options	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_smbus_write_block_data	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_stor_suspend	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	svc_gss_principal	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rpc_unlink	vmlinux	EXPORT_SYMBOL_GPL
@@ -362,7 +335,6 @@
 0x00000000	dev_addr_add_multiple	vmlinux	EXPORT_SYMBOL
 0x00000000	firmware_kobj	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_lock_device_for_reset	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	mdiobus_alloc	vmlinux	EXPORT_SYMBOL
 0x00000000	genl_register_mc_group	vmlinux	EXPORT_SYMBOL
 0x00000000	___pskb_trim	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_timer_global_new	vmlinux	EXPORT_SYMBOL
@@ -370,7 +342,6 @@
 0x00000000	strcmp	vmlinux	EXPORT_SYMBOL
 0x00000000	strsep	vmlinux	EXPORT_SYMBOL
 0x00000000	iomem_resource	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_queue_delayed_work	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_ctl_add	vmlinux	EXPORT_SYMBOL
 0x00000000	devm_kfree	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mnt_unpin	vmlinux	EXPORT_SYMBOL
@@ -387,11 +358,11 @@
 0x00000000	__DWC_ALLOC_ATOMIC	vmlinux	EXPORT_SYMBOL
 0x00000000	del_gendisk	vmlinux	EXPORT_SYMBOL
 0x00000000	block_write_full_page	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_register_type	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ct_invert_tuple	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_pcm_format_unsigned	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_UDELAY	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_MDELAY	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_stop	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	lockd_up	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	fat_sync_inode	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	put_mnt_ns	vmlinux	EXPORT_SYMBOL
@@ -402,9 +373,7 @@
 0x00000000	snd_soc_default_writable_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__blockdev_direct_IO	vmlinux	EXPORT_SYMBOL
 0x00000000	splice_from_pipe_end	vmlinux	EXPORT_SYMBOL
-0x00000000	ip6_route_me_harder	vmlinux	EXPORT_SYMBOL
 0x00000000	nfs_commit_release_pages	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	km_new_mapping	vmlinux	EXPORT_SYMBOL
 0x00000000	napi_complete	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_device_new	vmlinux	EXPORT_SYMBOL
 0x00000000	mmc_assume_removable	vmlinux	EXPORT_SYMBOL
@@ -420,7 +389,6 @@
 0x00000000	d_materialise_unique	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kmem_cache_free	vmlinux	EXPORT_SYMBOL
 0x00000000	file_remove_suid	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_data_from_8023	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_WRITE_REG32	vmlinux	EXPORT_SYMBOL
 0x00000000	dmaengine_get	vmlinux	EXPORT_SYMBOL
 0x00000000	amba_device_register	vmlinux	EXPORT_SYMBOL
@@ -447,7 +415,6 @@
 0x00000000	strpbrk	vmlinux	EXPORT_SYMBOL
 0x00000000	sysfs_create_file	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	seq_lseek	vmlinux	EXPORT_SYMBOL
-0x00000000	ip6_frag_match	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_info_get_str	vmlinux	EXPORT_SYMBOL
 0x00000000	bitmap_find_free_region	vmlinux	EXPORT_SYMBOL
 0x00000000	cache_flush	vmlinux	EXPORT_SYMBOL_GPL
@@ -458,9 +425,7 @@
 0x00000000	bus_find_device	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	blk_rq_unprep_clone	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	get_silan_busclk	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_sched_scan_results	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_create	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_aalg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tcp_create_openreq_child	vmlinux	EXPORT_SYMBOL
 0x00000000	sk_common_release	vmlinux	EXPORT_SYMBOL
 0x00000000	led_trigger_register	vmlinux	EXPORT_SYMBOL_GPL
@@ -471,7 +436,6 @@
 0x00000000	irq_get_irq_data	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	flex_array_get_ptr	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_alloc_bioset	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_get_hdrlen_from_skb	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_driver_set_configuration	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mii_ethtool_gset	vmlinux	EXPORT_SYMBOL
 0x00000000	mii_ethtool_sset	vmlinux	EXPORT_SYMBOL
@@ -480,7 +444,6 @@
 0x00000000	pm_qos_remove_request	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	nf_ct_l3proto_module_put	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	release_sock	vmlinux	EXPORT_SYMBOL
-0x00000000	__i2c_first_dynamic_bus_num	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	DWC_MUTEX_FREE	vmlinux	EXPORT_SYMBOL
 0x00000000	class_remove_file	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_pcm_hw_constraint_msbits	vmlinux	EXPORT_SYMBOL
@@ -511,7 +474,6 @@
 0x00000000	proc_net_mkdir	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__bforget	vmlinux	EXPORT_SYMBOL
 0x00000000	xdr_reserve_space	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	inet6_add_protocol	vmlinux	EXPORT_SYMBOL
 0x00000000	raw_unhash_sk	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xt_register_table	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sock_no_listen	vmlinux	EXPORT_SYMBOL
@@ -541,12 +503,10 @@
 0x00000000	remove_arg_zero	vmlinux	EXPORT_SYMBOL
 0x00000000	remap_pfn_range	vmlinux	EXPORT_SYMBOL
 0x00000000	getnstimeofday	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_register_fixup	vmlinux	EXPORT_SYMBOL
 0x00000000	device_bind_driver	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	skcipher_geniv_exit	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	file_update_time	vmlinux	EXPORT_SYMBOL
 0x00000000	bdi_unregister	vmlinux	EXPORT_SYMBOL
-0x00000000	inet6_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__hw_addr_sync	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_uc_init	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_mc_init	vmlinux	EXPORT_SYMBOL
@@ -567,6 +527,7 @@
 0x00000000	generic_readlink	vmlinux	EXPORT_SYMBOL
 0x00000000	ether_setup	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_deregister_device_driver	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_nway_reset	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	device_create_file	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__break_lease	vmlinux	EXPORT_SYMBOL
 0x00000000	get_task_comm	vmlinux	EXPORT_SYMBOL_GPL
@@ -582,6 +543,7 @@
 0x00000000	force_sig	vmlinux	EXPORT_SYMBOL
 0x00000000	d_path	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_fstatat	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_resume	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sdev_evt_send	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bio_integrity_tag_size	vmlinux	EXPORT_SYMBOL
 0x00000000	igrab	vmlinux	EXPORT_SYMBOL
@@ -601,7 +563,6 @@
 0x00000000	linkwatch_fire_event	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_device_free	vmlinux	EXPORT_SYMBOL
 0x00000000	dwc_wusb_gen_key	vmlinux	EXPORT_SYMBOL
-0x00000000	ndisc_build_skb	vmlinux	EXPORT_SYMBOL
 0x00000000	unregister_netevent_notifier	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_debugfs_root	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	input_mt_report_slot_state	vmlinux	EXPORT_SYMBOL
@@ -615,7 +576,6 @@
 0x00000000	snd_soc_read	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	read_cache_page_gfp	vmlinux	EXPORT_SYMBOL
 0x00000000	schedule_delayed_work_on	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wireless_stats	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sk_stream_error	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_stor_CB_reset	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netdev_crit	vmlinux	EXPORT_SYMBOL
@@ -632,21 +592,18 @@
 0x00000000	snd_soc_dapm_free	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_termios_input_baud_rate	vmlinux	EXPORT_SYMBOL
 0x00000000	d_set_d_op	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_aalg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	DWC_EXCEPTION	vmlinux	EXPORT_SYMBOL
 0x00000000	dma_sync_single_for_device	vmlinux	EXPORT_SYMBOL
 0x00000000	udp_table	vmlinux	EXPORT_SYMBOL
 0x00000000	mmc_erase_group_aligned	vmlinux	EXPORT_SYMBOL
 0x00000000	idr_get_new_above	vmlinux	EXPORT_SYMBOL
 0x00000000	ida_get_new_above	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_disable_dyn_ps	vmlinux	EXPORT_SYMBOL
 0x00000000	transport_configure_device	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	nla_put	vmlinux	EXPORT_SYMBOL
 0x00000000	revalidate_disk	vmlinux	EXPORT_SYMBOL
 0x00000000	vm_stat	vmlinux	EXPORT_SYMBOL
 0x00000000	register_shrinker	vmlinux	EXPORT_SYMBOL
 0x00000000	__kfifo_in	vmlinux	EXPORT_SYMBOL
-0x00000000	register_sound_dsp	vmlinux	EXPORT_SYMBOL
 0x00000000	misc_register	vmlinux	EXPORT_SYMBOL
 0x00000000	block_invalidatepage	vmlinux	EXPORT_SYMBOL
 0x00000000	may_umount_tree	vmlinux	EXPORT_SYMBOL
@@ -668,12 +625,10 @@
 0x00000000	arp_xmit	vmlinux	EXPORT_SYMBOL
 0x00000000	__dev_get_by_index	vmlinux	EXPORT_SYMBOL
 0x00000000	__dev_getfirstbyhwtype	vmlinux	EXPORT_SYMBOL
-0x00000000	mdiobus_register	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_tgt_it_nexus_destroy	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	flex_array_shrink	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_msgr_flush	vmlinux	EXPORT_SYMBOL
 0x00000000	qword_add	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	__inet6_lookup_established	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_timer_interrupt	vmlinux	EXPORT_SYMBOL
 0x00000000	sdio_claim_host	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__nla_put_nohdr	vmlinux	EXPORT_SYMBOL
@@ -683,7 +638,7 @@
 0x00000000	sysctl_tcp_ecn	vmlinux	EXPORT_SYMBOL
 0x00000000	sysctl_tcp_mem	vmlinux	EXPORT_SYMBOL
 0x00000000	ethtool_op_set_tx_csum	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_stop_tx_ba_session	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_probe	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_csk_accept	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	generic_mii_ioctl	vmlinux	EXPORT_SYMBOL
@@ -691,10 +646,8 @@
 0x00000000	do_splice_direct	vmlinux	EXPORT_SYMBOL
 0x00000000	xprt_wake_pending_tasks	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_bulk_msg	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_state_delete_tunnel	vmlinux	EXPORT_SYMBOL
 0x00000000	dwc_cc_clear	vmlinux	EXPORT_SYMBOL
 0x00000000	platform_device_add_resources	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	in6_dev_finish_destroy	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_gro_receive	vmlinux	EXPORT_SYMBOL
 0x00000000	eth_header	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_rescan_device	vmlinux	EXPORT_SYMBOL
@@ -713,12 +666,12 @@
 0x00000000	__block_write_begin	vmlinux	EXPORT_SYMBOL
 0x00000000	register_reboot_notifier	vmlinux	EXPORT_SYMBOL
 0x00000000	timespec_trunc	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_queue_work	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_sockets_allocated	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_tgt_queue_command	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inode_owner_or_capable	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_pipe_buf_confirm	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_READ_REG32	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_tx_timeout	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_device_quiesce	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_hw_param_first	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_SPINLOCK_FREE	vmlinux	EXPORT_SYMBOL
@@ -748,8 +701,6 @@
 0x00000000	sk_free	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_free_ac97_codec	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_is_sdev_device	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_stop_queue	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_hdrlen	vmlinux	EXPORT_SYMBOL
 0x00000000	kobject_init	vmlinux	EXPORT_SYMBOL
 0x00000000	flush_workqueue	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sleep_on	vmlinux	EXPORT_SYMBOL
@@ -760,7 +711,6 @@
 0x00000000	netlink_register_notifier	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_match_id	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bio_integrity_endio	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_policy_insert	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_segment	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mmc_vddrange_to_ocrmask	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_add_hcd	vmlinux	EXPORT_SYMBOL_GPL
@@ -776,14 +726,12 @@
 0x00000000	simple_rmdir	vmlinux	EXPORT_SYMBOL
 0x00000000	alloc_file	vmlinux	EXPORT_SYMBOL
 0x00000000	free_task	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_del_adapter	vmlinux	EXPORT_SYMBOL
 0x00000000	rtc_valid_tm	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_register_driver	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_block_requests	vmlinux	EXPORT_SYMBOL
 0x00000000	sysfs_get	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	seq_hlist_start	vmlinux	EXPORT_SYMBOL
 0x00000000	__kfifo_dma_in_finish_r	vmlinux	EXPORT_SYMBOL
-0x00000000	unregister_sound_special	vmlinux	EXPORT_SYMBOL
 0x00000000	mmc_release_host	vmlinux	EXPORT_SYMBOL
 0x00000000	fat_dir_empty	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__getblk	vmlinux	EXPORT_SYMBOL
@@ -795,7 +743,6 @@
 0x00000000	dev_warn	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ct_untracked_status_or	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_jack_set_key	vmlinux	EXPORT_SYMBOL
-0x00000000	get_phy_device	vmlinux	EXPORT_SYMBOL
 0x00000000	wakeup_source_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__sw_hweight32	vmlinux	EXPORT_SYMBOL
 0x00000000	__sw_hweight16	vmlinux	EXPORT_SYMBOL
@@ -818,8 +765,6 @@
 0x00000000	rtc_alarm_irq_enable	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	DWC_SHA256	vmlinux	EXPORT_SYMBOL
 0x00000000	irq_modify_status	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	inet6_del_protocol	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_input_resume	vmlinux	EXPORT_SYMBOL
 0x00000000	udplite_prot	vmlinux	EXPORT_SYMBOL
 0x00000000	sock_create_kern	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_eh_restore_cmnd	vmlinux	EXPORT_SYMBOL
@@ -855,14 +800,12 @@
 0x00000000	request_resource	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_getname	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ct_expect_init	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	snd_unregister_oss_device	vmlinux	EXPORT_SYMBOL
 0x00000000	iov_iter_fault_in_readable	vmlinux	EXPORT_SYMBOL
 0x00000000	module_mutex	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	put_mtd_device	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dpm_resume_noirq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__cap_empty_set	vmlinux	EXPORT_SYMBOL
 0x00000000	xprt_register_transport	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	i2c_smbus_process_call	vmlinux	EXPORT_SYMBOL
 0x00000000	platform_get_resource	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_shoot_alg	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	iput	vmlinux	EXPORT_SYMBOL
@@ -874,7 +817,6 @@
 0x00000000	vm_unmap_ram	vmlinux	EXPORT_SYMBOL
 0x00000000	proc_doulongvec_ms_jiffies_minmax	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_client_id	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_output	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bitmap_bitremap	vmlinux	EXPORT_SYMBOL
 0x00000000	register_blkdev	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_conntrack_alter_reply	vmlinux	EXPORT_SYMBOL_GPL
@@ -884,20 +826,17 @@
 0x00000000	usb_kill_anchored_urbs	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	request_firmware_nowait	vmlinux	EXPORT_SYMBOL
 0x00000000	kref_get	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_unlink_bss	vmlinux	EXPORT_SYMBOL
 0x00000000	netdev_change_features	vmlinux	EXPORT_SYMBOL
 0x00000000	init_dummy_netdev	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dst_destroy	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_drvinfo	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	svc_wake_up	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xprt_write_space	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ndisc_send_skb	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_unregister_queue_handlers	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mtd_blktrans_cease_background	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_mode_sense	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_show_sense_hdr	vmlinux	EXPORT_SYMBOL
 0x00000000	__init_waitqueue_head	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wext_siwgenie	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm4_tunnel_register	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ct_get_tuple	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dwc_cc_match_chid	vmlinux	EXPORT_SYMBOL
 0x00000000	dwc_cc_match_cdid	vmlinux	EXPORT_SYMBOL
@@ -930,7 +869,6 @@
 0x00000000	iget5_locked	vmlinux	EXPORT_SYMBOL
 0x00000000	irq_set_handler_data	vmlinux	EXPORT_SYMBOL
 0x00000000	yield_to	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_channel_to_frequency	vmlinux	EXPORT_SYMBOL
 0x00000000	mii_check_media	vmlinux	EXPORT_SYMBOL
 0x00000000	user_revoke	vmlinux	EXPORT_SYMBOL
 0x00000000	debugfs_create_dir	vmlinux	EXPORT_SYMBOL_GPL
@@ -951,7 +889,6 @@
 0x00000000	svc_reg_xprt_class	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	nf_ct_l3proto_try_module_get	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netdev_fix_features	vmlinux	EXPORT_SYMBOL
-0x00000000	register_sound_midi	vmlinux	EXPORT_SYMBOL
 0x00000000	sdio_release_irq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mmc_wait_for_cmd	vmlinux	EXPORT_SYMBOL
 0x00000000	kobject_rename	vmlinux	EXPORT_SYMBOL_GPL
@@ -961,7 +898,6 @@
 0x00000000	kstrtou8	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_rq_map_integrity_sg	vmlinux	EXPORT_SYMBOL
 0x00000000	get_task_pid	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	inet6_hash_frag	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_component_add	vmlinux	EXPORT_SYMBOL
 0x00000000	__big_tty_mutex_owner	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	flex_array_clear	vmlinux	EXPORT_SYMBOL
@@ -972,7 +908,6 @@
 0x00000000	nf_nat_proto_unique_tuple	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	nf_nat_mangle_udp_packet	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_dapm_get_pin_status	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_restart_hw	vmlinux	EXPORT_SYMBOL
 0x00000000	anon_transport_class_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	disk_part_iter_exit	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	follow_down_one	vmlinux	EXPORT_SYMBOL
@@ -987,12 +922,10 @@
 0x00000000	blk_unprep_request	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xdr_shift_buf	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ip_options_rcv_srr	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_bit_add_numbered_bus	vmlinux	EXPORT_SYMBOL
 0x00000000	device_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dentry_open	vmlinux	EXPORT_SYMBOL
 0x00000000	dma_free_coherent	vmlinux	EXPORT_SYMBOL
 0x00000000	mach_hwclk	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_sched_scan_results	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_checksum_help	vmlinux	EXPORT_SYMBOL
 0x00000000	unregister_netdevice_queue	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_dev_info_remove_list	vmlinux	EXPORT_SYMBOL
@@ -1040,18 +973,14 @@
 0x00000000	snd_timer_global_register	vmlinux	EXPORT_SYMBOL
 0x00000000	platform_get_irq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kill_anon_super	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm6_rcv	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm4_rcv	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ct_delete_from_lists	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_unregister_platform	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xdr_buf_subsegment	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bio_integrity_free	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_integrity_prep	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_integrity_trim	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_put_bss	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_dgram_connect	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_find_alt_setting	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	phy_connect	vmlinux	EXPORT_SYMBOL
 0x00000000	driver_unregister	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	generic_pipe_buf_unmap	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_pipe_buf_steal	vmlinux	EXPORT_SYMBOL
@@ -1089,14 +1018,12 @@
 0x00000000	inet_register_protosw	vmlinux	EXPORT_SYMBOL
 0x00000000	__inet_inherit_port	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dev_deactivate	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_find_first	vmlinux	EXPORT_SYMBOL
 0x00000000	srandom32	vmlinux	EXPORT_SYMBOL
 0x00000000	vmalloc_node	vmlinux	EXPORT_SYMBOL
 0x00000000	mempool_destroy	vmlinux	EXPORT_SYMBOL
 0x00000000	kernel_halt	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_ioctl	vmlinux	EXPORT_SYMBOL
 0x00000000	set_binfmt	vmlinux	EXPORT_SYMBOL
-0x00000000	km_policy_expired	vmlinux	EXPORT_SYMBOL
 0x00000000	spi_unregister_master	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	elv_rb_find	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_CPU_TO_BE32	vmlinux	EXPORT_SYMBOL
@@ -1111,10 +1038,7 @@
 0x00000000	scsi_report_device_reset	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_print_sense	vmlinux	EXPORT_SYMBOL
 0x00000000	locks_free_lock	vmlinux	EXPORT_SYMBOL
-0x00000000	register_sound_mixer	vmlinux	EXPORT_SYMBOL
 0x00000000	simple_attr_release	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_siwretry	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwretry	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_submit_urb	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bio_integrity_advance	vmlinux	EXPORT_SYMBOL
 0x00000000	rename_lock	vmlinux	EXPORT_SYMBOL
@@ -1124,11 +1048,9 @@
 0x00000000	vunmap	vmlinux	EXPORT_SYMBOL
 0x00000000	write_cache_pages	vmlinux	EXPORT_SYMBOL
 0x00000000	refrigerator	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_policy_alloc	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_conntrack_l4proto_tcp6	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	led_blink_set	vmlinux	EXPORT_SYMBOL
 0x00000000	mach_set_rtc_pll	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_remain_on_channel_expired	vmlinux	EXPORT_SYMBOL
 0x00000000	__nf_ct_ext_add	vmlinux	EXPORT_SYMBOL
 0x00000000	qdisc_class_hash_init	vmlinux	EXPORT_SYMBOL
 0x00000000	sk_prot_clear_portaddr_nulls	vmlinux	EXPORT_SYMBOL
@@ -1187,18 +1109,17 @@
 0x00000000	sysctl_tcp_adv_win_scale	vmlinux	EXPORT_SYMBOL
 0x00000000	ip_local_out	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_hcd_check_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	phy_device_free	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_permission	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_open	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	unlock_flocks	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_ctl_notify	vmlinux	EXPORT_SYMBOL
 0x00000000	uart_get_baud_rate	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_iopoll_init	vmlinux	EXPORT_SYMBOL
 0x00000000	atomic_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	secpath_dup	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_hw_constraint_step	vmlinux	EXPORT_SYMBOL
 0x00000000	dwc_wusb_gen_nonce	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_disconnect	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	set_user_nice	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_find_ie	vmlinux	EXPORT_SYMBOL
 0x00000000	gss_pseudoflavor_to_service	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	splice_direct_to_actor	vmlinux	EXPORT_SYMBOL
 0x00000000	hrtimer_get_res	vmlinux	EXPORT_SYMBOL_GPL
@@ -1217,13 +1138,11 @@
 0x00000000	qdisc_put_rtab	vmlinux	EXPORT_SYMBOL
 0x00000000	crypto_attr_alg2	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	nfs_commit_free	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_remain_on_channel_expired	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	proto_register	vmlinux	EXPORT_SYMBOL
 0x00000000	rtc_irq_unregister	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_wakeup	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	check_disk_size_change	vmlinux	EXPORT_SYMBOL
 0x00000000	down_read	vmlinux	EXPORT_SYMBOL
-0x00000000	km_report	vmlinux	EXPORT_SYMBOL
 0x00000000	__napi_complete	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_copy_expand	vmlinux	EXPORT_SYMBOL
 0x00000000	rtc_time_to_tm	vmlinux	EXPORT_SYMBOL
@@ -1257,7 +1176,6 @@
 0x00000000	inode_init_once	vmlinux	EXPORT_SYMBOL
 0x00000000	__srcu_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dma_cache_sync	vmlinux	EXPORT_SYMBOL
-0x00000000	nf_ip6_checksum	vmlinux	EXPORT_SYMBOL
 0x00000000	__DWC_DMA_FREE	vmlinux	EXPORT_SYMBOL
 0x00000000	device_move	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_cmd_ioctl	vmlinux	EXPORT_SYMBOL
@@ -1292,14 +1210,12 @@
 0x00000000	seq_release	vmlinux	EXPORT_SYMBOL
 0x00000000	insert_inode_locked	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_conntrack_event_cb	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	tun_get_socket	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dpm_resume_end	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__blk_put_request	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	elv_rb_latter_request	vmlinux	EXPORT_SYMBOL
 0x00000000	sysfs_create_bin_file	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	nr_free_buffer_pages	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	klist_init	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_state_unregister_afinfo	vmlinux	EXPORT_SYMBOL
 0x00000000	nla_strlcpy	vmlinux	EXPORT_SYMBOL
 0x00000000	kstrtouint	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_init_queue_node	vmlinux	EXPORT_SYMBOL
@@ -1316,7 +1232,6 @@
 0x00000000	match_token	vmlinux	EXPORT_SYMBOL
 0x00000000	vmtruncate	vmlinux	EXPORT_SYMBOL
 0x00000000	down_write	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_frequency_to_channel	vmlinux	EXPORT_SYMBOL
 0x00000000	ip_route_output_flow	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsilun_to_int	vmlinux	EXPORT_SYMBOL
 0x00000000	posix_test_lock	vmlinux	EXPORT_SYMBOL
@@ -1330,9 +1245,7 @@
 0x00000000	kernel_sock_ioctl	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_stor_disconnect	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kallsyms_on_each_symbol	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_siwencodeext	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	nfnetlink_unicast	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	snd_mixer_oss_ioctl_card	vmlinux	EXPORT_SYMBOL
 0x00000000	bsearch	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_put_request	vmlinux	EXPORT_SYMBOL
 0x00000000	async_synchronize_full_domain	vmlinux	EXPORT_SYMBOL_GPL
@@ -1345,6 +1258,7 @@
 0x00000000	sysfs_remove_files	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mapping_tagged	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_setbufsize	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_purge_paused_rxq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	put_disk	vmlinux	EXPORT_SYMBOL
 0x00000000	add_timer	vmlinux	EXPORT_SYMBOL
 0x00000000	spi_sync	vmlinux	EXPORT_SYMBOL_GPL
@@ -1383,17 +1297,11 @@
 0x00000000	dma_issue_pending_all	vmlinux	EXPORT_SYMBOL
 0x00000000	crypto_spawn_tfm	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	generic_error_remove_page	vmlinux	EXPORT_SYMBOL
-0x00000000	ipv6_chk_prefix	vmlinux	EXPORT_SYMBOL
-0x00000000	ip6_dst_lookup_flow	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_csk_search_req	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_unhash	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	nf_ct_nat_offset	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	mdio_bus_type	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_execute_rq	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wext_siwtxpower	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwtxpower	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rpc_call_sync	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ip6_xmit	vmlinux	EXPORT_SYMBOL
 0x00000000	vsscanf	vmlinux	EXPORT_SYMBOL
 0x00000000	seq_open_net	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sysctl_vfs_cache_pressure	vmlinux	EXPORT_SYMBOL_GPL
@@ -1404,6 +1312,7 @@
 0x00000000	sg_init_one	vmlinux	EXPORT_SYMBOL
 0x00000000	__kmalloc	vmlinux	EXPORT_SYMBOL
 0x00000000	__vmalloc	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_ethernet_addr	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kobject_init_and_add	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rpc_wake_up_next	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__ip_select_ident	vmlinux	EXPORT_SYMBOL
@@ -1429,8 +1338,6 @@
 0x00000000	simple_statfs	vmlinux	EXPORT_SYMBOL
 0x00000000	param_set_long	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_put_mount	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	km_policy_notify	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm4_tunnel_deregister	vmlinux	EXPORT_SYMBOL
 0x00000000	ip_mc_join_group	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_string	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__kfifo_free	vmlinux	EXPORT_SYMBOL
@@ -1439,7 +1346,6 @@
 0x00000000	uuid_be_gen	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	debugfs_remove	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	lease_modify	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_dst_ifdown	vmlinux	EXPORT_SYMBOL
 0x00000000	neigh_seq_start	vmlinux	EXPORT_SYMBOL
 0x00000000	cpu_sysdev_class	vmlinux	EXPORT_SYMBOL
 0x00000000	idle_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
@@ -1465,14 +1371,11 @@
 0x00000000	crypto_init_spawn	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mount_nodev	vmlinux	EXPORT_SYMBOL
 0x00000000	pagevec_lookup	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_find_acq	vmlinux	EXPORT_SYMBOL
 0x00000000	eth_mac_addr	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_WAITQ_ABORT	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_scan_host	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_setup_fs_cmnd	vmlinux	EXPORT_SYMBOL
 0x00000000	idle_notifier_register	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_siwfrag	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwfrag	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	svc_xprt_received	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tcp_sendpage	vmlinux	EXPORT_SYMBOL
 0x00000000	rtc_tm_to_time	vmlinux	EXPORT_SYMBOL
@@ -1500,12 +1403,10 @@
 0x00000000	vfs_link	vmlinux	EXPORT_SYMBOL
 0x00000000	call_usermodehelper_setup	vmlinux	EXPORT_SYMBOL
 0x00000000	netlink_rcv_skb	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_driver_unregister	vmlinux	EXPORT_SYMBOL
 0x00000000	crypto_alloc_pcomp	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ktime_get_real	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	panic_notifier_list	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_check_fsid	vmlinux	EXPORT_SYMBOL
-0x00000000	__xfrm_state_delete	vmlinux	EXPORT_SYMBOL
 0x00000000	unregister_mtd_chip_driver	vmlinux	EXPORT_SYMBOL
 0x00000000	d_delete	vmlinux	EXPORT_SYMBOL
 0x00000000	find_get_pages_tag	vmlinux	EXPORT_SYMBOL
@@ -1520,7 +1421,6 @@
 0x00000000	devres_destroy	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_hangup	vmlinux	EXPORT_SYMBOL
 0x00000000	add_page_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	mdiobus_read	vmlinux	EXPORT_SYMBOL
 0x00000000	tty_termios_copy_hw	vmlinux	EXPORT_SYMBOL
 0x00000000	dma_release_channel	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rpc_ntop	vmlinux	EXPORT_SYMBOL_GPL
@@ -1531,9 +1431,6 @@
 0x00000000	ceph_messenger_create	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_change_flags	vmlinux	EXPORT_SYMBOL
 0x00000000	__strncpy_from_user	vmlinux	EXPORT_SYMBOL
-0x00000000	__cfg80211_auth_canceled	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_state_walk	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_scan_fixups	vmlinux	EXPORT_SYMBOL
 0x00000000	nla_put_nohdr	vmlinux	EXPORT_SYMBOL
 0x00000000	napi_gro_flush	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_set_medium_removal	vmlinux	EXPORT_SYMBOL
@@ -1551,7 +1448,6 @@
 0x00000000	snd_free_pages	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_card_file_remove	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_init_urb	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	get_phy_id	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_free_tags	vmlinux	EXPORT_SYMBOL
 0x00000000	vfsmount_lock_lock_init	vmlinux	EXPORT_SYMBOL
 0x00000000	ktime_get_ts	vmlinux	EXPORT_SYMBOL_GPL
@@ -1562,8 +1458,6 @@
 0x00000000	files_lglock_local_lock_cpu	vmlinux	EXPORT_SYMBOL
 0x00000000	map_vm_area	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	unregister_shrinker	vmlinux	EXPORT_SYMBOL
-0x00000000	ipv6_dev_get_saddr	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_policy_flush	vmlinux	EXPORT_SYMBOL
 0x00000000	ethtool_ntuple_flush	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_cache_sync	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mmc_set_blocklen	vmlinux	EXPORT_SYMBOL
@@ -1573,7 +1467,6 @@
 0x00000000	napi_gro_frags	vmlinux	EXPORT_SYMBOL
 0x00000000	flex_array_get	vmlinux	EXPORT_SYMBOL
 0x00000000	key_task_permission	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_rate_control_register	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_nat_protocol_unregister	vmlinux	EXPORT_SYMBOL
 0x00000000	sock_sendmsg	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_malloc_pages	vmlinux	EXPORT_SYMBOL
@@ -1592,7 +1485,6 @@
 0x00000000	sdio_writew	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	vmalloc_to_pfn	vmlinux	EXPORT_SYMBOL
 0x00000000	get_task_mm	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_ctstoself_duration	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_default_readable_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dma_is_consistent	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ct_expect_put	vmlinux	EXPORT_SYMBOL_GPL
@@ -1604,16 +1496,12 @@
 0x00000000	__class_create	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	filp_open	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_file_aio_write	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm6_prepare_output	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_calg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm4_prepare_output	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_link_rwlock	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_unregister_codec	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	DWC_WORKQ_PENDING	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_TASK_FREE	vmlinux	EXPORT_SYMBOL
 0x00000000	get_disk	vmlinux	EXPORT_SYMBOL
 0x00000000	__free_pages	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_ready_on_channel	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_bind	vmlinux	EXPORT_SYMBOL
 0x00000000	qdisc_watchdog_init	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_gadget_probe_driver	vmlinux	EXPORT_SYMBOL
@@ -1621,19 +1509,15 @@
 0x00000000	__register_binfmt	vmlinux	EXPORT_SYMBOL
 0x00000000	thaw_process	vmlinux	EXPORT_SYMBOL
 0x00000000	silan_padmux_ctrl	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_init_state	vmlinux	EXPORT_SYMBOL
 0x00000000	kstrtos8_from_user	vmlinux	EXPORT_SYMBOL
 0x00000000	crypto_init_spawn2	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_user_policy	vmlinux	EXPORT_SYMBOL
 0x00000000	netif_notify_peers	vmlinux	EXPORT_SYMBOL
 0x00000000	netif_napi_add	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_split	vmlinux	EXPORT_SYMBOL
 0x00000000	input_grab_device	vmlinux	EXPORT_SYMBOL
 0x00000000	default_mtd_writev	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_port_block_til_ready	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_count_auth_supported	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netlink_broadcast	vmlinux	EXPORT_SYMBOL
-0x00000000	__i2c_board_list	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	block_write_full_page_endio	vmlinux	EXPORT_SYMBOL
 0x00000000	shmem_file_setup	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	in_group_p	vmlinux	EXPORT_SYMBOL
@@ -1647,7 +1531,6 @@
 0x00000000	sdio_register_driver	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_kill_urb	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_get_intf	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_ready_on_channel	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_dh_handler_exist	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	set_security_override_from_ctx	vmlinux	EXPORT_SYMBOL
 0x00000000	xdr_process_buf	vmlinux	EXPORT_SYMBOL_GPL
@@ -1674,12 +1557,10 @@
 0x00000000	amba_find_device	vmlinux	EXPORT_SYMBOL
 0x00000000	gpio_request_array	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snmp_mib_free	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	phy_start_interrupts	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_get_vpd_page	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	gpio_free_array	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scatterwalk_start	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sysfs_put	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_state_check_expire	vmlinux	EXPORT_SYMBOL
 0x00000000	netdev_boot_setup_check	vmlinux	EXPORT_SYMBOL
 0x00000000	sock_i_uid	vmlinux	EXPORT_SYMBOL
 0x00000000	sock_i_ino	vmlinux	EXPORT_SYMBOL
@@ -1692,17 +1573,15 @@
 0x00000000	sync_inode_metadata	vmlinux	EXPORT_SYMBOL
 0x00000000	mempool_alloc	vmlinux	EXPORT_SYMBOL
 0x00000000	__kfifo_out_r	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_classify8021d	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_register_platform	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__srcu_read_lock	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	secure_ipv4_port_ephemeral	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	proc_dointvec_minmax	vmlinux	EXPORT_SYMBOL
 0x00000000	dma_unmap_single	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_osdc_set_request_linger	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_bus_type	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	daemonize	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_malloc	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	icmpv6_send	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_pause_rx	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	put_driver	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	blk_queue_make_request	vmlinux	EXPORT_SYMBOL
 0x00000000	put_page	vmlinux	EXPORT_SYMBOL
@@ -1718,7 +1597,6 @@
 0x00000000	inet_del_protocol	vmlinux	EXPORT_SYMBOL
 0x00000000	neigh_update	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_WAITQ_FREE	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_stop	vmlinux	EXPORT_SYMBOL
 0x00000000	spi_bitbang_start	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	put_io_context	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_queue_io_min	vmlinux	EXPORT_SYMBOL
@@ -1727,7 +1605,6 @@
 0x00000000	__kfifo_dma_out_prepare	vmlinux	EXPORT_SYMBOL
 0x00000000	dma_map_single	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_monc_init	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_generic_frame_duration	vmlinux	EXPORT_SYMBOL
 0x00000000	ethtool_op_set_tx_hw_csum	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_unregister_dai	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	up	vmlinux	EXPORT_SYMBOL
@@ -1736,7 +1613,6 @@
 0x00000000	nfs4_set_ds_client	vmlinux	EXPORT_SYMBOL
 0x00000000	path_get	vmlinux	EXPORT_SYMBOL
 0x00000000	iov_iter_copy_from_user_atomic	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_state_update	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_deregister_dev	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_hcd_is_primary_hcd	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_grab_aead	vmlinux	EXPORT_SYMBOL_GPL
@@ -1749,7 +1625,6 @@
 0x00000000	snd_cards	vmlinux	EXPORT_SYMBOL
 0x00000000	ilookup	vmlinux	EXPORT_SYMBOL
 0x00000000	free_pages	vmlinux	EXPORT_SYMBOL
-0x00000000	mdiobus_free	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_file_fsync	vmlinux	EXPORT_SYMBOL
 0x00000000	unlock_new_inode	vmlinux	EXPORT_SYMBOL
 0x00000000	__f_setown	vmlinux	EXPORT_SYMBOL
@@ -1764,7 +1639,6 @@
 0x00000000	fput	vmlinux	EXPORT_SYMBOL
 0x00000000	platform_device_alloc	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	posix_timer_event	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ip6_frag_init	vmlinux	EXPORT_SYMBOL
 0x00000000	__fsnotify_parent	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	pm_qos_add_request	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	param_ops_bool	vmlinux	EXPORT_SYMBOL
@@ -1795,7 +1669,6 @@
 0x00000000	print_hex_dump_bytes	vmlinux	EXPORT_SYMBOL
 0x00000000	nlmclnt_proc	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	d_add_ci	vmlinux	EXPORT_SYMBOL
-0x00000000	net_ipv6_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	net_ipv4_ctl_path	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netdev_set_master	vmlinux	EXPORT_SYMBOL
 0x00000000	__skb_checksum_complete_head	vmlinux	EXPORT_SYMBOL
@@ -1812,6 +1685,7 @@
 0x00000000	workqueue_set_max_active	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__generic_copy_from_user	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_gadget_probe_driver_pre	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_cdc_status	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_port_raise_dtr_rts	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_queue_io_opt	vmlinux	EXPORT_SYMBOL
 0x00000000	system_unbound_wq	vmlinux	EXPORT_SYMBOL_GPL
@@ -1820,7 +1694,6 @@
 0x00000000	tcp_unregister_congestion_control	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bio_split	vmlinux	EXPORT_SYMBOL
 0x00000000	lock_rename	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_bit_add_bus	vmlinux	EXPORT_SYMBOL
 0x00000000	class_destroy	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	gpiochip_remove	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__locks_copy_lock	vmlinux	EXPORT_SYMBOL
@@ -1838,7 +1711,6 @@
 0x00000000	seq_read	vmlinux	EXPORT_SYMBOL
 0x00000000	is_bad_inode	vmlinux	EXPORT_SYMBOL
 0x00000000	param_get_int	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_key_removed	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	start_tty	vmlinux	EXPORT_SYMBOL
 0x00000000	gpio_set_debounce	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	shash_ahash_finup	vmlinux	EXPORT_SYMBOL_GPL
@@ -1850,19 +1722,16 @@
 0x00000000	notify_change	vmlinux	EXPORT_SYMBOL
 0x00000000	follow_up	vmlinux	EXPORT_SYMBOL
 0x00000000	param_get_short	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_start_tx_ba_cb_irqsafe	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_log_bind_pf	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_copy_and_csum_datagram_iovec	vmlinux	EXPORT_SYMBOL
 0x00000000	sock_no_ioctl	vmlinux	EXPORT_SYMBOL
 0x00000000	get_user_pages_fast	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dma_alloc_coherent	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_sta_block_awake	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_conntrack_find_get	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_codec_set_sysclk	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_remove_device	vmlinux	EXPORT_SYMBOL
 0x00000000	simple_empty	vmlinux	EXPORT_SYMBOL
 0x00000000	shmem_read_mapping_page_gfp	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_cfg_mutex	vmlinux	EXPORT_SYMBOL
 0x00000000	__sk_mem_schedule	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_hcd_irq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	radix_tree_gang_lookup_tag_slot	vmlinux	EXPORT_SYMBOL
@@ -1883,7 +1752,6 @@
 0x00000000	device_destroy	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	find_lock_page	vmlinux	EXPORT_SYMBOL
 0x00000000	srcu_notifier_chain_unregister	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	wiphy_register	vmlinux	EXPORT_SYMBOL
 0x00000000	unregister_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	input_ff_destroy	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	platform_get_irq_byname	vmlinux	EXPORT_SYMBOL_GPL
@@ -1894,19 +1762,14 @@
 0x00000000	napi_get_frags	vmlinux	EXPORT_SYMBOL
 0x00000000	sk_stream_write_space	vmlinux	EXPORT_SYMBOL
 0x00000000	sysfs_notify_dirent	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_beacon_get_tim	vmlinux	EXPORT_SYMBOL
-0x00000000	ipv6_dup_options	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	phy_register_fixup_for_id	vmlinux	EXPORT_SYMBOL
 0x00000000	add_mtd_blktrans_dev	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	silan_iis_device	vmlinux	EXPORT_SYMBOL
 0x00000000	mmc_do_release_host	vmlinux	EXPORT_SYMBOL
 0x00000000	zap_vma_ptes	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ceph_osdc_create_event	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_init_priority_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_policy_bysel_ctx	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_sendmsg	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_new_ac97_codec	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	i2c_smbus_write_word_data	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_complete_async_scans	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	elv_rb_add	vmlinux	EXPORT_SYMBOL
 0x00000000	elv_rb_del	vmlinux	EXPORT_SYMBOL
@@ -1922,7 +1785,6 @@
 0x00000000	blk_make_request	vmlinux	EXPORT_SYMBOL
 0x00000000	__pagevec_release	vmlinux	EXPORT_SYMBOL
 0x00000000	warn_slowpath_fmt	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_cqm_rssi_notify	vmlinux	EXPORT_SYMBOL
 0x00000000	sl_dma_getposition	vmlinux	EXPORT_SYMBOL
 0x00000000	nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
 0x00000000	ilookup5	vmlinux	EXPORT_SYMBOL
@@ -1932,7 +1794,6 @@
 0x00000000	dev_addr_flush	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_dma_reserve_buf	vmlinux	EXPORT_SYMBOL
 0x00000000	bitmap_scnlistprintf	vmlinux	EXPORT_SYMBOL
-0x00000000	wiphy_rfkill_set_hw_state	vmlinux	EXPORT_SYMBOL
 0x00000000	sunrpc_cache_pipe_upcall	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_info_volsw_2r_sx	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	blkdev_get_by_dev	vmlinux	EXPORT_SYMBOL
@@ -1959,7 +1820,6 @@
 0x00000000	inet_frag_evictor	vmlinux	EXPORT_SYMBOL
 0x00000000	xt_unregister_target	vmlinux	EXPORT_SYMBOL
 0x00000000	led_trigger_show	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_start_tx_ba_session	vmlinux	EXPORT_SYMBOL
 0x00000000	__iowrite32_copy	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xdr_enter_page	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	nf_conntrack_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
@@ -1970,10 +1830,9 @@
 0x00000000	pm_generic_thaw	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	generic_getxattr	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_setxattr	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_connect_result	vmlinux	EXPORT_SYMBOL
 0x00000000	gss_mech_register	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_start_xmit	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mpage_readpages	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_unlock_adapter	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__bitmap_parse	vmlinux	EXPORT_SYMBOL
 0x00000000	__wait_on_buffer	vmlinux	EXPORT_SYMBOL
 0x00000000	cancel_delayed_work_sync	vmlinux	EXPORT_SYMBOL
@@ -2008,7 +1867,6 @@
 0x00000000	gen_estimator_active	vmlinux	EXPORT_SYMBOL
 0x00000000	get_driver	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bitmap_release_region	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_roamed	vmlinux	EXPORT_SYMBOL
 0x00000000	ip_mc_inc_group	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_orphan_count	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	request_key_with_auxdata	vmlinux	EXPORT_SYMBOL
@@ -2028,7 +1886,6 @@
 0x00000000	files_lglock_local_unlock	vmlinux	EXPORT_SYMBOL
 0x00000000	follow_pfn	vmlinux	EXPORT_SYMBOL
 0x00000000	hrtimer_init	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_cqm_rssi_notify	vmlinux	EXPORT_SYMBOL
 0x00000000	memcpy_toiovec	vmlinux	EXPORT_SYMBOL
 0x00000000	in_aton	vmlinux	EXPORT_SYMBOL
 0x00000000	neigh_resolve_output	vmlinux	EXPORT_SYMBOL
@@ -2054,18 +1911,15 @@
 0x00000000	nf_ct_deliver_cached_events	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_nivaead_type	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bdi_writeout_inc	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm6_rcv_spi	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_release_substream	vmlinux	EXPORT_SYMBOL
 0x00000000	dwc_unregister_notifier	vmlinux	EXPORT_SYMBOL
 0x00000000	dma_release_from_coherent	vmlinux	EXPORT_SYMBOL
 0x00000000	disk_stack_limits	vmlinux	EXPORT_SYMBOL
 0x00000000	crypto_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	jiffies_to_timespec	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_master_send	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_tgt_free_queue	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	device_reprobe	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	timeval_to_jiffies	vmlinux	EXPORT_SYMBOL
-0x00000000	wiphy_free	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_kfree_skb_any	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_ctl_new1	vmlinux	EXPORT_SYMBOL
 0x00000000	seq_open	vmlinux	EXPORT_SYMBOL
@@ -2084,8 +1938,6 @@
 0x00000000	follow_down	vmlinux	EXPORT_SYMBOL
 0x00000000	filemap_write_and_wait_range	vmlinux	EXPORT_SYMBOL
 0x00000000	__generic_file_aio_write	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_rx_mgmt	vmlinux	EXPORT_SYMBOL
-0x00000000	genphy_read_status	vmlinux	EXPORT_SYMBOL
 0x00000000	tty_unregister_driver	vmlinux	EXPORT_SYMBOL
 0x00000000	get_write_access	vmlinux	EXPORT_SYMBOL
 0x00000000	invalidate_mapping_pages	vmlinux	EXPORT_SYMBOL
@@ -2108,7 +1960,6 @@
 0x00000000	strnlen	vmlinux	EXPORT_SYMBOL
 0x00000000	unregister_filesystem	vmlinux	EXPORT_SYMBOL
 0x00000000	adjust_resource	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_state_insert	vmlinux	EXPORT_SYMBOL
 0x00000000	kmsg_dump_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rpc_peeraddr2str	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xt_find_revision	vmlinux	EXPORT_SYMBOL_GPL
@@ -2133,12 +1984,10 @@
 0x00000000	override_creds	vmlinux	EXPORT_SYMBOL
 0x00000000	system_long_wq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kmsg_dump_unregister	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	secure_tcpv6_sequence_number	vmlinux	EXPORT_SYMBOL
 0x00000000	input_register_handle	vmlinux	EXPORT_SYMBOL
 0x00000000	blkdev_issue_zeroout	vmlinux	EXPORT_SYMBOL
 0x00000000	handle_level_irq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	silan_pad_check	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_radiotap_iterator_init	vmlinux	EXPORT_SYMBOL
 0x00000000	sdio_writesb	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	lzo1x_decompress_safe	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scatterwalk_done	vmlinux	EXPORT_SYMBOL_GPL
@@ -2152,15 +2001,12 @@
 0x00000000	skcipher_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	vfs_llseek	vmlinux	EXPORT_SYMBOL
 0x00000000	__irq_set_handler	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_find_sta	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_tx_status_irqsafe	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_dma_free_pages	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_get_drvdata	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_set_drvdata	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_handle_irq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_dapm_add_routes	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	blocking_notifier_chain_cond_register	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	__xfrm_state_destroy	vmlinux	EXPORT_SYMBOL
 0x00000000	bfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_unpoison_urb	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_port_init	vmlinux	EXPORT_SYMBOL
@@ -2170,7 +2016,6 @@
 0x00000000	net_msg_warn	vmlinux	EXPORT_SYMBOL
 0x00000000	__sock_recv_timestamp	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	noop_fsync	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_ibss_joined	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_add_host_with_dma	vmlinux	EXPORT_SYMBOL
 0x00000000	devres_remove_group	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_hash_walk_first	vmlinux	EXPORT_SYMBOL_GPL
@@ -2181,7 +2026,6 @@
 0x00000000	dev_set_allmulti	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_ctl_remove_id	vmlinux	EXPORT_SYMBOL
 0x00000000	mmc_can_erase	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_add_adapter	vmlinux	EXPORT_SYMBOL
 0x00000000	input_mt_report_finger_count	vmlinux	EXPORT_SYMBOL
 0x00000000	__bitmap_intersects	vmlinux	EXPORT_SYMBOL
 0x00000000	ksize	vmlinux	EXPORT_SYMBOL
@@ -2198,17 +2042,14 @@
 0x00000000	__sync_dirty_buffer	vmlinux	EXPORT_SYMBOL
 0x00000000	cancel_dirty_page	vmlinux	EXPORT_SYMBOL
 0x00000000	tasklet_kill	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_use_client	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_print_command	vmlinux	EXPORT_SYMBOL
 0x00000000	amba_driver_register	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_endio	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_stop_queues	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ct_expect_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sk_stop_timer	vmlinux	EXPORT_SYMBOL
 0x00000000	sg_free_table	vmlinux	EXPORT_SYMBOL
 0x00000000	locks_remove_posix	vmlinux	EXPORT_SYMBOL
 0x00000000	radix_tree_delete	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_enable_dyn_ps	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_slow_start	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	proc_net_netfilter	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_activate	vmlinux	EXPORT_SYMBOL
@@ -2225,11 +2066,9 @@
 0x00000000	names_cachep	vmlinux	EXPORT_SYMBOL
 0x00000000	invalidate_inode_pages2_range	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	qword_addhex	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_policy_register_afinfo	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_info_create_card_entry	vmlinux	EXPORT_SYMBOL
 0x00000000	key_instantiate_and_link	vmlinux	EXPORT_SYMBOL
 0x00000000	dentry_path_raw	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_sad_getinfo	vmlinux	EXPORT_SYMBOL
 0x00000000	netif_napi_del	vmlinux	EXPORT_SYMBOL
 0x00000000	input_event_from_user	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	wait_for_device_probe	vmlinux	EXPORT_SYMBOL_GPL
@@ -2238,14 +2077,10 @@
 0x00000000	debugfs_rename	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	single_open	vmlinux	EXPORT_SYMBOL
 0x00000000	page_follow_link_light	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_send_disassoc	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm6_find_1stfragopt	vmlinux	EXPORT_SYMBOL
-0x00000000	snd_lookup_oss_minor_data	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_request_card	vmlinux	EXPORT_SYMBOL
 0x00000000	__scsi_print_command	vmlinux	EXPORT_SYMBOL
 0x00000000	kthread_stop	vmlinux	EXPORT_SYMBOL
 0x00000000	lockd_down	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_nullfunc_get	vmlinux	EXPORT_SYMBOL
 0x00000000	xprt_reserve_xprt	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rtc_set_alarm	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__scsi_get_command	vmlinux	EXPORT_SYMBOL_GPL
@@ -2265,7 +2100,6 @@
 0x00000000	DWC_WORKQ_FREE	vmlinux	EXPORT_SYMBOL
 0x00000000	debugfs_remove_recursive	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dwc_usb_board_init	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_send_deauth	vmlinux	EXPORT_SYMBOL
 0x00000000	neigh_parms_alloc	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_disabled	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mount_single	vmlinux	EXPORT_SYMBOL
@@ -2279,12 +2113,10 @@
 0x00000000	disk_part_iter_next	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	block_write_end	vmlinux	EXPORT_SYMBOL
 0x00000000	pid_vnr	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	__xfrm_decode_session	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_net_ipv4_netfilter_sysctl_path	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_port_lower_dtr_rts	vmlinux	EXPORT_SYMBOL
 0x00000000	bitmap_set	vmlinux	EXPORT_SYMBOL
 0x00000000	__clocksource_updatefreq_scale	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	wiphy_rfkill_stop_polling	vmlinux	EXPORT_SYMBOL
 0x00000000	netlink_set_err	vmlinux	EXPORT_SYMBOL
 0x00000000	alloc_netdev_mqs	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_TIMER_ALLOC	vmlinux	EXPORT_SYMBOL
@@ -2305,8 +2137,6 @@
 0x00000000	xt_check_target	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sdio_claim_irq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	fsstack_copy_attr_all	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	udp6_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_init_replay	vmlinux	EXPORT_SYMBOL
 0x00000000	udp4_lib_lookup	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__nf_ct_try_assign_helper	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	genl_unregister_ops	vmlinux	EXPORT_SYMBOL
@@ -2322,7 +2152,6 @@
 0x00000000	input_register_handler	vmlinux	EXPORT_SYMBOL
 0x00000000	dma_pool_free	vmlinux	EXPORT_SYMBOL
 0x00000000	monotonic_to_bootbased	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	inet6_csk_bind_conflict	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ipv4_config	vmlinux	EXPORT_SYMBOL
 0x00000000	netif_carrier_on	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_MUTEX_LOCK	vmlinux	EXPORT_SYMBOL
@@ -2330,9 +2159,6 @@
 0x00000000	__bitmap_full	vmlinux	EXPORT_SYMBOL
 0x00000000	print_hex_dump	vmlinux	EXPORT_SYMBOL
 0x00000000	_flush_cache_mm	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_rts_duration	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_del_sta	vmlinux	EXPORT_SYMBOL
-0x00000000	ip6_route_output	vmlinux	EXPORT_SYMBOL
 0x00000000	__rta_fill	vmlinux	EXPORT_SYMBOL
 0x00000000	__dst_free	vmlinux	EXPORT_SYMBOL
 0x00000000	__DWC_FREE	vmlinux	EXPORT_SYMBOL
@@ -2366,14 +2192,12 @@
 0x00000000	netdev_rx_csum_fault	vmlinux	EXPORT_SYMBOL
 0x00000000	devres_release_group	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xdr_decode_array2	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ipv6_push_nfrag_opts	vmlinux	EXPORT_SYMBOL
 0x00000000	ipt_register_table	vmlinux	EXPORT_SYMBOL
 0x00000000	neigh_sysctl_unregister	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_format_width	vmlinux	EXPORT_SYMBOL
 0x00000000	dwc_cc_change	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_abort_request	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__scm_destroy	vmlinux	EXPORT_SYMBOL
-0x00000000	snd_mixer_oss_notify_callback	vmlinux	EXPORT_SYMBOL
 0x00000000	sdio_writeb_readb	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	DWC_TASK_ALLOC	vmlinux	EXPORT_SYMBOL
 0x00000000	d_move	vmlinux	EXPORT_SYMBOL
@@ -2381,7 +2205,6 @@
 0x00000000	request_key_async	vmlinux	EXPORT_SYMBOL
 0x00000000	touch_atime	vmlinux	EXPORT_SYMBOL
 0x00000000	get_cpu_idle_time_us	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_unregister_hw	vmlinux	EXPORT_SYMBOL
 0x00000000	device_set_wakeup_capable	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mod_timer_pending	vmlinux	EXPORT_SYMBOL
 0x00000000	rtnl_configure_link	vmlinux	EXPORT_SYMBOL
@@ -2389,15 +2212,12 @@
 0x00000000	snd_soc_codec_writable_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	strchr	vmlinux	EXPORT_SYMBOL
 0x00000000	strstr	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_get_buffered_bc	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_csk_listen_stop	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_wait_anchor_empty_timeout	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	uart_parse_options	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kobject_create_and_add	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	setup_new_exec	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_state_lookup_byaddr	vmlinux	EXPORT_SYMBOL
 0x00000000	pskb_expand_head	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_release_client	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_WAITQ_TRIGGER	vmlinux	EXPORT_SYMBOL
 0x00000000	pm_qos_update_request	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rtnl_link_register	vmlinux	EXPORT_SYMBOL_GPL
@@ -2454,18 +2274,15 @@
 0x00000000	nf_conntrack_helper_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_seq_root	vmlinux	EXPORT_SYMBOL
 0x00000000	crypto_attr_alg_name	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_calg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_hc_died	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	free_irq	vmlinux	EXPORT_SYMBOL
 0x00000000	__ioremap	vmlinux	EXPORT_SYMBOL
 0x00000000	trap	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_get_response_rate	vmlinux	EXPORT_SYMBOL
 0x00000000	deactivate_locked_super	vmlinux	EXPORT_SYMBOL
 0x00000000	filemap_fdatawait	vmlinux	EXPORT_SYMBOL
 0x00000000	rpcauth_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netdev_class_create_file	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_format_big_endian	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_cqm_pktloss_notify	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_wake_up	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netdev_rx_handler_unregister	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	skb_copy_datagram_const_iovec	vmlinux	EXPORT_SYMBOL
@@ -2495,7 +2312,6 @@
 0x00000000	snd_ecards_limit	vmlinux	EXPORT_SYMBOL
 0x00000000	uart_register_driver	vmlinux	EXPORT_SYMBOL
 0x00000000	__bitmap_and	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_alloc_spi	vmlinux	EXPORT_SYMBOL
 0x00000000	netdev_set_bond_master	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_rq_err_bytes	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_blkcipher_type	vmlinux	EXPORT_SYMBOL_GPL
@@ -2538,11 +2354,9 @@
 0x00000000	sysfs_format_mac	vmlinux	EXPORT_SYMBOL
 0x00000000	sk_send_sigurg	vmlinux	EXPORT_SYMBOL
 0x00000000	spi_bus_lock	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_sched_scan_stopped	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_crit	vmlinux	EXPORT_SYMBOL
 0x00000000	drop_super	vmlinux	EXPORT_SYMBOL
 0x00000000	printk	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_get_bss	vmlinux	EXPORT_SYMBOL
 0x00000000	sk_alloc	vmlinux	EXPORT_SYMBOL
 0x00000000	bus_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	remove_inode_hash	vmlinux	EXPORT_SYMBOL
@@ -2565,7 +2379,6 @@
 0x00000000	tcp_memory_pressure	vmlinux	EXPORT_SYMBOL
 0x00000000	setattr_copy	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_frags_fini	vmlinux	EXPORT_SYMBOL
-0x00000000	snd_register_oss_device	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_info_get_line	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_queue_work	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	elv_dispatch_sort	vmlinux	EXPORT_SYMBOL
@@ -2592,6 +2405,7 @@
 0x00000000	DWC_SPINLOCK_ALLOC	vmlinux	EXPORT_SYMBOL
 0x00000000	sysdev_class_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sunrpc_cache_unregister_pipefs	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_resume_rx	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__class_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__div64_32	vmlinux	EXPORT_SYMBOL
 0x00000000	idr_remove_all	vmlinux	EXPORT_SYMBOL
@@ -2609,7 +2423,6 @@
 0x00000000	ipv4_specific	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ct_l3proto_find_get	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	proto_unregister	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_new_dummy	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	register_mtd_chip_driver	vmlinux	EXPORT_SYMBOL
 0x00000000	__fsnotify_inode_delete	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	DWC_UTF8_TO_UTF16LE	vmlinux	EXPORT_SYMBOL
@@ -2630,7 +2443,6 @@
 0x00000000	nf_nat_get_offset	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kthread_bind	vmlinux	EXPORT_SYMBOL
 0x00000000	xprt_disconnect_done	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ipv6_setsockopt	vmlinux	EXPORT_SYMBOL
 0x00000000	del_mtd_blktrans_dev	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	cache_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_frag_find	vmlinux	EXPORT_SYMBOL
@@ -2662,7 +2474,6 @@
 0x00000000	sysfs_get_dirent	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	destroy_workqueue	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	idle_notifier_unregister	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	inet6_csk_reqsk_queue_hash_add	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_twsk_put	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	do_SAK	vmlinux	EXPORT_SYMBOL
 0x00000000	fat_get_dotdot_entry	vmlinux	EXPORT_SYMBOL_GPL
@@ -2675,11 +2486,9 @@
 0x00000000	page_put_link	vmlinux	EXPORT_SYMBOL
 0x00000000	release_pages	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_sleep_on	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	km_state_expired	vmlinux	EXPORT_SYMBOL
 0x00000000	qdisc_list_del	vmlinux	EXPORT_SYMBOL
 0x00000000	get_option	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_con_send	vmlinux	EXPORT_SYMBOL
-0x00000000	register_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_accept	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_select_initial_window	vmlinux	EXPORT_SYMBOL
 0x00000000	register_pernet_device	vmlinux	EXPORT_SYMBOL_GPL
@@ -2707,13 +2516,10 @@
 0x00000000	generic_fillattr	vmlinux	EXPORT_SYMBOL
 0x00000000	mempool_alloc_slab	vmlinux	EXPORT_SYMBOL
 0x00000000	param_set_invbool	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_register_driver	vmlinux	EXPORT_SYMBOL
 0x00000000	d_instantiate_unique	vmlinux	EXPORT_SYMBOL
 0x00000000	request_threaded_irq	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_send_unprot_disassoc	vmlinux	EXPORT_SYMBOL
 0x00000000	svc_drop	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mutex_lock_interruptible	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_get_mesh	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_clone	vmlinux	EXPORT_SYMBOL
 0x00000000	input_get_keycode	vmlinux	EXPORT_SYMBOL
 0x00000000	wakeup_source_destroy	vmlinux	EXPORT_SYMBOL_GPL
@@ -2724,8 +2530,6 @@
 0x00000000	snmp_fold_field	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tcp_init_xmit_timers	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_register_card	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	phy_ethtool_sset	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_ethtool_gset	vmlinux	EXPORT_SYMBOL
 0x00000000	eventfd_ctx_fdget	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	vfs_lock_file	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bio_uncopy_user	vmlinux	EXPORT_SYMBOL
@@ -2748,7 +2552,6 @@
 0x00000000	mmc_host_enable	vmlinux	EXPORT_SYMBOL
 0x00000000	rtc_set_time	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	auth_domain_lookup	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	icmpv6_err_convert	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_register_device_handler	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	do_sync_write	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_readv	vmlinux	EXPORT_SYMBOL
@@ -2784,10 +2587,8 @@
 0x00000000	filemap_flush	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_stack_limits	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_calc_raw_layout	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_scan_completed	vmlinux	EXPORT_SYMBOL
 0x00000000	unix_domain_find	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tcp_set_state	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	i2c_smbus_read_i2c_block_data	vmlinux	EXPORT_SYMBOL
 0x00000000	tty_mutex	vmlinux	EXPORT_SYMBOL
 0x00000000	strnlen_user	vmlinux	EXPORT_SYMBOL
 0x00000000	xt_free_table_info	vmlinux	EXPORT_SYMBOL
@@ -2798,7 +2599,6 @@
 0x00000000	__page_symlink	vmlinux	EXPORT_SYMBOL
 0x00000000	install_exec_creds	vmlinux	EXPORT_SYMBOL
 0x00000000	sched_setscheduler	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	unregister_sound_midi	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_open	vmlinux	EXPORT_SYMBOL
 0x00000000	__kfifo_from_user	vmlinux	EXPORT_SYMBOL
 0x00000000	xdr_skb_read_bits	vmlinux	EXPORT_SYMBOL_GPL
@@ -2806,8 +2606,6 @@
 0x00000000	inet_putpeer	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_ctl_register_ioctl	vmlinux	EXPORT_SYMBOL
 0x00000000	mmc_card_sleep	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_adapter_type	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	inet6_sk_rebuild_header	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sdio_reset_comm	vmlinux	EXPORT_SYMBOL
 0x00000000	device_init_wakeup	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	system_wq	vmlinux	EXPORT_SYMBOL_GPL
@@ -2815,15 +2613,12 @@
 0x00000000	nf_ct_extend_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	register_mtd_parser	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mark_page_accessed	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_count_enc_supported	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	nf_conntrack_destroy	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_report_bus_reset	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_compare_options	vmlinux	EXPORT_SYMBOL
-0x00000000	ip6_sk_dst_lookup_flow	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_dma_get_reserved_buf	vmlinux	EXPORT_SYMBOL
 0x00000000	cdev_add	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_update_rtt	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_input	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_uc_add	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_uc_del	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_mc_add	vmlinux	EXPORT_SYMBOL
@@ -2839,12 +2634,12 @@
 0x00000000	rt_mutex_destroy	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	system_freezable_wq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	queue_delayed_work_on	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_report_low_ack	vmlinux	EXPORT_SYMBOL
 0x00000000	devres_open_group	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	div_s64_rem	vmlinux	EXPORT_SYMBOL
 0x00000000	__set_page_dirty_nobuffers	vmlinux	EXPORT_SYMBOL
 0x00000000	svc_xprt_copy_addrs	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__nf_ct_kill_acct	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_unlink_rx_urbs	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mempool_create_node	vmlinux	EXPORT_SYMBOL
 0x00000000	find_get_pid	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dev_set_promiscuity	vmlinux	EXPORT_SYMBOL
@@ -2873,7 +2668,6 @@
 0x00000000	__inet_twsk_hashdance	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	neigh_table_init_no_netlink	vmlinux	EXPORT_SYMBOL
 0x00000000	gnet_stats_copy_app	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_verify_client	vmlinux	EXPORT_SYMBOL
 0x00000000	input_allocate_device	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_printk	vmlinux	EXPORT_SYMBOL
 0x00000000	bitmap_parselist	vmlinux	EXPORT_SYMBOL
@@ -2883,7 +2677,6 @@
 0x00000000	fs_overflowgid	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_dh_set_params	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bio_clone	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_policy_walk	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_card_proc_new	vmlinux	EXPORT_SYMBOL
 0x00000000	spi_bitbang_setup_transfer	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	blocking_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
@@ -2893,7 +2686,6 @@
 0x00000000	unregister_blkdev	vmlinux	EXPORT_SYMBOL
 0x00000000	key_alloc	vmlinux	EXPORT_SYMBOL
 0x00000000	write_inode_now	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_amsdu_to_8023s	vmlinux	EXPORT_SYMBOL
 0x00000000	dpm_suspend_noirq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sysdev_store_ulong	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_termios_hw_change	vmlinux	EXPORT_SYMBOL
@@ -2910,22 +2702,16 @@
 0x00000000	fsnotify	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	generic_file_open	vmlinux	EXPORT_SYMBOL
 0x00000000	ktime_get	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_new_sta	vmlinux	EXPORT_SYMBOL
-0x00000000	genphy_update_link	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_cont_expand_simple	vmlinux	EXPORT_SYMBOL
 0x00000000	d_instantiate	vmlinux	EXPORT_SYMBOL
-0x00000000	register_sound_special_device	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_queue_rq_timed_out	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dma_map_page	vmlinux	EXPORT_SYMBOL
 0x00000000	xt_alloc_table_info	vmlinux	EXPORT_SYMBOL
 0x00000000	sysdev_create_file	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crc32_be	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_osdc_new_request	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_register_hw	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_restart_call	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_output_resume	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	skb_find_text	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_unregister_device	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bio_integrity_add_page	vmlinux	EXPORT_SYMBOL
 0x00000000	current_fs_time	vmlinux	EXPORT_SYMBOL
 0x00000000	dma_map_sg	vmlinux	EXPORT_SYMBOL
@@ -2952,12 +2738,10 @@
 0x00000000	elevator_init	vmlinux	EXPORT_SYMBOL
 0x00000000	kill_fasync	vmlinux	EXPORT_SYMBOL
 0x00000000	param_get_byte	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_sta_ps_transition	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_disable_lro	vmlinux	EXPORT_SYMBOL
 0x00000000	attribute_container_classdev_to_container	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kblockd_schedule_delayed_work	vmlinux	EXPORT_SYMBOL
 0x00000000	debugfs_create_u8	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_find_sta_by_ifaddr	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_dapm_info_pin_switch	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	DWC_TASK_SCHEDULE	vmlinux	EXPORT_SYMBOL
 0x00000000	__gpio_get_value	vmlinux	EXPORT_SYMBOL_GPL
@@ -2975,8 +2759,8 @@
 0x00000000	blk_end_request_cur	vmlinux	EXPORT_SYMBOL
 0x00000000	vfsmount_lock_local_lock_cpu	vmlinux	EXPORT_SYMBOL
 0x00000000	replace_mount_options	vmlinux	EXPORT_SYMBOL
-0x00000000	__xfrm_policy_check	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_ctl_rename_id	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_get_link	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	blk_sync_queue	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_lld_busy	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	pskb_copy	vmlinux	EXPORT_SYMBOL
@@ -2990,7 +2774,6 @@
 0x00000000	spi_async	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	round_jiffies_up_relative	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	eth_header_cache	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_smbus_read_byte_data	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_print_sense_hdr	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_host_lookup	vmlinux	EXPORT_SYMBOL
 0x00000000	uart_set_options	vmlinux	EXPORT_SYMBOL_GPL
@@ -3022,7 +2805,6 @@
 0x00000000	radix_tree_tag_get	vmlinux	EXPORT_SYMBOL
 0x00000000	posix_acl_from_xattr	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_seq_read	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_transfer	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_device_lookup	vmlinux	EXPORT_SYMBOL
 0x00000000	param_set_int	vmlinux	EXPORT_SYMBOL
 0x00000000	xdr_inline_pages	vmlinux	EXPORT_SYMBOL_GPL
@@ -3050,7 +2832,6 @@
 0x00000000	sysfs_create_group	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	g_make_token_header	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xprt_release_rqst_cong	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_unregister_mode	vmlinux	EXPORT_SYMBOL
 0x00000000	consume_skb	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_MUTEX_UNLOCK	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_add_device	vmlinux	EXPORT_SYMBOL
@@ -3058,7 +2839,6 @@
 0x00000000	rpc_alloc_iostats	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ethtool_op_get_tso	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_lib_get_vmalloc_page	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_add_numbered_adapter	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_unanchor_urb	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bio_kmalloc	vmlinux	EXPORT_SYMBOL
 0x00000000	poll_schedule_timeout	vmlinux	EXPORT_SYMBOL
@@ -3093,7 +2873,6 @@
 0x00000000	wait_for_completion	vmlinux	EXPORT_SYMBOL
 0x00000000	csum_partial_copy_to_xdr	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dev_get_by_name_rcu	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_smbus_write_byte_data	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_unlink_urb	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	___ratelimit	vmlinux	EXPORT_SYMBOL
 0x00000000	__nf_nat_mangle_tcp_packet	vmlinux	EXPORT_SYMBOL
@@ -3105,7 +2884,6 @@
 0x00000000	put_rpccred	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_twdr_twcal_tick	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sock_create_lite	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_sta_set_tim	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_register_dais	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	d_obtain_alias	vmlinux	EXPORT_SYMBOL
 0x00000000	ip4_datagram_connect	vmlinux	EXPORT_SYMBOL
@@ -3113,7 +2891,6 @@
 0x00000000	nf_conntrack_helper_try_module_get	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	schedule_hrtimeout	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ceph_osdc_put_event	vmlinux	EXPORT_SYMBOL
-0x00000000	mod_firmware_load	vmlinux	EXPORT_SYMBOL
 0x00000000	starget_for_each_device	vmlinux	EXPORT_SYMBOL
 0x00000000	nobh_writepage	vmlinux	EXPORT_SYMBOL
 0x00000000	clear_page_dirty_for_io	vmlinux	EXPORT_SYMBOL
@@ -3166,7 +2943,6 @@
 0x00000000	skb_trim	vmlinux	EXPORT_SYMBOL
 0x00000000	gpio_request_one	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	svc_proc_register	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_policy_delete	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_frags_init	vmlinux	EXPORT_SYMBOL
 0x00000000	rtc_irq_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	match_int	vmlinux	EXPORT_SYMBOL
@@ -3178,22 +2954,19 @@
 0x00000000	rpcauth_generic_bind_cred	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	skb_cow_data	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_pcm_kernel_ioctl	vmlinux	EXPORT_SYMBOL
-0x00000000	bridge_tunnel_header	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_card_free_when_closed	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_get_adapter	vmlinux	EXPORT_SYMBOL
 0x00000000	get_options	vmlinux	EXPORT_SYMBOL
 0x00000000	setup_irq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xdr_partial_copy_from_skb	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	input_unregister_handler	vmlinux	EXPORT_SYMBOL
 0x00000000	bh_uptodate_or_lock	vmlinux	EXPORT_SYMBOL
 0x00000000	__kfifo_in_r	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_chswitch_done	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_state_walk_init	vmlinux	EXPORT_SYMBOL
 0x00000000	rtc_read_alarm	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_get_settings	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_set_settings	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	string_get_size	vmlinux	EXPORT_SYMBOL
 0x00000000	fat_fill_super	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	register_exec_domain	vmlinux	EXPORT_SYMBOL
-0x00000000	fl6_sock_lookup	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sg_alloc_table	vmlinux	EXPORT_SYMBOL
 0x00000000	handle_simple_irq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	async_synchronize_cookie_domain	vmlinux	EXPORT_SYMBOL_GPL
@@ -3202,11 +2975,8 @@
 0x00000000	nf_hooks	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_info_free_entry	vmlinux	EXPORT_SYMBOL
 0x00000000	pm_qos_remove_notifier	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_connection_loss	vmlinux	EXPORT_SYMBOL
 0x00000000	DWC_MEMMOVE	vmlinux	EXPORT_SYMBOL
 0x00000000	seq_list_start	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_aead_get_byname	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	km_state_notify	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_set_ops	vmlinux	EXPORT_SYMBOL
 0x00000000	dma_run_dependencies	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	completion_done	vmlinux	EXPORT_SYMBOL
@@ -3235,7 +3005,6 @@
 0x00000000	wait_for_key_construction	vmlinux	EXPORT_SYMBOL
 0x00000000	f_setown	vmlinux	EXPORT_SYMBOL
 0x00000000	xdr_encode_string	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ip6_dst_hoplimit	vmlinux	EXPORT_SYMBOL
 0x00000000	arp_invalidate	vmlinux	EXPORT_SYMBOL
 0x00000000	silan_i2s_hdmi_dai	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_clear_halt	vmlinux	EXPORT_SYMBOL_GPL
@@ -3250,18 +3019,15 @@
 0x00000000	kvasprintf	vmlinux	EXPORT_SYMBOL
 0x00000000	rb_insert_color	vmlinux	EXPORT_SYMBOL
 0x00000000	svcauth_unix_set_client	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	__xfrm_init_state	vmlinux	EXPORT_SYMBOL
 0x00000000	symbol_put_addr	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__module_text_address	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	hrtimer_start_range_ns	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	cpu_possible_mask	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_smbus_read_word_data	vmlinux	EXPORT_SYMBOL
 0x00000000	tty_buffer_request_room	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	d_alloc	vmlinux	EXPORT_SYMBOL
 0x00000000	unuse_mm	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__alloc_pages_nodemask	vmlinux	EXPORT_SYMBOL
 0x00000000	elv_abort_queue	vmlinux	EXPORT_SYMBOL
-0x00000000	wiphy_unregister	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_err	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_execute_rq_nowait	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	clk_get_rate	vmlinux	EXPORT_SYMBOL
@@ -3271,15 +3037,12 @@
 0x00000000	kernel_sendpage	vmlinux	EXPORT_SYMBOL
 0x00000000	delete_from_page_cache	vmlinux	EXPORT_SYMBOL
 0x00000000	wait_for_completion_killable	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_send_assoc_timeout	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_dai_set_sysclk	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__alloc_percpu	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	clear_user	vmlinux	EXPORT_SYMBOL
 0x00000000	led_trigger_unregister	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_cmd_get_serial	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_calc_pg_primary	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wext_siwessid	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwessid	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	svc_close_xprt	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	neigh_parms_release	vmlinux	EXPORT_SYMBOL
 0x00000000	mmc_card_awake	vmlinux	EXPORT_SYMBOL
@@ -3295,12 +3058,10 @@
 0x00000000	scsi_register_interface	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_setlease	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	console_trylock	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_smbus_read_block_data	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_put_intf	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	blk_queue_dma_pad	vmlinux	EXPORT_SYMBOL
 0x00000000	set_current_groups	vmlinux	EXPORT_SYMBOL
 0x00000000	wait_for_completion_timeout	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm6_input_addr	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_stor_probe1	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_stor_probe2	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xz_dec_reset	vmlinux	EXPORT_SYMBOL
@@ -3333,7 +3094,6 @@
 0x00000000	tcp_child_process	vmlinux	EXPORT_SYMBOL
 0x00000000	crc_t10dif	vmlinux	EXPORT_SYMBOL
 0x00000000	param_get_charp	vmlinux	EXPORT_SYMBOL
-0x00000000	mdiobus_write	vmlinux	EXPORT_SYMBOL
 0x00000000	bsg_unregister_queue	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	prepare_binprm	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_v4_destroy_sock	vmlinux	EXPORT_SYMBOL
@@ -3342,7 +3102,6 @@
 0x00000000	mount_bdev	vmlinux	EXPORT_SYMBOL
 0x00000000	can_do_mlock	vmlinux	EXPORT_SYMBOL
 0x00000000	__print_symbol	vmlinux	EXPORT_SYMBOL
-0x00000000	ndisc_mc_map	vmlinux	EXPORT_SYMBOL
 0x00000000	sysdev_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sprintf	vmlinux	EXPORT_SYMBOL
 0x00000000	simple_unlink	vmlinux	EXPORT_SYMBOL
@@ -3373,10 +3132,8 @@
 0x00000000	nlmclnt_done	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dio_end_io	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	timecounter_cyc2time	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_wake_queue	vmlinux	EXPORT_SYMBOL
 0x00000000	rtc_tm_to_ktime	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	generic_check_addressable	vmlinux	EXPORT_SYMBOL
-0x00000000	inet6_csk_addr2sockaddr	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netdev_refcnt_read	vmlinux	EXPORT_SYMBOL
 0x00000000	input_mt_init_slots	vmlinux	EXPORT_SYMBOL
 0x00000000	__pm_wakeup_event	vmlinux	EXPORT_SYMBOL_GPL
@@ -3392,7 +3149,6 @@
 0x00000000	simple_strtoul	vmlinux	EXPORT_SYMBOL
 0x00000000	simple_strtoll	vmlinux	EXPORT_SYMBOL
 0x00000000	nfs_initiate_commit	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_napi_complete	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_register_afinfo	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	net_ns_type_operations	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	proc_symlink	vmlinux	EXPORT_SYMBOL
@@ -3408,7 +3164,6 @@
 0x00000000	kernel_restart	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dev_alloc_skb	vmlinux	EXPORT_SYMBOL
 0x00000000	memchr	vmlinux	EXPORT_SYMBOL
-0x00000000	inet6_release	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ct_expect_hsize	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	vfs_kern_mount	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	gss_mech_list_pseudoflavors	vmlinux	EXPORT_SYMBOL_GPL
@@ -3420,7 +3175,6 @@
 0x00000000	register_oom_notifier	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	handle_nested_irq	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ceph_msg_dump	vmlinux	EXPORT_SYMBOL
-0x00000000	fl6_update_dst	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	neigh_lookup	vmlinux	EXPORT_SYMBOL
 0x00000000	mmc_remove_host	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_put_hcd	vmlinux	EXPORT_SYMBOL_GPL
@@ -3434,6 +3188,7 @@
 0x00000000	sysfs_streq	vmlinux	EXPORT_SYMBOL
 0x00000000	alloc_buffer_head	vmlinux	EXPORT_SYMBOL
 0x00000000	xdr_write_pages	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_get_endpoints	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	device_remove_file	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	unmap_kernel_range_noflush	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ipv6_skip_exthdr	vmlinux	EXPORT_SYMBOL
@@ -3443,37 +3198,30 @@
 0x00000000	param_get_ulong	vmlinux	EXPORT_SYMBOL
 0x00000000	kill_pid	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_get_direct_page_vector	vmlinux	EXPORT_SYMBOL
-0x00000000	rt6_lookup	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_frags_init_net	vmlinux	EXPORT_SYMBOL
 0x00000000	spi_bitbang_cleanup	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	congestion_wait	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_del_driver	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_queue_dma_drain	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_beacon_loss	vmlinux	EXPORT_SYMBOL
 0x00000000	__dma_request_channel	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	hex_dump_to_buffer	vmlinux	EXPORT_SYMBOL
 0x00000000	file_ra_state_init	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mach_get_ss	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_alloc_coherent	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_larval_kill	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_register_mode	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_csk_get_port	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	i2c_clients_command	vmlinux	EXPORT_SYMBOL
 0x00000000	klist_remove	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ethtool_op_get_ufo	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_get_flags	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_get_status	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
 0x00000000	svc_auth_register	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	flow_cache_genid	vmlinux	EXPORT_SYMBOL
 0x00000000	gen_new_estimator	vmlinux	EXPORT_SYMBOL
 0x00000000	input_class	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dwc_notify	vmlinux	EXPORT_SYMBOL
 0x00000000	crypto_alg_mod_lookup	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	freeze_super	vmlinux	EXPORT_SYMBOL
 0x00000000	__devm_request_region	vmlinux	EXPORT_SYMBOL
-0x00000000	__cfg80211_send_disassoc	vmlinux	EXPORT_SYMBOL
 0x00000000	mmc_set_data_timeout	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_set_device_state	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_eh_finish_cmd	vmlinux	EXPORT_SYMBOL
@@ -3508,12 +3256,9 @@
 0x00000000	timecounter_init	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_addr_type	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_recvmsg	vmlinux	EXPORT_SYMBOL
-0x00000000	mdiobus_unregister	vmlinux	EXPORT_SYMBOL
 0x00000000	timekeeping_inject_offset	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_detach	vmlinux	EXPORT_SYMBOL
 0x00000000	mii_link_ok	vmlinux	EXPORT_SYMBOL
 0x00000000	nfs_commitdata_alloc	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_inform_bss_frame	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_proc_register	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_conntrack_l4proto_udp6	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	wakeup_source_remove	vmlinux	EXPORT_SYMBOL_GPL
@@ -3522,7 +3267,6 @@
 0x00000000	generic_write_sync	vmlinux	EXPORT_SYMBOL
 0x00000000	lookup_create	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sdio_writel	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_policy_destroy	vmlinux	EXPORT_SYMBOL
 0x00000000	sdio_memcpy_toio	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ceph_osdc_release_request	vmlinux	EXPORT_SYMBOL
 0x00000000	neigh_ifdown	vmlinux	EXPORT_SYMBOL
@@ -3537,13 +3281,11 @@
 0x00000000	seq_bitmap_list	vmlinux	EXPORT_SYMBOL
 0x00000000	alloc_pages_exact	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_msg_new	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_rx	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_rx_irqsafe	vmlinux	EXPORT_SYMBOL
 0x00000000	gss_svc_to_pseudoflavor	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	svc_find_xprt	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	svc_process	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rpc_force_rebind	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	register_sound_special	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_skb_return	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__nla_reserve	vmlinux	EXPORT_SYMBOL
 0x00000000	alloc_chrdev_region	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_killall_tasks	vmlinux	EXPORT_SYMBOL_GPL
@@ -3558,7 +3300,6 @@
 0x00000000	finish_wait	vmlinux	EXPORT_SYMBOL
 0x00000000	klist_add_after	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	svc_xprt_init	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	phy_start_aneg	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_print_result	vmlinux	EXPORT_SYMBOL
 0x00000000	__bitmap_weight	vmlinux	EXPORT_SYMBOL
 0x00000000	simple_strtoull	vmlinux	EXPORT_SYMBOL
@@ -3571,9 +3312,7 @@
 0x00000000	get_net_ns_by_pid	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	mmc_power_save_host	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_statfs	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_iterate_active_interfaces_atomic	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	udp_ioctl	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_new_probed_device	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__nla_reserve_nohdr	vmlinux	EXPORT_SYMBOL
 0x00000000	rtnetlink_put_metrics	vmlinux	EXPORT_SYMBOL
 0x00000000	int_to_scsilun	vmlinux	EXPORT_SYMBOL
@@ -3591,9 +3330,6 @@
 0x00000000	tcp_death_row	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kstrtouint_from_user	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_get_nr_vecs	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wext_siwencode	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwencode	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_policy_byid	vmlinux	EXPORT_SYMBOL
 0x00000000	ahash_register_instance	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	load_nls_default	vmlinux	EXPORT_SYMBOL
 0x00000000	nonseekable_open	vmlinux	EXPORT_SYMBOL
@@ -3601,20 +3337,16 @@
 0x00000000	inet_get_local_port_range	vmlinux	EXPORT_SYMBOL
 0x00000000	seq_escape	vmlinux	EXPORT_SYMBOL
 0x00000000	__seq_open_private	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_ealg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_stor_resume	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	DWC_TIMER_CANCEL	vmlinux	EXPORT_SYMBOL
 0x00000000	d_alloc_root	vmlinux	EXPORT_SYMBOL
 0x00000000	irq_alloc_descs	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_lookup	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_store_bits	vmlinux	EXPORT_SYMBOL
 0x00000000	page_cache_sync_readahead	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	unregister_pm_notifier	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_unregister_protosw	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_get_volsw	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_put_volsw	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	i2c_probe_func_quick_read	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	i2c_smbus_read_byte	vmlinux	EXPORT_SYMBOL
 0x00000000	platform_create_bundle	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	_dev_info	vmlinux	EXPORT_SYMBOL
 0x00000000	svc_xprt_put	vmlinux	EXPORT_SYMBOL_GPL
@@ -3622,7 +3354,6 @@
 0x00000000	blkcipher_walk_phys	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	seq_hlist_start_head	vmlinux	EXPORT_SYMBOL
 0x00000000	clocksource_change_rating	vmlinux	EXPORT_SYMBOL
-0x00000000	__ieee80211_get_channel	vmlinux	EXPORT_SYMBOL
 0x00000000	sdio_set_block_size	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_stor_post_reset	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	DWC_PRINTF	vmlinux	EXPORT_SYMBOL
@@ -3653,7 +3384,6 @@
 0x00000000	thaw_super	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_file_mmap	vmlinux	EXPORT_SYMBOL
 0x00000000	abort_creds	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_alloc_hw	vmlinux	EXPORT_SYMBOL
 0x00000000	neigh_rand_reach_time	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_forward_skb	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sock_common_getsockopt	vmlinux	EXPORT_SYMBOL
@@ -3663,8 +3393,6 @@
 0x00000000	zlib_inflate_blob	vmlinux	EXPORT_SYMBOL
 0x00000000	idr_find	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_mknod	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_disconnected	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_send_rx_auth	vmlinux	EXPORT_SYMBOL
 0x00000000	ethtool_op_get_sg	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_dequeue	vmlinux	EXPORT_SYMBOL
 0x00000000	filemap_write_and_wait	vmlinux	EXPORT_SYMBOL
@@ -3676,7 +3404,6 @@
 0x00000000	netdev_features_change	vmlinux	EXPORT_SYMBOL
 0x00000000	platform_get_resource_byname	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	cpu_online_mask	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_start	vmlinux	EXPORT_SYMBOL
 0x00000000	devres_find	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	proc_dostring	vmlinux	EXPORT_SYMBOL
 0x00000000	usecs_to_jiffies	vmlinux	EXPORT_SYMBOL
@@ -3695,14 +3422,12 @@
 0x00000000	dev_kfree_skb_irq	vmlinux	EXPORT_SYMBOL
 0x00000000	kill_mtd_super	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__symbol_put	vmlinux	EXPORT_SYMBOL
-0x00000000	genphy_restart_aneg	vmlinux	EXPORT_SYMBOL
 0x00000000	get_zeroed_page	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_lib_read	vmlinux	EXPORT_SYMBOL
 0x00000000	input_close_device	vmlinux	EXPORT_SYMBOL
 0x00000000	key_validate	vmlinux	EXPORT_SYMBOL
 0x00000000	rtnl_create_link	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_format_silence_64	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_connect_direct	vmlinux	EXPORT_SYMBOL
 0x00000000	tty_insert_flip_string_flags	vmlinux	EXPORT_SYMBOL
 0x00000000	address_space_init_once	vmlinux	EXPORT_SYMBOL
 0x00000000	prepare_to_wait_exclusive	vmlinux	EXPORT_SYMBOL
@@ -3712,8 +3437,6 @@
 0x00000000	debugfs_create_size_t	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	remove_proc_entry	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_pagelist_release	vmlinux	EXPORT_SYMBOL
-0x00000000	ipv6_opt_accepted	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_spd_getinfo	vmlinux	EXPORT_SYMBOL
 0x00000000	block_is_partially_uptodate	vmlinux	EXPORT_SYMBOL
 0x00000000	xprt_load_transport	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	alloc_etherdev_mqs	vmlinux	EXPORT_SYMBOL
@@ -3734,7 +3457,6 @@
 0x00000000	fb_unregister_client	vmlinux	EXPORT_SYMBOL
 0x00000000	kstrtoint_from_user	vmlinux	EXPORT_SYMBOL
 0x00000000	crypto_larval_error	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_inner_extract_output	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_csk_init_xmit_timers	vmlinux	EXPORT_SYMBOL
 0x00000000	__nf_ct_l4proto_find	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	probe_kernel_read	vmlinux	EXPORT_SYMBOL_GPL
@@ -3743,7 +3465,6 @@
 0x00000000	vfs_readlink	vmlinux	EXPORT_SYMBOL
 0x00000000	timecompare_offset	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	complete_and_exit	vmlinux	EXPORT_SYMBOL
-0x00000000	inet6_lookup	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sysfs_remove_group	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sysfs_remove_file_from_group	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	get_monotonic_boottime	vmlinux	EXPORT_SYMBOL_GPL
@@ -3754,7 +3475,6 @@
 0x00000000	nf_getsockopt	vmlinux	EXPORT_SYMBOL
 0x00000000	rtnl_unregister_all	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netif_rx_ni	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_smbus_xfer	vmlinux	EXPORT_SYMBOL
 0x00000000	device_attach	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_port_open	vmlinux	EXPORT_SYMBOL
 0x00000000	alloc_disk	vmlinux	EXPORT_SYMBOL
@@ -3793,7 +3513,6 @@
 0x00000000	DWC_SPINLOCK_IRQSAVE	vmlinux	EXPORT_SYMBOL
 0x00000000	kthread_worker_fn	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dma_sync_sg_for_device	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_stateonly_find	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_create_hcd	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_device_type	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_integrity_is_initialized	vmlinux	EXPORT_SYMBOL
@@ -3818,8 +3537,6 @@
 0x00000000	aead_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dma_release_declared_memory	vmlinux	EXPORT_SYMBOL
 0x00000000	irq_set_chip_data	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_scan_done	vmlinux	EXPORT_SYMBOL
-0x00000000	inet6_csk_xmit	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tcp_ioctl	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_symlink	vmlinux	EXPORT_SYMBOL
 0x00000000	find_vpid	vmlinux	EXPORT_SYMBOL_GPL
@@ -3832,7 +3549,6 @@
 0x00000000	dma_async_tx_descriptor_init	vmlinux	EXPORT_SYMBOL
 0x00000000	cpu_present_mask	vmlinux	EXPORT_SYMBOL
 0x00000000	_flush_cache_all	vmlinux	EXPORT_SYMBOL
-0x00000000	wireless_send_event	vmlinux	EXPORT_SYMBOL
 0x00000000	xprt_release_xprt_cong	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_get_enum_double	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_put_enum_double	vmlinux	EXPORT_SYMBOL_GPL
@@ -3840,12 +3556,10 @@
 0x00000000	vm_get_page_prot	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_wake_up_queued_task	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rtc_irq_set_state	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	phy_driver_register	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_dma_unmap	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_put_port	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_conntrack_register_notifier	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sock_no_connect	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_print_status	vmlinux	EXPORT_SYMBOL
 0x00000000	send_remote_softirq	vmlinux	EXPORT_SYMBOL
 0x00000000	wait_for_completion_killable_timeout	vmlinux	EXPORT_SYMBOL
 0x00000000	skcipher_geniv_alloc	vmlinux	EXPORT_SYMBOL_GPL
@@ -3860,6 +3574,7 @@
 0x00000000	tcp_shutdown	vmlinux	EXPORT_SYMBOL
 0x00000000	copy_to_user_fromio	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_stor_set_xfer_buf	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_change_mtu	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_nonblockable_ioctl	vmlinux	EXPORT_SYMBOL
 0x00000000	down_write_trylock	vmlinux	EXPORT_SYMBOL
 0x00000000	param_set_uint	vmlinux	EXPORT_SYMBOL
@@ -3903,7 +3618,6 @@
 0x00000000	radix_tree_preload	vmlinux	EXPORT_SYMBOL
 0x00000000	blkdev_ioctl	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	__kernel_param_unlock	vmlinux	EXPORT_SYMBOL
-0x00000000	__i2c_board_lock	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_ldisc_flush	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_register_instance	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_alloc_tfm	vmlinux	EXPORT_SYMBOL_GPL
@@ -3942,16 +3656,12 @@
 0x00000000	net_namespace_list	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sock_register	vmlinux	EXPORT_SYMBOL
 0x00000000	device_set_wakeup_enable	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	__cfg80211_send_deauth	vmlinux	EXPORT_SYMBOL
-0x00000000	inet6_register_protosw	vmlinux	EXPORT_SYMBOL
 0x00000000	nfnl_lock	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netif_set_real_num_tx_queues	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_set_group	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_register_fixup_for_uid	vmlinux	EXPORT_SYMBOL
 0x00000000	register_mtd_blktrans	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_dev_info_add_list	vmlinux	EXPORT_SYMBOL
 0x00000000	end_buffer_async_write	vmlinux	EXPORT_SYMBOL
-0x00000000	rfc1042_header	vmlinux	EXPORT_SYMBOL
 0x00000000	ip_nat_decode_session	vmlinux	EXPORT_SYMBOL
 0x00000000	sdio_get_host_pm_caps	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	vfs_writev	vmlinux	EXPORT_SYMBOL
@@ -3973,7 +3683,6 @@
 0x00000000	snd_pcm_limit_hw_rates	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_bus_list	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bio_integrity_split	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_napi_schedule	vmlinux	EXPORT_SYMBOL
 0x00000000	radix_tree_range_tag_if_tagged	vmlinux	EXPORT_SYMBOL
 0x00000000	proc_dointvec_userhz_jiffies	vmlinux	EXPORT_SYMBOL
 0x00000000	console_start	vmlinux	EXPORT_SYMBOL
@@ -3984,12 +3693,10 @@
 0x00000000	simple_dir_inode_operations	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_codec_set_cache_io	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dmam_pool_create	vmlinux	EXPORT_SYMBOL
-0x00000000	genphy_suspend	vmlinux	EXPORT_SYMBOL
 0x00000000	__find_get_block	vmlinux	EXPORT_SYMBOL
 0x00000000	dcache_dir_open	vmlinux	EXPORT_SYMBOL
 0x00000000	put_unused_fd	vmlinux	EXPORT_SYMBOL
 0x00000000	jiffies_64_to_clock_t	vmlinux	EXPORT_SYMBOL
-0x00000000	inet6_lookup_listener	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rb_first	vmlinux	EXPORT_SYMBOL
 0x00000000	unregister_module_notifier	vmlinux	EXPORT_SYMBOL
 0x00000000	flush_delayed_work	vmlinux	EXPORT_SYMBOL
@@ -4014,15 +3721,11 @@
 0x00000000	nla_policy_len	vmlinux	EXPORT_SYMBOL
 0x00000000	bitmap_clear	vmlinux	EXPORT_SYMBOL
 0x00000000	fsync_bdev	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wext_giwrange	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	cache_unregister	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	xprt_set_retrans_timeout_def	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ip6_dst_lookup	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	i2c_new_device	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	device_for_each_child	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	vzalloc	vmlinux	EXPORT_SYMBOL
 0x00000000	timespec_to_jiffies	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_free_hw	vmlinux	EXPORT_SYMBOL
 0x00000000	unregister_key_type	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_shutdown_client	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	_ctype	vmlinux	EXPORT_SYMBOL
@@ -4044,7 +3747,6 @@
 0x00000000	do_settimeofday	vmlinux	EXPORT_SYMBOL
 0x00000000	netdev_increment_features	vmlinux	EXPORT_SYMBOL
 0x00000000	uart_match_port	vmlinux	EXPORT_SYMBOL
-0x00000000	flow_cache_lookup	vmlinux	EXPORT_SYMBOL
 0x00000000	alloc_tty_driver	vmlinux	EXPORT_SYMBOL
 0x00000000	__splice_from_pipe	vmlinux	EXPORT_SYMBOL
 0x00000000	unregister_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
@@ -4054,13 +3756,11 @@
 0x00000000	tty_write_room	vmlinux	EXPORT_SYMBOL
 0x00000000	sysfs_add_file_to_group	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	param_ops_ushort	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_pspoll_get	vmlinux	EXPORT_SYMBOL
 0x00000000	dev_trans_start	vmlinux	EXPORT_SYMBOL
 0x00000000	dmaengine_put	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_register_region	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_put	vmlinux	EXPORT_SYMBOL
 0x00000000	task_tgid_nr_ns	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_rts_get	vmlinux	EXPORT_SYMBOL
 0x00000000	input_alloc_absinfo	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_is_target_device	vmlinux	EXPORT_SYMBOL
 0x00000000	each_symbol_section	vmlinux	EXPORT_SYMBOL_GPL
@@ -4104,7 +3804,6 @@
 0x00000000	nf_conntrack_untracked	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_usual_ignore_device	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kstrtos16	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_request_smps	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_cache_read	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_info_volsw_ext	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_tgt_cmd_to_host	vmlinux	EXPORT_SYMBOL_GPL
@@ -4116,13 +3815,11 @@
 0x00000000	strncpy_from_user	vmlinux	EXPORT_SYMBOL
 0x00000000	gss_mech_put	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rpc_max_payload	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	inet6_hash_connect	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	gnet_stats_copy_rate_est	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_partial_csum_set	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sdio_enable_func	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	create_empty_buffers	vmlinux	EXPORT_SYMBOL
 0x00000000	init_special_inode	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_mgmt_tx_status	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_frag_destroy	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_make_writable	vmlinux	EXPORT_SYMBOL
 0x00000000	sk_chk_filter	vmlinux	EXPORT_SYMBOL
@@ -4139,13 +3836,10 @@
 0x00000000	vm_insert_pfn	vmlinux	EXPORT_SYMBOL
 0x00000000	out_of_line_wait_on_bit_lock	vmlinux	EXPORT_SYMBOL
 0x00000000	register_net_sysctl_table	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_state_alloc	vmlinux	EXPORT_SYMBOL
 0x00000000	rtnl_is_locked	vmlinux	EXPORT_SYMBOL
 0x00000000	fat_remove_entries	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	page_symlink	vmlinux	EXPORT_SYMBOL
 0x00000000	workqueue_congested	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	freq_reg_info	vmlinux	EXPORT_SYMBOL
-0x00000000	__xfrm_route_forward	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_get_volsw_2r	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_put_volsw_2r	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_soc_get_volsw_s8	vmlinux	EXPORT_SYMBOL_GPL
@@ -4166,7 +3860,6 @@
 0x00000000	sunrpc_cache_lookup	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	arp_tbl	vmlinux	EXPORT_SYMBOL
 0x00000000	__skb_recv_datagram	vmlinux	EXPORT_SYMBOL
-0x00000000	phy_attach	vmlinux	EXPORT_SYMBOL
 0x00000000	xdr_encode_opaque_fixed	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tcp_splice_read	vmlinux	EXPORT_SYMBOL
 0x00000000	xt_unregister_match	vmlinux	EXPORT_SYMBOL
@@ -4181,6 +3874,7 @@
 0x00000000	__nf_conntrack_find	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	lock_sock_nested	vmlinux	EXPORT_SYMBOL
 0x00000000	sdio_disable_func	vmlinux	EXPORT_SYMBOL_GPL
+0x00000000	usbnet_cdc_bind	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_free_command	vmlinux	EXPORT_SYMBOL
 0x00000000	platform_add_devices	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	flush_work	vmlinux	EXPORT_SYMBOL_GPL
@@ -4209,11 +3903,8 @@
 0x00000000	nf_ct_helper_ext_add	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	led_trigger_unregister_simple	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_stor_reset_resume	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	phy_disconnect	vmlinux	EXPORT_SYMBOL
 0x00000000	aead_geniv_free	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	register_chrdev_region	vmlinux	EXPORT_SYMBOL
-0x00000000	rate_control_send_low	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_radiotap_iterator_next	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_csk_reqsk_queue_prune	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netdev_state_change	vmlinux	EXPORT_SYMBOL
 0x00000000	sort	vmlinux	EXPORT_SYMBOL
@@ -4251,7 +3942,6 @@
 0x00000000	sdio_memcpy_fromio	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	flex_array_free_parts	vmlinux	EXPORT_SYMBOL
 0x00000000	svc_auth_unregister	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_unregister_type	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ip_checksum	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_info_register	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_iopoll_enabled	vmlinux	EXPORT_SYMBOL
@@ -4263,11 +3953,9 @@
 0x00000000	module_put	vmlinux	EXPORT_SYMBOL
 0x00000000	console_set_on_cmdline	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_get_from_anchor	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	genphy_resume	vmlinux	EXPORT_SYMBOL
 0x00000000	inode_get_bytes	vmlinux	EXPORT_SYMBOL
 0x00000000	__wake_up	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_conntrack_helper_unregister	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	i2c_for_each_dev	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dev_driver_string	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_mkdir	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_driver_claim_interface	vmlinux	EXPORT_SYMBOL_GPL
@@ -4278,12 +3966,10 @@
 0x00000000	led_trigger_set	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	eventfd_fget	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dget_parent	vmlinux	EXPORT_SYMBOL
-0x00000000	wiphy_new	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_mmap_data	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_get_dev	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	iunique	vmlinux	EXPORT_SYMBOL
 0x00000000	unregister_die_notifier	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_policy_walk_done	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_dgram_ops	vmlinux	EXPORT_SYMBOL
 0x00000000	input_release_device	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_put_command	vmlinux	EXPORT_SYMBOL
@@ -4293,7 +3979,6 @@
 0x00000000	get_unused_fd	vmlinux	EXPORT_SYMBOL
 0x00000000	files_lglock_global_unlock_online	vmlinux	EXPORT_SYMBOL
 0x00000000	proc_doulongvec_minmax	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_bss_get_ie	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_proc_unregister	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_store_new_id	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sdev_evt_send_simple	vmlinux	EXPORT_SYMBOL_GPL
@@ -4303,13 +3988,11 @@
 0x00000000	__kfifo_to_user	vmlinux	EXPORT_SYMBOL
 0x00000000	local_bh_enable_ip	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_con_close	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm4_rcv_encap	vmlinux	EXPORT_SYMBOL
 0x00000000	udp_poll	vmlinux	EXPORT_SYMBOL
 0x00000000	posix_acl_from_mode	vmlinux	EXPORT_SYMBOL
 0x00000000	kstrndup	vmlinux	EXPORT_SYMBOL
 0x00000000	irq_set_chip	vmlinux	EXPORT_SYMBOL
 0x00000000	console_stop	vmlinux	EXPORT_SYMBOL
-0x00000000	inet6_getname	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_conntrack_tuple_taken	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	snd_device_register	vmlinux	EXPORT_SYMBOL
 0x00000000	xdr_encode_word	vmlinux	EXPORT_SYMBOL_GPL
@@ -4336,7 +4019,6 @@
 0x00000000	kset_unregister	vmlinux	EXPORT_SYMBOL
 0x00000000	debugfs_create_u32	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	register_net_sysctl_rotable	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_siwpmksa	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netdev_rx_handler_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_csk_reset_keepalive_timer	vmlinux	EXPORT_SYMBOL
 0x00000000	user_read	vmlinux	EXPORT_SYMBOL_GPL
@@ -4366,21 +4048,18 @@
 0x00000000	ceph_monc_do_statfs	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_ifnum_to_if	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	debugfs_create_x16	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	inet6_destroy_sock	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	strcat	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_integrity_set_tag	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_integrity_get_tag	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_gadget_unregister_driver	vmlinux	EXPORT_SYMBOL
 0x00000000	crypto_register_shash	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	inet6_unregister_protosw	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_register_hooks	vmlinux	EXPORT_SYMBOL
 0x00000000	pfifo_qdisc_ops	vmlinux	EXPORT_SYMBOL
 0x00000000	radix_tree_insert	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_listxattr	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	find_get_pages_contig	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_tx_status	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_state_walk_done	vmlinux	EXPORT_SYMBOL
 0x00000000	qdisc_create_dflt	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_defer_kevent	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	uart_add_one_port	vmlinux	EXPORT_SYMBOL
 0x00000000	ewma_init	vmlinux	EXPORT_SYMBOL
 0x00000000	key_put	vmlinux	EXPORT_SYMBOL
@@ -4400,19 +4079,13 @@
 0x00000000	do_munmap	vmlinux	EXPORT_SYMBOL
 0x00000000	dma_sync_single_range_for_cpu	vmlinux	EXPORT_SYMBOL
 0x00000000	dma_sync_sg_for_cpu	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_aalg_get_byname	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_state_flush	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_interval_list	vmlinux	EXPORT_SYMBOL
 0x00000000	mmc_align_data_size	vmlinux	EXPORT_SYMBOL
 0x00000000	fat_flush_inodes	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_find_acq_byseq	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_policy_unregister_afinfo	vmlinux	EXPORT_SYMBOL
 0x00000000	__rtnl_af_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	schedule_timeout_interruptible	vmlinux	EXPORT_SYMBOL
 0x00000000	bitmap_allocate_region	vmlinux	EXPORT_SYMBOL
 0x00000000	memory_read_from_buffer	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_probereq_get	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_get_acqseq	vmlinux	EXPORT_SYMBOL
 0x00000000	__scsi_iterate_devices	vmlinux	EXPORT_SYMBOL
 0x00000000	svc_reserve	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	spi_register_driver	vmlinux	EXPORT_SYMBOL_GPL
@@ -4421,8 +4094,6 @@
 0x00000000	skb_abort_seq_read	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_soc_cnew	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_sense_desc_find	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_rate_control_unregister	vmlinux	EXPORT_SYMBOL
-0x00000000	inet6_ioctl	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_setsockopt	vmlinux	EXPORT_SYMBOL
 0x00000000	tcp_getsockopt	vmlinux	EXPORT_SYMBOL
 0x00000000	rtnl_unicast	vmlinux	EXPORT_SYMBOL
@@ -4439,7 +4110,6 @@
 0x00000000	crypto_tfm_in_queue	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	fget_raw	vmlinux	EXPORT_SYMBOL
 0x00000000	atomic_notifier_call_chain	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_send_unprot_deauth	vmlinux	EXPORT_SYMBOL
 0x00000000	spi_add_device	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sysctl_tcp_wmem	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_unregister_hook	vmlinux	EXPORT_SYMBOL
@@ -4459,30 +4129,23 @@
 0x00000000	posix_clock_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	_clear_dcache_all	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_get_request	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_inform_bss	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_ealg_get_byid	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	device_pm_wait_for_dev	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_ft_tab	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_fl_tab	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_it_tab	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	crypto_il_tab	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	down_timeout	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_get_tkip_key	vmlinux	EXPORT_SYMBOL
 0x00000000	nfnetlink_has_listeners	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	msecs_to_jiffies	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_suspend_all	vmlinux	EXPORT_SYMBOL
 0x00000000	misc_deregister	vmlinux	EXPORT_SYMBOL
 0x00000000	blkdev_fsync	vmlinux	EXPORT_SYMBOL
 0x00000000	lookup_one_len	vmlinux	EXPORT_SYMBOL
-0x00000000	inet6_bind	vmlinux	EXPORT_SYMBOL
 0x00000000	register_inetaddr_notifier	vmlinux	EXPORT_SYMBOL
-0x00000000	unregister_sound_mixer	vmlinux	EXPORT_SYMBOL
 0x00000000	atomic_dec_and_mutex_lock	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_ap_probereq_get	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_lib_write	vmlinux	EXPORT_SYMBOL
 0x00000000	devres_add	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	devres_get	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_data_to_8023	vmlinux	EXPORT_SYMBOL
 0x00000000	sync_inodes_sb	vmlinux	EXPORT_SYMBOL
 0x00000000	unregister_chrdev_region	vmlinux	EXPORT_SYMBOL
 0x00000000	generic_writepages	vmlinux	EXPORT_SYMBOL
@@ -4519,7 +4182,6 @@
 0x00000000	param_set_charp	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_free	vmlinux	EXPORT_SYMBOL
 0x00000000	qdisc_class_hash_remove	vmlinux	EXPORT_SYMBOL
-0x00000000	snd_oss_info_register	vmlinux	EXPORT_SYMBOL
 0x00000000	dmam_alloc_noncoherent	vmlinux	EXPORT_SYMBOL
 0x00000000	transport_destroy_device	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_unregister_device	vmlinux	EXPORT_SYMBOL
@@ -4545,7 +4207,6 @@
 0x00000000	simple_write_begin	vmlinux	EXPORT_SYMBOL
 0x00000000	bdi_set_max_ratio	vmlinux	EXPORT_SYMBOL
 0x00000000	redirty_page_for_writepage	vmlinux	EXPORT_SYMBOL
-0x00000000	ieee80211_ctstoself_get	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_conntrack_htable_size	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	netdev_emerg	vmlinux	EXPORT_SYMBOL
 0x00000000	sk_stream_kill_queues	vmlinux	EXPORT_SYMBOL
@@ -4585,19 +4246,9 @@
 0x00000000	snd_lookup_minor_data	vmlinux	EXPORT_SYMBOL
 0x00000000	tty_termios_encode_baud_rate	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	inet_csk_delete_keepalive_timer	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wext_siwmlme	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwname	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_siwmode	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwmode	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_siwrate	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwrate	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_send_auth_timeout	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_state_register_afinfo	vmlinux	EXPORT_SYMBOL
 0x00000000	usb_register_device_driver	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kmem_cache_size	vmlinux	EXPORT_SYMBOL
 0x00000000	silan_amba_devs	vmlinux	EXPORT_SYMBOL
-0x00000000	regulatory_hint	vmlinux	EXPORT_SYMBOL
-0x00000000	wiphy_rfkill_start_polling	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_ioctl	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_show_extd_sense	vmlinux	EXPORT_SYMBOL
 0x00000000	kobject_get_path	vmlinux	EXPORT_SYMBOL_GPL
@@ -4615,7 +4266,6 @@
 0x00000000	cpu_bit_bitmap	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rpc_free_iostats	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rpc_destroy_wait_queue	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	wiphy_apply_custom_regulatory	vmlinux	EXPORT_SYMBOL
 0x00000000	svcauth_unix_purge	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	usb_hcd_poll_rh_status	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	device_find_child	vmlinux	EXPORT_SYMBOL_GPL
@@ -4627,7 +4277,6 @@
 0x00000000	xprt_lookup_rqst	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	writeback_inodes_sb_if_idle	vmlinux	EXPORT_SYMBOL
 0x00000000	truncate_pagecache	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_ealg_get_byidx	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	sock_no_shutdown	vmlinux	EXPORT_SYMBOL
 0x00000000	__generic_block_fiemap	vmlinux	EXPORT_SYMBOL
 0x00000000	rcu_barrier_sched	vmlinux	EXPORT_SYMBOL_GPL
@@ -4642,12 +4291,12 @@
 0x00000000	inet_peer_xrlim_allow	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_ct_attach	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_timer_global_free	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_policy_walk_init	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_lib_writev	vmlinux	EXPORT_SYMBOL
 0x00000000	driver_attach	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	commit_creds	vmlinux	EXPORT_SYMBOL
 0x00000000	__nf_ct_expect_find	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	dwc_cc_data_for_save	vmlinux	EXPORT_SYMBOL
+0x00000000	usbnet_generic_cdc_bind	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	platform_device_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	fb_register_client	vmlinux	EXPORT_SYMBOL
 0x00000000	match_hex	vmlinux	EXPORT_SYMBOL
@@ -4663,8 +4312,6 @@
 0x00000000	blkcipher_walk_done	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	page_readlink	vmlinux	EXPORT_SYMBOL
 0x00000000	account_page_writeback	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wext_siwauth	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwauth	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	nf_unregister_afinfo	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	blk_verify_command	vmlinux	EXPORT_SYMBOL
 0x00000000	kstrdup	vmlinux	EXPORT_SYMBOL
@@ -4672,7 +4319,6 @@
 0x00000000	DWC_CPU_TO_LE16	vmlinux	EXPORT_SYMBOL
 0x00000000	_atomic_dec_and_lock	vmlinux	EXPORT_SYMBOL
 0x00000000	key_update	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_register_km	vmlinux	EXPORT_SYMBOL
 0x00000000	ip_mc_dec_group	vmlinux	EXPORT_SYMBOL
 0x00000000	kasprintf	vmlinux	EXPORT_SYMBOL
 0x00000000	simple_rename	vmlinux	EXPORT_SYMBOL
@@ -4684,7 +4330,6 @@
 0x00000000	ip_queue_xmit	vmlinux	EXPORT_SYMBOL
 0x00000000	class_dev_iter_init	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scatterwalk_map	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	km_query	vmlinux	EXPORT_SYMBOL
 0x00000000	inet_release	vmlinux	EXPORT_SYMBOL
 0x00000000	rwsem_is_locked	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_queue_start_tag	vmlinux	EXPORT_SYMBOL
@@ -4699,16 +4344,13 @@
 0x00000000	tty_put_char	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	kfree	vmlinux	EXPORT_SYMBOL
 0x00000000	__rt_mutex_init	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	xfrm_state_delete	vmlinux	EXPORT_SYMBOL
 0x00000000	nf_register_sockopt	vmlinux	EXPORT_SYMBOL
 0x00000000	sock_kmalloc	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_pcm_rate_to_rate_bit	vmlinux	EXPORT_SYMBOL
 0x00000000	schedule_work_on	vmlinux	EXPORT_SYMBOL
 0x00000000	ceph_calc_file_object_mapping	vmlinux	EXPORT_SYMBOL
 0x00000000	seq_list_next	vmlinux	EXPORT_SYMBOL
-0x00000000	unregister_inet6addr_notifier	vmlinux	EXPORT_SYMBOL
 0x00000000	__kfifo_dma_out_finish_r	vmlinux	EXPORT_SYMBOL
-0x00000000	ipv6_chk_addr	vmlinux	EXPORT_SYMBOL
 0x00000000	uart_suspend_port	vmlinux	EXPORT_SYMBOL
 0x00000000	__blkdev_driver_ioctl	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	blk_alloc_queue_node	vmlinux	EXPORT_SYMBOL
@@ -4717,25 +4359,21 @@
 0x00000000	flex_array_free	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_queue_flush	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	bio_phys_segments	vmlinux	EXPORT_SYMBOL
-0x00000000	ipv6_find_tlv	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	neigh_changeaddr	vmlinux	EXPORT_SYMBOL
 0x00000000	skb_recycle_check	vmlinux	EXPORT_SYMBOL
 0x00000000	tty_unregister_ldisc	vmlinux	EXPORT_SYMBOL
 0x00000000	crypto_unregister_notifier	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	invalidate_inode_pages2	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	ceph_copy_page_vector_to_user	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_michael_mic_failure	vmlinux	EXPORT_SYMBOL
 0x00000000	ipt_do_table	vmlinux	EXPORT_SYMBOL
 0x00000000	led_classdev_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_calculate_bounce_limit	vmlinux	EXPORT_SYMBOL
 0x00000000	kmem_cache_destroy	vmlinux	EXPORT_SYMBOL
 0x00000000	add_to_page_cache_locked	vmlinux	EXPORT_SYMBOL
-0x00000000	xfrm_prepare_input	vmlinux	EXPORT_SYMBOL
 0x00000000	xt_find_target	vmlinux	EXPORT_SYMBOL
 0x00000000	vfsmount_lock_global_lock	vmlinux	EXPORT_SYMBOL
 0x00000000	rpc_proc_register	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	rpc_queue_empty	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	phy_mii_ioctl	vmlinux	EXPORT_SYMBOL
 0x00000000	vm_event_states	vmlinux	EXPORT_SYMBOL
 0x00000000	__release_region	vmlinux	EXPORT_SYMBOL
 0x00000000	complete_all	vmlinux	EXPORT_SYMBOL
@@ -4750,8 +4388,6 @@
 0x00000000	tty_get_pgrp	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	strncasecmp	vmlinux	EXPORT_SYMBOL
 0x00000000	default_llseek	vmlinux	EXPORT_SYMBOL
-0x00000000	cfg80211_wext_siwpower	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	cfg80211_wext_giwpower	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tcp_read_sock	vmlinux	EXPORT_SYMBOL
 0x00000000	snd_jack_new	vmlinux	EXPORT_SYMBOL
 0x00000000	silan_pad_enable	vmlinux	EXPORT_SYMBOL
@@ -4761,7 +4397,6 @@
 0x00000000	match_octal	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_map_kern	vmlinux	EXPORT_SYMBOL
 0x00000000	xt_register_targets	vmlinux	EXPORT_SYMBOL
-0x00000000	i2c_smbus_write_byte	vmlinux	EXPORT_SYMBOL
 0x00000000	scsi_register_driver	vmlinux	EXPORT_SYMBOL
 0x00000000	crc32c	vmlinux	EXPORT_SYMBOL
 0x00000000	vfs_fsync	vmlinux	EXPORT_SYMBOL
@@ -4772,7 +4407,6 @@
 0x00000000	current_umask	vmlinux	EXPORT_SYMBOL
 0x00000000	get_fs_type	vmlinux	EXPORT_SYMBOL
 0x00000000	ref_module	vmlinux	EXPORT_SYMBOL_GPL
-0x00000000	ieee80211_iterate_active_interfaces	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	tty_driver_kref_put	vmlinux	EXPORT_SYMBOL
 0x00000000	sock_prot_inuse_get	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	scsi_host_set_state	vmlinux	EXPORT_SYMBOL
@@ -4780,9 +4414,7 @@
 0x00000000	generic_write_end	vmlinux	EXPORT_SYMBOL
 0x00000000	call_rcu_bh	vmlinux	EXPORT_SYMBOL_GPL
 0x00000000	devm_request_threaded_irq	vmlinux	EXPORT_SYMBOL
-0x00000000	unregister_sound_dsp	vmlinux	EXPORT_SYMBOL
 0x00000000	dwc_cc_if_alloc	vmlinux	EXPORT_SYMBOL
-0x00000000	genphy_config_aneg	vmlinux	EXPORT_SYMBOL
 0x00000000	blk_start_queue	vmlinux	EXPORT_SYMBOL
 0x00000000	bio_copy_user	vmlinux	EXPORT_SYMBOL
 0x00000000	kzfree	vmlinux	EXPORT_SYMBOL
Binary files kernel-22/kernel/scripts/basic/fixdep and kernel-central/kernel/scripts/basic/fixdep differ
Binary files kernel-22/kernel/scripts/bin2c and kernel-central/kernel/scripts/bin2c differ
Binary files kernel-22/kernel/scripts/kallsyms and kernel-central/kernel/scripts/kallsyms differ
Binary files kernel-22/kernel/scripts/kconfig/conf and kernel-central/kernel/scripts/kconfig/conf differ
Binary files kernel-22/kernel/scripts/kconfig/mconf and kernel-central/kernel/scripts/kconfig/mconf differ
Binary files kernel-22/kernel/scripts/mod/mk_elfconfig and kernel-central/kernel/scripts/mod/mk_elfconfig differ
Binary files kernel-22/kernel/scripts/mod/modpost and kernel-central/kernel/scripts/mod/modpost differ
diff --no-dereference -Nru kernel-22/kernel/sound/soc/silan/dlna_i2s.c kernel-central/kernel/sound/soc/silan/dlna_i2s.c
--- kernel-22/kernel/sound/soc/silan/dlna_i2s.c	2017-01-18 12:55:16.000000000 +0200
+++ kernel-central/kernel/sound/soc/silan/dlna_i2s.c	2017-02-12 11:12:01.804709715 +0200
@@ -53,13 +53,16 @@
 		writel(clk_cr, dev->i2s_params[0].regs + CLK_CTRL);
 
 		writel(imr_x, dev->i2s_params[0].regs + IMR_X(0));
+
 	}
 	else
 	{
-		//cr &= ~RTXEN;
-		//ctrl &= ~ITXEN;
-		//cr |= RTFF;
-		//ctrl |= TXFLUSH;
+/*
+		cr &= ~RTXEN;
+		ctrl &= ~ITXEN;
+		cr |= RTFF;
+		ctrl |= TXFLUSH;
+*/
 	}
 
 	writel(ctrl, dev->i2s_params[0].regs + IIS_CTRL);
@@ -142,6 +145,8 @@
 		return -EINVAL;
 	}
 
+printk("--- [GRIF] --- i2s: %s chnl (%d)\n", substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "out" : "in", chnl);
+
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
 		cr |= WLEN_16BIT<<RTWLEN_SHIFT;
@@ -220,6 +225,8 @@
 static void silan_i2s_hdmi_start(struct silan_i2s_hdmi_dev *dev, 
 				struct snd_pcm_substream *substream)
 {
+printk("--- [GRIF] --- i2s: start\n");
+
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		silan_snd_txctrl(dev, 1);
 	else
@@ -229,6 +236,8 @@
 static void silan_i2s_hdmi_stop(struct silan_i2s_hdmi_dev *dev, 
 				struct snd_pcm_substream *substream)
 {
+printk("--- [GRIF] --- i2s: stop\n");
+
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		silan_snd_txctrl(dev, 0);
 	else
@@ -241,6 +250,8 @@
 	struct silan_i2s_hdmi_dev *dev = snd_soc_dai_get_drvdata(dai);
 	int ret = 0;
 
+printk("--- [GRIF] --- i2s: trigger\n");
+
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
@@ -264,6 +275,8 @@
 {
 	struct silan_i2s_hdmi_dev *dev = snd_soc_dai_get_drvdata(dai);
 
+printk("--- [GRIF] --- i2s: startup\n");
+
 	if(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		dev->dma_params[0].dma_addr = (dma_addr_t)(dev->i2s_params[0].phy_base + TFR_X(0));
 		snd_soc_dai_set_dma_data(dai, substream, &dev->dma_params[0]);
@@ -309,6 +322,8 @@
 		writel(TXFOM | TXFEM | RXFOM | RXDAM, dev->i2s_params[i].regs + IMR_X(0));
 	}
 
+printk("--- [GRIF] --- i2s: probe\n");
+
 	return 0;
 }
 
@@ -372,6 +387,8 @@
 
 		writel(TXFOM | TXFEM | RXFOM | RXDAM, dev->i2s_params[i].regs + IMR_X(0));
     }
+
+printk("--- [GRIF] --- i2s: shutdown\n");
 }
 
 #ifdef CONFIG_PM_SLEEP
diff --no-dereference -Nru kernel-22/kernel/sound/soc/silan/silan_codec.c kernel-central/kernel/sound/soc/silan/silan_codec.c
--- kernel-22/kernel/sound/soc/silan/silan_codec.c	2017-01-18 12:55:16.000000000 +0200
+++ kernel-central/kernel/sound/soc/silan/silan_codec.c	2017-02-12 09:22:23.387188189 +0200
@@ -169,6 +169,8 @@
 {
 	u32 val = 0;
 
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	if(cnt < 0 || cnt >= 8){
 		printk("The offset of the reg 0x%x if out of range\n", offset);
 		return;
@@ -192,7 +194,8 @@
 static int slinner_read_param(void __iomem *base, int offset, int cnt)
 {
 	u32 val = 0;
-	
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	if(cnt < 0 || cnt >= 8){
 		printk("The offset of the reg 0x%x if out of range\n", offset);
 		return -1;
@@ -208,7 +211,8 @@
 {
 	u32 val = 0, val1 = 0;
 	u8 i = 0;
-	
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	if(cnt < 0 || cnt >= 8){
 		printk("The offset of the reg 0x%x if out of range\n", offset);
 		return;
@@ -234,7 +238,8 @@
 {
 	u32 val = 0, val1 = 0;
 	u8 i = 0;
-	
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	if(cnt < 0 || cnt >= 8){
 		printk("The offset of the reg 0x%x if out of range\n", offset);
 		return -1;
@@ -252,107 +257,136 @@
 
 static void slinner_dac_enable(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	slinner_set_param1(base, 0x03, CR1, 2, 0);
 }
 
 static void slinner_linebypass_enable(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	slinner_set_param1(base, 0x02, CR1, 2, 0);
 }
 
 static void slinner_micbypass_enable(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	slinner_set_param1(base, 0x01, CR1, 2, 0);
 }
 
 static void slinner_hp_mute(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	slinner_set_param(base, 0x01, CR1, enable, 5);
 }
 
 static void slinner_line_out(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	slinner_set_param(base, 0x01, CR1, ENABLE, 7);
 }
 
 static void slinner_headphone_out(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	slinner_set_param(base, 0x01, CR1, DISABLE, 7);
 }
 
 #ifdef EXTER
 static void slinner_dac_mono(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	slinner_set_param(base, 0x01, CR2, ENABLE, 7);
 }
 #endif
 
 static void slinner_dac_stereo(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	slinner_set_param(base, 0x01, CR2, DISABLE, 7);
 }
 
 static void slinner_dac_mute(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	slinner_set_param(base, 0x01, CR2, enable, 5);
 }
 
 #ifdef EXTER
 static void slinner_dock_mode(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
+
 	slinner_set_param(base, 0x01, CR2, DISABLE, 1);
 }
 #endif
 
 static void slinner_nomad_mode(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, CR2, ENABLE, 1);
 }
 
 #ifdef EXTER
 static void slinner_dac_left_only(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, CR2, enable, 0);
 }
 #endif
 
 static void slinner_adc_line_in(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, 0x02, CR3, 2, 2);
 }
 
 static void slinner_adc_mic1_in(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, 0x0, CR3, 2, 2);
 }
 
 #ifdef EXTER
 static void slinner_adc_mic2_in(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, 0x1, CR3, 2, 2);
 }
 #endif
 
 static void slinner_mic_stereo(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, CR3, ENABLE, 1);
 }
 
 #ifdef EXTER
 static void slinner_mic_mono(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, CR3, DISABLE, 1);
 }
 #endif
 
 static void slinner_mic_single_mode(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, CR3, DISABLE, 0);
 }
 
 #ifdef EXTER
 static void slinner_mic_diff_mode(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, CR3, ENABLE, 0);
 }
 #endif
@@ -360,17 +394,20 @@
 #ifdef EXTER
 static void slinner_adc_hpf(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, CR4, enable, 7);
 }
 
 static void slinner_adc_left_only(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, CR4, enable, 0);
 }
 #endif
 
 static void slinner_set_format(void __iomem *base, u8 value, int stream)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	u32 val = 0;
 	val = readl(base+AICR);
 	val |= 0xf;	
@@ -388,6 +425,7 @@
 
 static int slinner_set_rate(void __iomem *base, u8 value, int stream)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	u32 val = 0;
 	val = readl(base+CCR2);
 	
@@ -406,23 +444,27 @@
 
 static void slinner_pmr1(void __iomem *base, int enable, int cnt)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, PMR1, enable, cnt);
 }
 
 static void slinner_sb(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_pmr1(base, enable, 7);
 }
 
 //sleep mode
 static void slinner_sb_sleep(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_pmr1(base, enable, 6);
 }
 
 //complete aip(micbias, microphone and line inputs)
 static void slinner_sb_aip(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_pmr1(base, !enable, 5);
 }
 
@@ -430,6 +472,7 @@
 //stereo line input 
 static void slinner_sb_line(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_pmr1(base, !enable, 4);
 }
 //#endif
@@ -437,12 +480,14 @@
 //analog mic1 input 
 static void slinner_sb_mic1(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_pmr1(base, !enable, 3);
 }
 
 //analog mic2 input 
 static void slinner_sb_mic2(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_pmr1(base, !enable, 2);
 }
 
@@ -450,6 +495,7 @@
 //analog line input(bypass) 
 static void slinner_sb_bypass(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_pmr1(base, !enable, 1);
 }
 //#endif
@@ -457,32 +503,38 @@
 //microphone biasing buffer
 static void slinner_sb_micbias(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_pmr1(base, !enable, 0);
 }
 
 static void slinner_pmr2(void __iomem *base, int enable, int cnt)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, PMR2, enable, cnt);
 }
 
 static void slinner_sb_adc(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_pmr2(base, !enable, 4);
 }
 
 //headphone output stage
 static void slinner_sb_hp(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_pmr2(base, !enable, 3);
 }
 
 static void slinner_sb_dac(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_pmr2(base, !enable, 0);
 }
 
 static void slinner_icr(void __iomem *base, int enable, int cnt)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, ICR, enable, cnt);
 }
 
@@ -490,38 +542,45 @@
 //Event on output jack plug detection
 static void slinner_jack(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_icr(base, !enable, 5);
 }
 #endif
 
 static void slinner_scmc(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_icr(base, !enable, 4);
 }
 
 #ifdef EXTER
 static void slinner_rup(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_icr(base, !enable, 3);
 }
 
 static void slinner_rdo(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_icr(base, !enable, 2);
 }
 
 static void slinner_gup(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_icr(base, !enable, 1);
 }
 
 static void slinner_gdo(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_icr(base, !enable, 0);
 }
 
 static void slinner_ifr(void __iomem *base, int enable, int cnt)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, IFR, enable, cnt);
 }
 #endif
@@ -530,6 +589,7 @@
 //hp amplifier gain coupling
 static void slinner_lrgo(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, GCR1, enable, 7);
 }
 #endif
@@ -537,22 +597,26 @@
 //left channel hp amplifier gain programming value
 static void slinner_hp_gol(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, GCR1, 5, 0);
 }
 
 static int slinner_get_hp_gol(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, GCR1, 5, 0);
 }
 
 //right channel hp amplifier gain programming value
 static void slinner_hp_gor(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, GCR2, 5, 0);
 }
 
 static int slinner_get_hp_gor(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, GCR2, 5, 0);
 }
 
@@ -561,6 +625,7 @@
 #ifdef EXTER
 static void slinner_lrgi(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, GCR3, 1, 7);
 }
 #endif
@@ -568,22 +633,26 @@
 //left channel line in gain programming value
 static void slinner_bypass_gil(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, GCR3, 5, 0);
 }
 
 static int slinner_get_bypass_gil(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, GCR3, 5, 0);
 }
 
 //right channel line in gain programming value
 static void slinner_bypass_gir(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, GCR4, 5, 0);
 }
 
 static int slinner_get_bypass_gir(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, GCR4, 5, 0);
 }
 
@@ -591,6 +660,7 @@
 //dac digital gain coupling
 static void slinner_lrgod(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, GCR5, enable, 7);
 }
 #endif
@@ -598,43 +668,51 @@
 //left channel dac digital gain programming value
 static void slinner_dac_godl(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, GCR5, 5, 0);
 }
 
 static int slinner_get_dac_godl(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, GCR5, 5, 0);
 }
 //right channel dac digital gain programming value
 static void slinner_dac_godr(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, GCR6, 5, 0);
 }
 
 static int slinner_get_dac_godr(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, GCR6, 5, 0);
 }
 
 //microphone 1 boot stage gain programming value
 static void slinner_mic_gim1(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, GCR7, 3, 3);
 }
 
 static int slinner_get_mic_gim1(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, GCR7, 3, 3);
 }
 
 //microphone 2 boot stage gain programming value
 static void slinner_mic_gim2(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, GCR7, 3, 0);
 }
 
 static int slinner_get_mic_gim2(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, GCR7, 3, 0);
 }
 
@@ -642,6 +720,7 @@
 //adc digital gain coupling
 static void slinner_lrgid(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, GCR8, enable, 7);
 }
 #endif
@@ -649,22 +728,26 @@
 //left channel adc digital gain programming value
 static void slinner_adc_gidl(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, GCR8, 5, 0);
 }
 
 static int slinner_get_adc_gidl(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, GCR8, 5, 0);
 }
 
 //right channel adc digital gain programming value
 static void slinner_adc_gidr(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, GCR9, 5, 0);
 }
 
 static int slinner_get_adc_gidr(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, GCR9, 5, 0);
 }
 
@@ -672,6 +755,7 @@
 //selection of the AGC system
 static void slinner_agc_en(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, AGC1, enable, 7);
 }
 #endif
@@ -680,36 +764,42 @@
 //target output level of the adc
 static void slinner_target(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, AGC1, 4, 2);
 }
 
 //selection of the Noise Gate system
 static void slinner_ng_en(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, AGC2, enable, 7);
 }
 
 //Noise Gate Threshold value
 static void slinner_ng_thr(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, AGC2, 3, 4);
 }
 
 //Hold time before starting AGC adjustment to the target value
 static void slinner_hold(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, AGC2, 4, 0);
 }
 
 //Attack Time-Gain Ramp Down
 static void slinner_atk(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, AGC3, 4, 4);
 }
 
 //Decay Time - Gain Ramp up
 static void slinner_dcy(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, AGC3, 4, 0);
 }
 #endif
@@ -718,12 +808,14 @@
 //Maximum Gain Value to apply to the ADC path
 static void slinner_agc_max(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, AGC4, 5, 0);
 }
 
 //Minimum Gain Value to apply to the ADC path
 static void slinner_agc_min(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, AGC5, 5, 0);
 }
 #endif
@@ -731,45 +823,53 @@
 //Mixer mode on ADC path
 static void slinner_adc_mix_rec(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, MIX1, 2, 6);
 }
 
 //Mixer gain for input path
 static void slinner_adc_gimix(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, MIX1, 5, 0);
 }
 
 static int slinner_get_adc_gimix(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, MIX1, 5, 0);
 }
 
 //Mixer mode on DAC path
 static void slinner_dac_mix_rec(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, MIX2, 2, 6);
 }
 
 //Mixer gain for dac path
 static void slinner_dac_gomix(void __iomem *base, int value)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param1(base, value, MIX2, 5, 0);
 }
 
 static int slinner_get_dac_gomix(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	return slinner_get_param1(base, MIX2, 5, 0);
 }
 
 static void slinner_fast_on(void __iomem *base, int enable)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_set_param(base, 0x01, TR1, enable, 0);
 }
 
 static void slinner_codec_reset(void)
 {
 	int value;
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
         
 	value = readl(CODEC_SW_REG);
     value &= ~CODEC_SW_RESETn;
@@ -780,6 +880,7 @@
 
 static void slinner_clk_init(void __iomem *crbase)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	u32 value;
 
 	//enable mc_clk
@@ -803,6 +904,7 @@
 
 static void slinner_irq_init(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	// Init codec irq mask as 0xe0
 	writel(0x2f, base+ICR);
 }
@@ -810,6 +912,7 @@
 static void slinner_dac_init(void __iomem *base)
 {
 	int init_cnt = 3, time_out = 0;
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 
 	while (init_cnt--)
 	{
@@ -888,6 +991,7 @@
 
 static void slinner_linein_init(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_adc_line_in(base);
 
 	slinner_sb_aip(base, ENABLE);
@@ -901,6 +1005,7 @@
 
 static void slinner_mic_init(void __iomem *base)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_mic_stereo(base);
 	
 	slinner_adc_mic1_in(base);
@@ -920,6 +1025,7 @@
 
 static void slinner_init(void __iomem *base, void __iomem *crbase)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	slinner_clk_init(crbase);
 
 	slinner_dac_init(base);
@@ -929,6 +1035,7 @@
 
 static void set_sample_rate(void __iomem *base, int sample, int stream)
 {
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	u8 val = -1;
 	switch (sample) {
 		case 8000:
@@ -971,6 +1078,7 @@
 static void set_bit_format(void __iomem *base, int format, int stream)
 {
 	u8 val = -1;
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 
 	switch (format) {
 		case SNDRV_PCM_FORMAT_S16_LE:
@@ -1003,6 +1111,7 @@
 	struct snd_soc_codec *codec = dai->codec;
 	struct slinner_priv *slinner = snd_soc_codec_get_drvdata(codec);
 	
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	set_bit_format(slinner->base, params_format(params), substream->stream);
 
 	set_sample_rate(slinner->base, params_rate(params), substream->stream);
@@ -1015,11 +1124,13 @@
 static int slinner_set_dai_fmt(struct snd_soc_dai *codec_dai,
 		unsigned int fmt)
 {
+printk("--- [GRIF - %s:%d] --- dummy\n", __func__, __LINE__);
 	return 0;
 }
 static int slinner_set_dai_sysclk(struct snd_soc_dai *codec_dai,
 		int clk_id, unsigned int freq, int dir)
 {
+printk("--- [GRIF - %s:%d] --- dummy\n", __func__, __LINE__);
 	return 0;
 }
 
@@ -1027,6 +1138,7 @@
 static int slinner_set_bias_level(struct snd_soc_codec *codec,
 				 enum snd_soc_bias_level level)
 {
+printk("--- [GRIF - %s:%d] --- dummy\n", __func__, __LINE__);
 	return 0;
 }
 #endif
@@ -1038,6 +1150,7 @@
 
 	//slinner_dac_mute(slinner->base, mute);
 	//slinner_hp_mute(slinner->base, mute);
+printk("--- [GRIF - %s:%d] --- dummy\n", __func__, __LINE__);
 
 	return 0;
 }
@@ -1070,17 +1183,20 @@
 
 static int slinner_suspend(struct snd_soc_codec *codec, pm_message_t state)
 {
+printk("--- [GRIF - %s:%d] --- dummy\n", __func__, __LINE__);
 	return 0;
 }
 
 static int slinner_resume(struct snd_soc_codec *codec)
 {
+printk("--- [GRIF - %s:%d] --- dummy\n", __func__, __LINE__);
 	return 0;
 }
 
 static int slinner_resume_hp(void __iomem *base)
 {
     int time_out;
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 
     slinner_sb_hp(base, DISABLE);
 
@@ -1123,6 +1239,7 @@
 {
 	int value = slinner_def->icr_value;
     int time_out;
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 
     if((value & CODEC_IRQ_SCMC) != 0) {
 		printk("## %08x: codec output short detect! ##\n", value);
@@ -1151,6 +1268,7 @@
 {
 	struct slinner_priv *slinner = (struct slinner_priv *)dev;
 	int value = readl(slinner->base+IFR);
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	
 	// clear related interrupt
 	writel(value, slinner->base+IFR);
@@ -1187,6 +1305,7 @@
 	struct slinner_priv *slinner = snd_soc_codec_get_drvdata(codec);
     u32	val = 0;	
 	//printk("##### %s %d reg: 0x%x\n", __func__, __LINE__, reg);
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 	
 	switch(reg){
 		case MIX2:
@@ -1205,6 +1324,7 @@
 	//struct slinner_priv *slinner = snd_soc_codec_get_drvdata(codec);
 	
 	//printk("##### %s %d reg: 0x%x, value: 0x%x\n", __func__, __LINE__, reg, value);
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 
 	switch(reg){
 		case MIX2:
@@ -1235,6 +1355,7 @@
 {
 //	struct slinner_priv *slinner = container_of(fp->private_data,
 //					     struct slinner_priv, miscdev);
+printk("--- [GRIF - %s:%d] --- dummy\n", __func__, __LINE__);
 	return 0;
 }
 
@@ -1248,6 +1369,7 @@
 	struct slinner_priv *slinner = filp->private_data;
     int ret = 0;
 	struct codec_priv param;
+printk("--- [GRIF - %s:%d] ---\n", __func__, __LINE__);
 
 	if(argp != 0){
 		if(copy_from_user(&param,(struct codec_priv *)argp, sizeof(param)))
diff --no-dereference -Nru kernel-22/kernel/sound/soc/silan/suv_dwc.c kernel-central/kernel/sound/soc/silan/suv_dwc.c
--- kernel-22/kernel/sound/soc/silan/suv_dwc.c	2017-02-10 04:09:42.025799962 +0200
+++ kernel-central/kernel/sound/soc/silan/suv_dwc.c	2017-02-12 10:09:28.482435982 +0200
@@ -113,8 +113,11 @@
 static struct snd_soc_dai_link suv_i2s_wmcodec_dai_link = {
     .name = "IIS CODEC",
 	.stream_name = "IIS CODEC",
-    .codec_name = "silan-wmcodec",
-    .codec_dai_name = "silan-wmcodec-dai",
+//    .codec_name = "silan-wmcodec",
+//    .codec_dai_name = "silan-wmcodec-dai",
+	.codec_name = "silan-spdcodec",
+	.codec_dai_name = "silan-spdcodec-dai",
+
     .cpu_dai_name = "silan-i2s-hdmi",
 	.platform_name = "silan-pcm",
 	.ops = &suv_dwc_ops,
@@ -193,6 +196,7 @@
 	}
 
 	for(i=0; i < SND_CARD_NUM; i++) {
+//	for(i=0; i < 1; i++) {
 		platform_set_drvdata(suv_dwc_snd_device[i], &snd_soc_suv_card[i]);
 		ret = platform_device_add(suv_dwc_snd_device[i]);
 		if (ret) {
@@ -209,6 +213,7 @@
 	int i;
 
 	for(i=0; i < SND_CARD_NUM; i++) 
+//	for(i=0; i < 1; i++) 
 		platform_device_unregister(suv_dwc_snd_device[i]);
 }
 
diff --no-dereference -Nru kernel-22/kernel/sound/soc/silan/suv_pcm.c kernel-central/kernel/sound/soc/silan/suv_pcm.c
--- kernel-22/kernel/sound/soc/silan/suv_pcm.c	2017-01-18 12:55:16.000000000 +0200
+++ kernel-central/kernel/sound/soc/silan/suv_pcm.c	2017-02-12 13:13:12.244200147 +0200
@@ -72,6 +72,7 @@
 static void audio_dma_complete(void *data)
 {
 	struct sl_pcm_runtime_data *prtd = (struct sl_pcm_runtime_data *)data;
+//printk("--- [GRIF - %s:%d] --- in\n", __func__, __LINE__);
 	
 #ifdef CONFIG_SILAN_DMA_LLI_INT
 	prtd->endInt_flag = !prtd->endInt_flag;
@@ -88,11 +89,14 @@
 		dma_tasklet((unsigned long)prtd);
 //		tasklet_schedule(&prtd->tasklet);
 	}
+//printk("--- [GRIF - %s:%d] --- out\n", __func__, __LINE__);
+
 }
 
 static bool filter(struct dma_chan *chan, void *param)
 {
 	struct sl_pcm_runtime_data *prtd = param;
+printk("--- [GRIF - %s:%d] --- in %s chan(%d:%d)\n", __func__, __LINE__, dev_name(chan->device->dev), chan->chan_id, prtd->dma_data.dma_request);
 	
 #ifdef CONFIG_MIPS_SILAN_DLNA
 	if((strcmp(dev_name(chan->device->dev), DMAC0_NAME) != 0) || (chan->chan_id != prtd->dma_data.dma_request))
@@ -100,6 +104,7 @@
 	if((strcmp(dev_name(chan->device->dev), DMAC1_NAME) != 0) || (chan->chan_id != prtd->dma_data.dma_request))
 #endif
 		return false;
+printk("--- [GRIF - %s:%d] --- out\n", __func__, __LINE__);
 
 	chan->private = &prtd->dma_data;
 	return true;
@@ -115,6 +120,7 @@
 	dma_cap_mask_t mask;
 	enum dma_slave_buswidth buswidth;
 	int ret;
+printk("--- [GRIF - %s:%d] --- in\n", __func__, __LINE__);
 
 	dma_params = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream); 
 
@@ -166,6 +172,7 @@
 	ret = dmaengine_slave_config(prtd->dma_chan, &slave_config);
 	if(ret)
 		return ret;
+printk("--- [GRIF - %s:%d] --- out (chan %d)\n", __func__, __LINE__, prtd->dma_chan->chan_id);
 	return 0;
 }
 
@@ -174,6 +181,7 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct sl_pcm_runtime_data *prtd = runtime->private_data;
 	int ret;
+printk("--- [GRIF - %s:%d] --- \n", __func__, __LINE__);
 
 	ret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
 	if(ret < 0) {
@@ -201,6 +209,7 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct sl_pcm_runtime_data *prtd = runtime->private_data;
 	
+printk("--- [GRIF - %s:%d] --- \n", __func__, __LINE__);
 	tasklet_kill(&prtd->tasklet);
 	if(prtd->dma_chan) {
 		dmaengine_terminate_all(prtd->dma_chan);
@@ -219,6 +228,7 @@
   //  long long t_tm;
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct sl_pcm_runtime_data *prtd = runtime->private_data;
+printk("--- [GRIF - %s:%d] --- \n", __func__, __LINE__);
 	
 	prtd->dma_addr = runtime->dma_addr;
 	prtd->buffer_bytes = snd_pcm_lib_buffer_bytes(substream);	
@@ -251,6 +261,8 @@
 	struct dma_chan *chan = prtd->dma_chan;
 	struct dma_async_tx_descriptor *desc;
 	struct scatterlist sg;
+	dma_cookie_t cookie;
+//printk("--- [GRIF - %s:%d] --- in \n", __func__, __LINE__);
 
 	sg_init_table(&sg, 1);
 
@@ -270,8 +282,12 @@
 
 	desc->callback = audio_dma_complete;
 	desc->callback_param = prtd;
-	desc->tx_submit(desc);
+	cookie = desc->tx_submit(desc);
+
+if (cookie < 0)
+printk("--- [GRIF - %s:%d] --- Failed to submit a dma transfer \n", __func__, __LINE__);
 
+//printk("--- [GRIF - %s:%d] --- out \n", __func__, __LINE__);
 	return desc;
 }
 
@@ -328,6 +344,7 @@
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct sl_pcm_runtime_data *prtd = runtime->private_data;
+printk("--- [GRIF - %s:%d] --- cmd:%d \n", __func__, __LINE__, cmd);
 
 	switch(cmd) {
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
@@ -350,11 +367,13 @@
 	default:
 		return -EINVAL;
 	}	
+printk("--- [GRIF - %s:%d] --- out \n", __func__, __LINE__);
 	return 0;
 }
 
 static snd_pcm_uframes_t silan_pcm_pointer(struct snd_pcm_substream *substream)
 {
+//printk("--- [GRIF - %s:%d] --- in \n", __func__, __LINE__);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct sl_pcm_runtime_data *prtd = runtime->private_data;
 #ifdef CONFIG_SILAN_DMA_LLI_INT
@@ -387,8 +406,10 @@
 	}
 #endif
 
+printk("--- [GRIF - %s:%d] --- out \n", __func__, __LINE__);
 	return bytes_to_frames(substream->runtime, res);
 #else
+//printk("--- [GRIF - %s:%d] --- out %lu\n", __func__, __LINE__, prtd->pos);
 	return bytes_to_frames(substream->runtime, prtd->pos);
 #endif
 }
@@ -399,6 +420,8 @@
 	struct sl_pcm_runtime_data *prtd;
 	int ret;
 
+printk("--- [GRIF - %s:%d] --- in \n", __func__, __LINE__);
+
 	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
 	if(prtd == NULL)
 		return -ENOMEM;
@@ -417,6 +440,8 @@
 		return ret;
 	}
 	
+printk("--- [GRIF - %s:%d] --- out \n", __func__, __LINE__);
+
 	return 0;
 }
 
@@ -425,6 +450,8 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct sl_pcm_runtime_data *prtd = runtime->private_data;
 
+printk("--- [GRIF - %s:%d] --- \n", __func__, __LINE__);
+
 	if(!prtd)
 		printk("dma_close called with prtd == NULL\n");
 
@@ -438,6 +465,8 @@
 	vma->vm_flags |= VM_IO | VM_RESERVED;
 	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
 
+printk("--- [GRIF - %s:%d] --- \n", __func__, __LINE__);
+
 	return remap_pfn_range(vma, vma->vm_start, 
 				substream->dma_buffer.addr >> PAGE_SHIFT,
 				vma->vm_end - vma->vm_start, vma->vm_page_prot);
diff --no-dereference -Nru kernel-22/kernel/.version kernel-central/kernel/.version
--- kernel-22/kernel/.version	2017-01-18 13:08:23.000000000 +0200
+++ kernel-central/kernel/.version	2017-02-12 13:13:57.124580820 +0200
@@ -1 +1 @@
-1
+36
